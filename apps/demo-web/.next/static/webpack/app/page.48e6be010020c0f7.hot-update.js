"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/agent/openai-realtime.ts":
/*!**************************************!*\
  !*** ./lib/agent/openai-realtime.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OpenAIRealtimeAgent: function() { return /* binding */ OpenAIRealtimeAgent; }\n/* harmony export */ });\nclass OpenAIRealtimeAgent {\n    setCalendarIds(ids) {\n        this.calendarIds = ids && ids.length ? [\n            ...ids\n        ] : undefined;\n    }\n    requireTool(name, opts) {\n        // Cancel any current generation and require a tool call\n        try {\n            this.sendOAI({\n                type: \"response.cancel\"\n            });\n        } catch (e) {}\n        const instructions = name === \"slots\" ? \"User asked for day availability. Call getAvailableSlots with the requested date (YYYY-MM-DD). Do not state times unless they come from the tool result.\" : \"User asked for a specific time. Call checkAvailability with start at that exact local time and end=start+60 minutes (unless user specified a duration). Do not speak availability before tool result.\";\n        this.sendOAI({\n            type: \"response.create\",\n            response: {\n                instructions,\n                tool_choice: \"required\",\n                modalities: [\n                    \"audio\",\n                    \"text\"\n                ]\n            }\n        });\n        this.awaitingTool = true;\n        if (this.awaitingToolTimer) clearTimeout(this.awaitingToolTimer);\n        this.awaitingToolTimer = setTimeout(()=>{\n            if (this.awaitingTool) {\n                // Re-prompt once\n                this.sendOAI({\n                    type: \"response.create\",\n                    response: {\n                        instructions,\n                        tool_choice: \"required\",\n                        modalities: [\n                            \"audio\",\n                            \"text\"\n                        ]\n                    }\n                });\n            }\n        }, 2000);\n        // Fallback after 3500ms for specific-time queries: parse transcript and call API directly\n        if (name === \"check\") {\n            if (this.fallbackTimer) clearTimeout(this.fallbackTimer);\n            this.fallbackTimer = setTimeout(()=>{\n                if (!this.awaitingTool) return;\n                const parsed = this.parseSlotFromTranscript(this.lastTranscript, this.tz);\n                if (!parsed) return;\n                const organizationId = this.defaultOrgId;\n                const calendarId = this.defaultCalendarId;\n                fetch(\"/api/calendar/check-availability\", {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: JSON.stringify({\n                        organizationId,\n                        start: parsed.start,\n                        end: parsed.end,\n                        calendarId,\n                        calendarIds: this.calendarIds\n                    })\n                }).then(async (r)=>({\n                        ok: r.ok,\n                        j: await r.json().catch(()=>({}))\n                    })).then((param)=>{\n                    let { ok, j } = param;\n                    this.awaitingTool = false;\n                    if (ok && (j === null || j === void 0 ? void 0 : j.available) === true) {\n                        this.speak(\"That time is available: \".concat(this.fmtRange(j.start || parsed.start, j.end || parsed.end, j.timeZone || this.tz), \". Should I book it?\"));\n                    } else if (ok && (j === null || j === void 0 ? void 0 : j.available) === false) {\n                        const date = (j.start || parsed.start).slice(0, 10);\n                        fetch(\"/api/calendar/slots\", {\n                            method: \"POST\",\n                            headers: {\n                                \"Content-Type\": \"application/json\"\n                            },\n                            body: JSON.stringify({\n                                date,\n                                slotMinutes: 60,\n                                calendarIds: this.calendarIds\n                            })\n                        }).then(async (r2)=>({\n                                ok2: r2.ok,\n                                j2: await r2.json().catch(()=>({}))\n                            })).then((param)=>{\n                            let { ok2, j2 } = param;\n                            if (ok2 && Array.isArray(j2 === null || j2 === void 0 ? void 0 : j2.slots) && j2.slots.length) {\n                                const list = j2.slots.slice(0, 5).map((it)=>this.fmtRange(it.start, it.end, j2.timeZone || this.tz)).join(\", \");\n                                this.speak(\"That time is not available. Here are some options: \".concat(list, \".\"));\n                            } else {\n                                this.speak(\"That time is not available and I could not retrieve alternative slots.\");\n                            }\n                        });\n                    } else {\n                        this.speak(\"I could not verify that time just now.\");\n                    }\n                }).catch(()=>this.speak(\"I could not verify that time just now.\"));\n            }, 3500);\n        }\n    }\n    speak(text) {\n        var _this_onToolEvent, _this;\n        (_this_onToolEvent = (_this = this).onToolEvent) === null || _this_onToolEvent === void 0 ? void 0 : _this_onToolEvent.call(_this, {\n            kind: \"event\",\n            type: \"spoken\",\n            text\n        });\n        this.sendOAI({\n            type: \"response.create\",\n            response: {\n                instructions: text,\n                modalities: [\n                    \"audio\",\n                    \"text\"\n                ]\n            }\n        });\n    }\n    fmtTime(iso, tz) {\n        try {\n            const d = new Date(iso);\n            const fmt = new Intl.DateTimeFormat(\"en-US\", {\n                timeZone: tz,\n                hour: \"2-digit\",\n                minute: \"2-digit\"\n            });\n            return fmt.format(d);\n        } catch (e) {\n            return iso;\n        }\n    }\n    fmtRange(startIso, endIso, tz) {\n        return \"\".concat(this.fmtTime(startIso, tz), \" â€“ \").concat(this.fmtTime(endIso, tz));\n    }\n    async connect(systemPrompt, opts) {\n        var _session_client_secret;\n        const session = await fetch(\"/api/realtime/token\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                systemPrompt,\n                organizationId: opts === null || opts === void 0 ? void 0 : opts.organizationId,\n                calendarId: (opts === null || opts === void 0 ? void 0 : opts.calendarId) || \"primary\",\n                greeting: opts === null || opts === void 0 ? void 0 : opts.greeting,\n                language: (opts === null || opts === void 0 ? void 0 : opts.language) || \"en-US\",\n                timeZone: opts === null || opts === void 0 ? void 0 : opts.timeZone\n            })\n        }).then((r)=>r.json());\n        if (!(session === null || session === void 0 ? void 0 : (_session_client_secret = session.client_secret) === null || _session_client_secret === void 0 ? void 0 : _session_client_secret.value) || !(session === null || session === void 0 ? void 0 : session.model)) {\n            throw new Error(\"Failed to obtain Realtime session\");\n        }\n        this.defaultOrgId = opts === null || opts === void 0 ? void 0 : opts.organizationId;\n        this.defaultCalendarId = (opts === null || opts === void 0 ? void 0 : opts.calendarId) || \"primary\";\n        this.tz = opts === null || opts === void 0 ? void 0 : opts.timeZone;\n        const pc = new RTCPeerConnection();\n        this.pc = pc;\n        pc.ontrack = (e)=>{\n            const [stream] = e.streams;\n            this.audioEl.srcObject = stream;\n            this.audioEl.play().catch(()=>{});\n        };\n        // Receive events from OpenAI\n        pc.ondatachannel = (event)=>{\n            const channel = event.channel;\n            if (channel.label !== \"oai-events\") return;\n            // Prefer the inbound channel if OpenAI creates it.\n            this.attachDataChannel(channel);\n        };\n        const dc = pc.createDataChannel(\"oai-events\");\n        this.attachDataChannel(dc);\n        this.mic = await navigator.mediaDevices.getUserMedia({\n            audio: true\n        });\n        this.mic.getTracks().forEach((t)=>pc.addTrack(t, this.mic));\n        const offer = await pc.createOffer();\n        await pc.setLocalDescription(offer);\n        const baseUrl = \"https://api.openai.com/v1/realtime\";\n        const sdpResponse = await fetch(\"\".concat(baseUrl, \"?model=\").concat(encodeURIComponent(session.model)), {\n            method: \"POST\",\n            headers: {\n                Authorization: \"Bearer \".concat(session.client_secret.value),\n                \"Content-Type\": \"application/sdp\",\n                \"OpenAI-Beta\": \"realtime=v1\"\n            },\n            body: offer.sdp\n        });\n        if (!sdpResponse.ok) {\n            const txt = await sdpResponse.text();\n            throw new Error(\"Realtime SDP error: \".concat(sdpResponse.status, \" \").concat(txt));\n        }\n        const answer = {\n            type: \"answer\",\n            sdp: await sdpResponse.text()\n        };\n        await pc.setRemoteDescription(answer);\n        // Speak the explicit greeting first (if provided), without jumping into scheduling yet\n        if (opts === null || opts === void 0 ? void 0 : opts.greeting) {\n            const safe = opts.greeting.replace(/\"/g, '\\\\\"');\n            const greetOnly = 'Say exactly: \"'.concat(safe, '\". Then stop speaking and wait for the caller to respond.');\n            this.sendOAI({\n                type: \"response.create\",\n                response: {\n                    instructions: greetOnly,\n                    modalities: [\n                        \"audio\",\n                        \"text\"\n                    ]\n                }\n            });\n        }\n    }\n    async disconnect() {\n        var _this_pc, _this_mic;\n        try {\n            this.sendOAI({\n                type: \"response.cancel\"\n            });\n        } catch (e) {}\n        (_this_pc = this.pc) === null || _this_pc === void 0 ? void 0 : _this_pc.close();\n        this.pc = null;\n        (_this_mic = this.mic) === null || _this_mic === void 0 ? void 0 : _this_mic.getTracks().forEach((t)=>t.stop());\n        this.mic = null;\n        this.toolArgsBuffers.clear();\n        this.dataChannel = null;\n        this.pendingMessages = [];\n    }\n    async invokeTool(callId, name, argsJson) {\n        let args = {};\n        try {\n            args = argsJson ? JSON.parse(argsJson) : {};\n        } catch (e) {\n            // If parsing fails, return an error result\n            await this.sendToolResult(callId, {\n                error: \"Invalid tool arguments\"\n            });\n            return;\n        }\n        try {\n            var _this_onToolEvent, _this;\n            // Heuristic mapping if model omitted the function name\n            let effective = name;\n            if (!effective || effective === \"unknown\") {\n                if (args && typeof args === \"object\") {\n                    if (args.start && args.end && !args.customer) effective = \"checkAvailability\";\n                    else if (args.start && args.end && args.customer) effective = \"bookAppointment\";\n                    else if (args.date) effective = \"getAvailableSlots\";\n                }\n            }\n            (_this_onToolEvent = (_this = this).onToolEvent) === null || _this_onToolEvent === void 0 ? void 0 : _this_onToolEvent.call(_this, {\n                kind: \"call\",\n                name: effective || name,\n                args: argsJson\n            });\n            if (effective === \"checkAvailability\") {\n                var _this_onToolEvent1, _this1;\n                const organizationId = args.organizationId || this.defaultOrgId;\n                const calendarId = args.calendarId || this.defaultCalendarId;\n                if (!args.start || !args.end) {\n                    await this.sendToolResult(callId, {\n                        error: \"Missing start/end\"\n                    });\n                    return;\n                }\n                const res = await (async ()=>{\n                    const r = await fetch(\"/api/calendar/check-availability\", {\n                        method: \"POST\",\n                        headers: {\n                            \"Content-Type\": \"application/json\"\n                        },\n                        body: JSON.stringify({\n                            organizationId,\n                            start: args.start,\n                            end: args.end,\n                            calendarId,\n                            calendarIds: this.calendarIds\n                        })\n                    });\n                    try {\n                        const j = await r.json();\n                        return r.ok ? j : {\n                            error: \"http_error\",\n                            status: r.status,\n                            detail: j\n                        };\n                    } catch (e) {\n                        const t = await r.text().catch(()=>\"\");\n                        return {\n                            error: \"http_error\",\n                            status: r.status,\n                            detail: t\n                        };\n                    }\n                })();\n                (_this_onToolEvent1 = (_this1 = this).onToolEvent) === null || _this_onToolEvent1 === void 0 ? void 0 : _this_onToolEvent1.call(_this1, {\n                    kind: \"result\",\n                    name: effective,\n                    result: res\n                });\n                await this.sendToolResult(callId, res);\n                try {\n                    if ((res === null || res === void 0 ? void 0 : res.error) === \"broad_window\") {\n                        this.requireTool(\"slots\");\n                    } else if ((res === null || res === void 0 ? void 0 : res.available) === true) {\n                        const tz = res === null || res === void 0 ? void 0 : res.timeZone;\n                        const s = (res === null || res === void 0 ? void 0 : res.start) || args.start;\n                        const e = (res === null || res === void 0 ? void 0 : res.end) || args.end;\n                        this.speak(\"That time is available: \".concat(this.fmtRange(s, e, tz), \". Should I book it?\"));\n                    } else if ((res === null || res === void 0 ? void 0 : res.available) === false) {\n                        var _j_slots;\n                        const date = ((res === null || res === void 0 ? void 0 : res.start) || args.start).slice(0, 10);\n                        const r2 = await fetch(\"/api/calendar/slots\", {\n                            method: \"POST\",\n                            headers: {\n                                \"Content-Type\": \"application/json\"\n                            },\n                            body: JSON.stringify({\n                                date,\n                                slotMinutes: 60,\n                                calendarIds: this.calendarIds\n                            })\n                        });\n                        let j = null;\n                        try {\n                            j = await r2.json();\n                        } catch (e) {}\n                        if (r2.ok && (j === null || j === void 0 ? void 0 : (_j_slots = j.slots) === null || _j_slots === void 0 ? void 0 : _j_slots.length)) {\n                            const tz2 = j.timeZone;\n                            try {\n                                var _this_onSlots, _this2;\n                                (_this_onSlots = (_this2 = this).onSlots) === null || _this_onSlots === void 0 ? void 0 : _this_onSlots.call(_this2, j.slots, tz2);\n                            } catch (e) {}\n                            const list = j.slots.slice(0, 5).map((it)=>this.fmtRange(it.start, it.end, tz2)).join(\", \");\n                            this.speak(\"That time is not available. Here are some options: \".concat(list, \".\"));\n                        } else {\n                            this.speak(\"That time is not available and I could not retrieve alternative slots.\");\n                        }\n                    }\n                } catch (e) {}\n            } else if (effective === \"bookAppointment\") {\n                var _this_onToolEvent2, _this3;\n                const organizationId = args.organizationId || this.defaultOrgId;\n                const calendarId = args.calendarId || this.defaultCalendarId;\n                if (!organizationId) {\n                    await this.sendToolResult(callId, {\n                        error: \"Missing organizationId\"\n                    });\n                    return;\n                }\n                const res = await (async ()=>{\n                    const r = await fetch(\"/api/appointments/book\", {\n                        method: \"POST\",\n                        headers: {\n                            \"Content-Type\": \"application/json\"\n                        },\n                        body: JSON.stringify({\n                            organizationId,\n                            customer: args.customer,\n                            start: args.start,\n                            end: args.end,\n                            notes: args.notes,\n                            calendarId\n                        })\n                    });\n                    try {\n                        const j = await r.json();\n                        return r.ok ? j : {\n                            error: \"http_error\",\n                            status: r.status,\n                            detail: j\n                        };\n                    } catch (e) {\n                        const t = await r.text().catch(()=>\"\");\n                        return {\n                            error: \"http_error\",\n                            status: r.status,\n                            detail: t\n                        };\n                    }\n                })();\n                (_this_onToolEvent2 = (_this3 = this).onToolEvent) === null || _this_onToolEvent2 === void 0 ? void 0 : _this_onToolEvent2.call(_this3, {\n                    kind: \"result\",\n                    name: effective,\n                    result: res\n                });\n                await this.sendToolResult(callId, res);\n                try {\n                    if ((res === null || res === void 0 ? void 0 : res.error) === \"conflict\") {\n                        this.speak(\"That time is busy. Would you like me to suggest alternatives?\");\n                    } else if (res === null || res === void 0 ? void 0 : res.appointment) {\n                        const tz = res === null || res === void 0 ? void 0 : res.timeZone;\n                        const s = (res === null || res === void 0 ? void 0 : res.start) || args.start;\n                        const e = (res === null || res === void 0 ? void 0 : res.end) || args.end;\n                        this.speak(\"Booked: \".concat(this.fmtRange(s, e, tz), \". I have added it to the calendar.\"));\n                    }\n                } catch (e) {}\n            } else if (effective === \"getAvailableSlots\") {\n                var _this_onToolEvent3, _this4;\n                const organizationId = args.organizationId || this.defaultOrgId;\n                const res = await (async ()=>{\n                    const r = await fetch(\"/api/calendar/slots\", {\n                        method: \"POST\",\n                        headers: {\n                            \"Content-Type\": \"application/json\"\n                        },\n                        body: JSON.stringify({\n                            organizationId,\n                            date: args.date,\n                            slotMinutes: args.slotMinutes,\n                            businessHours: args.businessHours,\n                            calendarIds: this.calendarIds\n                        })\n                    });\n                    try {\n                        const j = await r.json();\n                        return r.ok ? j : {\n                            error: \"http_error\",\n                            status: r.status,\n                            detail: j\n                        };\n                    } catch (e) {\n                        const t = await r.text().catch(()=>\"\");\n                        return {\n                            error: \"http_error\",\n                            status: r.status,\n                            detail: t\n                        };\n                    }\n                })();\n                (_this_onToolEvent3 = (_this4 = this).onToolEvent) === null || _this_onToolEvent3 === void 0 ? void 0 : _this_onToolEvent3.call(_this4, {\n                    kind: \"result\",\n                    name: effective,\n                    result: res\n                });\n                await this.sendToolResult(callId, res);\n                try {\n                    if (Array.isArray(res === null || res === void 0 ? void 0 : res.slots)) {\n                        const tz = res === null || res === void 0 ? void 0 : res.timeZone;\n                        try {\n                            var _this_onSlots1, _this5;\n                            (_this_onSlots1 = (_this5 = this).onSlots) === null || _this_onSlots1 === void 0 ? void 0 : _this_onSlots1.call(_this5, res.slots, tz);\n                        } catch (e) {}\n                        if (res.slots.length === 0) this.speak(\"No free slots found that day.\");\n                        else {\n                            const list = res.slots.slice(0, 5).map((it)=>this.fmtRange(it.start, it.end, tz)).join(\", \");\n                            this.speak(\"Available slots are: \".concat(list, \".\"));\n                        }\n                    } else if (res === null || res === void 0 ? void 0 : res.error) {\n                        this.speak(\"I could not retrieve the day availability at the moment.\");\n                    }\n                } catch (e) {}\n            } else {\n                var _this_onToolEvent4, _this6;\n                const err = {\n                    error: \"Unknown tool \".concat(name || \"unknown\")\n                };\n                (_this_onToolEvent4 = (_this6 = this).onToolEvent) === null || _this_onToolEvent4 === void 0 ? void 0 : _this_onToolEvent4.call(_this6, {\n                    kind: \"result\",\n                    name,\n                    result: err\n                });\n                await this.sendToolResult(callId, err);\n            }\n        } catch (e) {\n            var _this_onToolEvent5, _this7;\n            const err = {\n                error: e.message\n            };\n            (_this_onToolEvent5 = (_this7 = this).onToolEvent) === null || _this_onToolEvent5 === void 0 ? void 0 : _this_onToolEvent5.call(_this7, {\n                kind: \"result\",\n                name,\n                result: err\n            });\n            await this.sendToolResult(callId, err);\n        }\n    }\n    async sendToolResult(callId, result) {\n        // Provide tool output to the model and request it to continue\n        const createItem = {\n            type: \"conversation.item.create\",\n            item: {\n                type: \"function_call_output\",\n                call_id: callId,\n                output: JSON.stringify(result)\n            }\n        };\n        // Do NOT auto-trigger a model response; we will speak deterministic text from tool results.\n        this.sendOAI(createItem);\n    }\n    attachDataChannel(channel) {\n        this.dataChannel = channel;\n        channel.onmessage = (ev)=>this.handleOAIEvent(ev.data);\n        channel.onopen = ()=>{\n            // Flush any queued messages once channel is open\n            if (this.pendingMessages.length) {\n                for (const msg of this.pendingMessages){\n                    try {\n                        channel.send(JSON.stringify(msg));\n                    } catch (e) {\n                    // ignore send failures\n                    }\n                }\n                this.pendingMessages = [];\n            }\n        };\n    }\n    sendOAI(msg) {\n        const dc = this.dataChannel;\n        const payload = JSON.stringify(msg);\n        if (dc && dc.readyState === \"open\") {\n            try {\n                dc.send(payload);\n            } catch (e) {\n                // If send fails unexpectedly, queue it for retry on next open\n                this.pendingMessages.push(msg);\n            }\n        } else {\n            this.pendingMessages.push(msg);\n        }\n    }\n    constructor(opts){\n        this.pc = null;\n        this.mic = null;\n        this.toolArgsBuffers = new Map();\n        this.dataChannel = null;\n        this.pendingMessages = [];\n        this.toolHintSent = false;\n        this.awaitingTool = false;\n        this.awaitingToolTimer = null;\n        this.fallbackTimer = null;\n        this.lastTranscript = \"\";\n        this.handleOAIEvent = (raw)=>{\n            try {\n                const msg = typeof raw === \"string\" ? JSON.parse(raw) : raw;\n                // Lightweight debug logging to help diagnose tool calling\n                if (msg === null || msg === void 0 ? void 0 : msg.type) {\n                    const k = msg.type;\n                    if (k.startsWith(\"response.function_call\") || k.startsWith(\"response.output_text\") || k === \"transcript\") {\n                        var _this_onToolEvent, _this;\n                        // eslint-disable-next-line no-console\n                        console.debug(\"[oai]\", k);\n                        (_this_onToolEvent = (_this = this).onToolEvent) === null || _this_onToolEvent === void 0 ? void 0 : _this_onToolEvent.call(_this, {\n                            kind: \"event\",\n                            type: k\n                        });\n                    }\n                }\n                // Simple transcript tap if present\n                if (msg.type === \"transcript\") {\n                    if (this.onTranscript) this.onTranscript(msg.text);\n                    // After first user transcript, arm tool usage with explicit guidance (once)\n                    if (!this.toolHintSent) {\n                        const toolHint = \"Use tools for scheduling. When the caller mentions a specific time, call checkAvailability with start at that exact local time and end=start+60 minutes (unless the user requested a different duration). Do not check a whole day when a specific time was requested. If checkAvailability shows conflicts, do not proceed to booking; propose the next free times. Format dates as RFC3339 with timezone (e.g., 2025-09-10T10:00:00-04:00). Default organizationId=\".concat(this.defaultOrgId || \"unknown\", \", calendarId=\").concat(this.defaultCalendarId || \"primary\", \".\");\n                        this.sendOAI({\n                            type: \"response.create\",\n                            response: {\n                                instructions: toolHint,\n                                tool_choice: \"auto\",\n                                modalities: [\n                                    \"audio\",\n                                    \"text\"\n                                ]\n                            }\n                        });\n                        this.toolHintSent = true;\n                    }\n                    // Heuristic: day availability question -> require getAvailableSlots\n                    const t = msg.text.toLowerCase();\n                    const hasTime = /\\b(\\d{1,2})(?::(\\d{2}))?\\s?(am|pm)?\\b/.test(t) || /\\bnoon\\b|\\bmidnight\\b/.test(t);\n                    const dayQuery = /\\b(today|tomorrow|monday|tuesday|wednesday|thursday|friday|saturday|sunday|this\\s+week|availability|free|open)\\b/.test(t);\n                    if (dayQuery && !hasTime) this.requireTool(\"slots\");\n                    if (hasTime) this.requireTool(\"check\");\n                }\n                // Tool calling (function calling) handlers â€“ support current and legacy event names\n                if (msg.type === \"response.function_call.created\") {\n                    // Capture the function name early so later delta/done events can find it\n                    const callId = msg.call_id || msg.id;\n                    const name = msg.name || \"unknown\";\n                    if (callId) {\n                        var _this_onToolEvent1, _this1;\n                        const cur = this.toolArgsBuffers.get(callId) || {\n                            name,\n                            args: \"\"\n                        };\n                        cur.name = name;\n                        this.toolArgsBuffers.set(callId, cur);\n                        (_this_onToolEvent1 = (_this1 = this).onToolEvent) === null || _this_onToolEvent1 === void 0 ? void 0 : _this_onToolEvent1.call(_this1, {\n                            kind: \"event\",\n                            type: \"response.function_call.created\"\n                        });\n                    }\n                }\n                if (msg.type === \"response.function_call.arguments.delta\" || msg.type === \"response.function_call_arguments.delta\") {\n                    var _this_toolArgsBuffers_get;\n                    this.awaitingTool = false;\n                    const callId = msg.call_id || msg.id;\n                    var _this_toolArgsBuffers_get_name;\n                    const name = msg.name || ((_this_toolArgsBuffers_get_name = (_this_toolArgsBuffers_get = this.toolArgsBuffers.get(callId)) === null || _this_toolArgsBuffers_get === void 0 ? void 0 : _this_toolArgsBuffers_get.name) !== null && _this_toolArgsBuffers_get_name !== void 0 ? _this_toolArgsBuffers_get_name : \"unknown\");\n                    const delta = msg.delta || \"\";\n                    if (!callId) return;\n                    const cur = this.toolArgsBuffers.get(callId) || {\n                        name,\n                        args: \"\"\n                    };\n                    cur.args += delta;\n                    cur.name = name;\n                    this.toolArgsBuffers.set(callId, cur);\n                }\n                if (msg.type === \"response.function_call.arguments.done\" || msg.type === \"response.function_call_arguments.done\") {\n                    this.awaitingTool = false;\n                    const callId = msg.call_id || msg.id;\n                    if (!callId) return;\n                    const buf = this.toolArgsBuffers.get(callId);\n                    if (!buf) return;\n                    // eslint-disable-next-line no-console\n                    console.debug(\"[oai] function_call.complete\", buf.name);\n                    this.invokeTool(callId, buf.name, buf.args);\n                }\n                if (msg.type === \"response.function_call.completed\") {\n                    var _this_toolArgsBuffers_get1;\n                    this.awaitingTool = false;\n                    // Some backends emit a single completed event with full arguments\n                    const callId = msg.call_id || msg.id;\n                    const name = msg.name || \"unknown\";\n                    const args = msg.arguments || ((_this_toolArgsBuffers_get1 = this.toolArgsBuffers.get(callId || \"\")) === null || _this_toolArgsBuffers_get1 === void 0 ? void 0 : _this_toolArgsBuffers_get1.args) || \"\";\n                    if (!callId) return;\n                    // eslint-disable-next-line no-console\n                    console.debug(\"[oai] function_call.completed\", name);\n                    this.invokeTool(callId, name, args);\n                }\n            } catch (e) {\n            // ignore parse errors\n            }\n        };\n        this.audioEl = new Audio();\n        this.onTranscript = opts === null || opts === void 0 ? void 0 : opts.onTranscript;\n        this.onToolEvent = opts === null || opts === void 0 ? void 0 : opts.onToolEvent;\n        this.onSlots = opts === null || opts === void 0 ? void 0 : opts.onSlots;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9hZ2VudC9vcGVuYWktcmVhbHRpbWUudHMiLCJtYXBwaW5ncyI6Ijs7OztBQU9PLE1BQU1BO0lBK0JYQyxlQUFlQyxHQUF5QixFQUFFO1FBQ3hDLElBQUksQ0FBQ0MsV0FBVyxHQUFHRCxPQUFPQSxJQUFJRSxNQUFNLEdBQUc7ZUFBSUY7U0FBSSxHQUFHRztJQUNwRDtJQUVRQyxZQUFZQyxJQUF1QixFQUFFQyxJQUF3QixFQUFFO1FBQ3JFLHdEQUF3RDtRQUN4RCxJQUFJO1lBQUUsSUFBSSxDQUFDQyxPQUFPLENBQUM7Z0JBQUVDLE1BQU07WUFBa0I7UUFBRyxFQUFFLFVBQU0sQ0FBQztRQUN6RCxNQUFNQyxlQUNKSixTQUFTLFVBQ0wsNEpBQ0E7UUFDTixJQUFJLENBQUNFLE9BQU8sQ0FBQztZQUFFQyxNQUFNO1lBQW1CRSxVQUFVO2dCQUFFRDtnQkFBY0UsYUFBYTtnQkFBWUMsWUFBWTtvQkFBQztvQkFBUztpQkFBTztZQUFDO1FBQUU7UUFDM0gsSUFBSSxDQUFDQyxZQUFZLEdBQUc7UUFDcEIsSUFBSSxJQUFJLENBQUNDLGlCQUFpQixFQUFFQyxhQUFhLElBQUksQ0FBQ0QsaUJBQWlCO1FBQy9ELElBQUksQ0FBQ0EsaUJBQWlCLEdBQUdFLFdBQVc7WUFDbEMsSUFBSSxJQUFJLENBQUNILFlBQVksRUFBRTtnQkFDckIsaUJBQWlCO2dCQUNqQixJQUFJLENBQUNOLE9BQU8sQ0FBQztvQkFBRUMsTUFBTTtvQkFBbUJFLFVBQVU7d0JBQUVEO3dCQUFjRSxhQUFhO3dCQUFZQyxZQUFZOzRCQUFDOzRCQUFTO3lCQUFPO29CQUFDO2dCQUFFO1lBQzdIO1FBQ0YsR0FBRztRQUVILDBGQUEwRjtRQUMxRixJQUFJUCxTQUFTLFNBQVM7WUFDcEIsSUFBSSxJQUFJLENBQUNZLGFBQWEsRUFBRUYsYUFBYSxJQUFJLENBQUNFLGFBQWE7WUFDdkQsSUFBSSxDQUFDQSxhQUFhLEdBQUdELFdBQVc7Z0JBQzlCLElBQUksQ0FBQyxJQUFJ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QUssQ0FBQyxnQ0FBZ0NZLElBQUloTCxJQUFJO29CQUN0RCxJQUFJLENBQUMySCxVQUFVLENBQUNDLFFBQVFvRCxJQUFJaEwsSUFBSSxFQUFFZ0wsSUFBSWxELElBQUk7Z0JBQzVDO2dCQUNBLElBQUkwQixJQUFJckosSUFBSSxLQUFLLG9DQUFvQzt3QkFLVDtvQkFKMUMsSUFBSSxDQUFDSyxZQUFZLEdBQUc7b0JBQ3BCLGtFQUFrRTtvQkFDbEUsTUFBTW9ILFNBQVMsSUFBS3FCLE9BQU8sSUFBZ0JPLElBQUltQixFQUFFO29CQUNqRCxNQUFNM0ssT0FBTyxJQUFLQSxJQUFJLElBQWU7b0JBQ3JDLE1BQU04SCxPQUFPLElBQUttRCxTQUFTLE1BQWUsaUNBQUksQ0FBQzFELGVBQWUsQ0FBQ3NELEdBQUcsQ0FBQ2pELFVBQVUsaUJBQW5DLDRFQUF3Q0UsSUFBSSxLQUFJO29CQUMxRixJQUFJLENBQUNGLFFBQVE7b0JBQ2Isc0NBQXNDO29CQUN0Q3VDLFFBQVFDLEtBQUssQ0FBQyxpQ0FBaUNwSztvQkFDL0MsSUFBSSxDQUFDMkgsVUFBVSxDQUFDQyxRQUFRNUgsTUFBTThIO2dCQUNoQztZQUNGLEVBQUUsT0FBTy9DLEdBQUc7WUFDVixzQkFBc0I7WUFDeEI7UUFDRjtRQTlRRSxJQUFJLENBQUNHLE9BQU8sR0FBRyxJQUFJZ0c7UUFDbkIsSUFBSSxDQUFDYixZQUFZLEdBQUdwSyxpQkFBQUEsMkJBQUFBLEtBQU1vSyxZQUFZO1FBQ3RDLElBQUksQ0FBQ2hILFdBQVcsR0FBR3BELGlCQUFBQSwyQkFBQUEsS0FBTW9ELFdBQVc7UUFDcEMsSUFBSSxDQUFDb0YsT0FBTyxHQUFHeEksaUJBQUFBLDJCQUFBQSxLQUFNd0ksT0FBTztJQUM5QjtBQXFkRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvYWdlbnQvb3BlbmFpLXJlYWx0aW1lLnRzPzBlMWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBBZ2VudEFkYXB0ZXIgfSBmcm9tICcuLi9hZGFwdGVycy90eXBlcydcblxudHlwZSBUb29sRXZlbnQgPVxuICB8IHsga2luZDogJ2V2ZW50JzsgdHlwZTogc3RyaW5nOyB0ZXh0Pzogc3RyaW5nIH1cbiAgfCB7IGtpbmQ6ICdjYWxsJzsgbmFtZTogc3RyaW5nOyBhcmdzOiBzdHJpbmcgfVxuICB8IHsga2luZDogJ3Jlc3VsdCc7IG5hbWU6IHN0cmluZzsgcmVzdWx0OiBhbnkgfVxuXG5leHBvcnQgY2xhc3MgT3BlbkFJUmVhbHRpbWVBZ2VudCBpbXBsZW1lbnRzIEFnZW50QWRhcHRlciB7XG4gIHByaXZhdGUgcGM6IFJUQ1BlZXJDb25uZWN0aW9uIHwgbnVsbCA9IG51bGxcbiAgcHJpdmF0ZSBtaWM6IE1lZGlhU3RyZWFtIHwgbnVsbCA9IG51bGxcbiAgcHJpdmF0ZSBhdWRpb0VsOiBIVE1MQXVkaW9FbGVtZW50XG4gIHByaXZhdGUgb25UcmFuc2NyaXB0PzogKHRleHQ6IHN0cmluZykgPT4gdm9pZFxuICBwcml2YXRlIHRvb2xBcmdzQnVmZmVycyA9IG5ldyBNYXA8c3RyaW5nLCB7IG5hbWU6IHN0cmluZzsgYXJnczogc3RyaW5nIH0+KClcbiAgcHJpdmF0ZSBkYXRhQ2hhbm5lbDogUlRDRGF0YUNoYW5uZWwgfCBudWxsID0gbnVsbFxuICBwcml2YXRlIHBlbmRpbmdNZXNzYWdlczogYW55W10gPSBbXVxuICBwcml2YXRlIGRlZmF1bHRPcmdJZDogc3RyaW5nIHwgdW5kZWZpbmVkXG4gIHByaXZhdGUgZGVmYXVsdENhbGVuZGFySWQ6IHN0cmluZyB8IHVuZGVmaW5lZFxuICBwcml2YXRlIHRvb2xIaW50U2VudCA9IGZhbHNlXG4gIHByaXZhdGUgb25Ub29sRXZlbnQ/OiAoZTogVG9vbEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgb25TbG90cz86IChzbG90czogQXJyYXk8eyBzdGFydDogc3RyaW5nOyBlbmQ6IHN0cmluZyB9PiwgdHo/OiBzdHJpbmcpID0+IHZvaWRcbiAgcHJpdmF0ZSBjYWxlbmRhcklkczogc3RyaW5nW10gfCB1bmRlZmluZWRcbiAgcHJpdmF0ZSBhd2FpdGluZ1Rvb2w6IGJvb2xlYW4gPSBmYWxzZVxuICBwcml2YXRlIGF3YWl0aW5nVG9vbFRpbWVyOiBhbnkgPSBudWxsXG4gIHByaXZhdGUgZmFsbGJhY2tUaW1lcjogYW55ID0gbnVsbFxuICBwcml2YXRlIGxhc3RUcmFuc2NyaXB0OiBzdHJpbmcgPSAnJ1xuICBwcml2YXRlIHR6OiBzdHJpbmcgfCB1bmRlZmluZWRcblxuICBjb25zdHJ1Y3RvcihvcHRzPzoge1xuICAgIG9uVHJhbnNjcmlwdD86ICh0ZXh0OiBzdHJpbmcpID0+IHZvaWRcbiAgICBvblRvb2xFdmVudD86IChlOiBUb29sRXZlbnQpID0+IHZvaWRcbiAgICBvblNsb3RzPzogKHNsb3RzOiBBcnJheTx7IHN0YXJ0OiBzdHJpbmc7IGVuZDogc3RyaW5nIH0+LCB0ej86IHN0cmluZykgPT4gdm9pZFxuICB9KSB7XG4gICAgdGhpcy5hdWRpb0VsID0gbmV3IEF1ZGlvKClcbiAgICB0aGlzLm9uVHJhbnNjcmlwdCA9IG9wdHM/Lm9uVHJhbnNjcmlwdFxuICAgIHRoaXMub25Ub29sRXZlbnQgPSBvcHRzPy5vblRvb2xFdmVudFxuICAgIHRoaXMub25TbG90cyA9IG9wdHM/Lm9uU2xvdHNcbiAgfVxuXG4gIHNldENhbGVuZGFySWRzKGlkczogc3RyaW5nW10gfCB1bmRlZmluZWQpIHtcbiAgICB0aGlzLmNhbGVuZGFySWRzID0gaWRzICYmIGlkcy5sZW5ndGggPyBbLi4uaWRzXSA6IHVuZGVmaW5lZFxuICB9XG5cbiAgcHJpdmF0ZSByZXF1aXJlVG9vbChuYW1lOiAnY2hlY2snIHwgJ3Nsb3RzJywgb3B0cz86IHsgdGV4dD86IHN0cmluZyB9KSB7XG4gICAgLy8gQ2FuY2VsIGFueSBjdXJyZW50IGdlbmVyYXRpb24gYW5kIHJlcXVpcmUgYSB0b29sIGNhbGxcbiAgICB0cnkgeyB0aGlzLnNlbmRPQUkoeyB0eXBlOiAncmVzcG9uc2UuY2FuY2VsJyB9KSB9IGNhdGNoIHt9XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25zID1cbiAgICAgIG5hbWUgPT09ICdzbG90cydcbiAgICAgICAgPyAnVXNlciBhc2tlZCBmb3IgZGF5IGF2YWlsYWJpbGl0eS4gQ2FsbCBnZXRBdmFpbGFibGVTbG90cyB3aXRoIHRoZSByZXF1ZXN0ZWQgZGF0ZSAoWVlZWS1NTS1ERCkuIERvIG5vdCBzdGF0ZSB0aW1lcyB1bmxlc3MgdGhleSBjb21lIGZyb20gdGhlIHRvb2wgcmVzdWx0LidcbiAgICAgICAgOiAnVXNlciBhc2tlZCBmb3IgYSBzcGVjaWZpYyB0aW1lLiBDYWxsIGNoZWNrQXZhaWxhYmlsaXR5IHdpdGggc3RhcnQgYXQgdGhhdCBleGFjdCBsb2NhbCB0aW1lIGFuZCBlbmQ9c3RhcnQrNjAgbWludXRlcyAodW5sZXNzIHVzZXIgc3BlY2lmaWVkIGEgZHVyYXRpb24pLiBEbyBub3Qgc3BlYWsgYXZhaWxhYmlsaXR5IGJlZm9yZSB0b29sIHJlc3VsdC4nXG4gICAgdGhpcy5zZW5kT0FJKHsgdHlwZTogJ3Jlc3BvbnNlLmNyZWF0ZScsIHJlc3BvbnNlOiB7IGluc3RydWN0aW9ucywgdG9vbF9jaG9pY2U6ICdyZXF1aXJlZCcsIG1vZGFsaXRpZXM6IFsnYXVkaW8nLCAndGV4dCddIH0gfSlcbiAgICB0aGlzLmF3YWl0aW5nVG9vbCA9IHRydWVcbiAgICBpZiAodGhpcy5hd2FpdGluZ1Rvb2xUaW1lcikgY2xlYXJUaW1lb3V0KHRoaXMuYXdhaXRpbmdUb29sVGltZXIpXG4gICAgdGhpcy5hd2FpdGluZ1Rvb2xUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuYXdhaXRpbmdUb29sKSB7XG4gICAgICAgIC8vIFJlLXByb21wdCBvbmNlXG4gICAgICAgIHRoaXMuc2VuZE9BSSh7IHR5cGU6ICdyZXNwb25zZS5jcmVhdGUnLCByZXNwb25zZTogeyBpbnN0cnVjdGlvbnMsIHRvb2xfY2hvaWNlOiAncmVxdWlyZWQnLCBtb2RhbGl0aWVzOiBbJ2F1ZGlvJywgJ3RleHQnXSB9IH0pXG4gICAgICB9XG4gICAgfSwgMjAwMClcblxuICAgIC8vIEZhbGxiYWNrIGFmdGVyIDM1MDBtcyBmb3Igc3BlY2lmaWMtdGltZSBxdWVyaWVzOiBwYXJzZSB0cmFuc2NyaXB0IGFuZCBjYWxsIEFQSSBkaXJlY3RseVxuICAgIGlmIChuYW1lID09PSAnY2hlY2snKSB7XG4gICAgICBpZiAodGhpcy5mYWxsYmFja1RpbWVyKSBjbGVhclRpbWVvdXQodGhpcy5mYWxsYmFja1RpbWVyKVxuICAgICAgdGhpcy5mYWxsYmFja1RpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5hd2FpdGluZ1Rvb2wpIHJldHVyblxuICAgICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLnBhcnNlU2xvdEZyb21UcmFuc2NyaXB0KHRoaXMubGFzdFRyYW5zY3JpcHQsIHRoaXMudHopXG4gICAgICAgIGlmICghcGFyc2VkKSByZXR1cm5cbiAgICAgICAgY29uc3Qgb3JnYW5pemF0aW9uSWQgPSB0aGlzLmRlZmF1bHRPcmdJZFxuICAgICAgICBjb25zdCBjYWxlbmRhcklkID0gdGhpcy5kZWZhdWx0Q2FsZW5kYXJJZFxuICAgICAgICBmZXRjaCgnL2FwaS9jYWxlbmRhci9jaGVjay1hdmFpbGFiaWxpdHknLCB7XG4gICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBvcmdhbml6YXRpb25JZCwgc3RhcnQ6IHBhcnNlZC5zdGFydCwgZW5kOiBwYXJzZWQuZW5kLCBjYWxlbmRhcklkLCBjYWxlbmRhcklkczogdGhpcy5jYWxlbmRhcklkcyB9KVxuICAgICAgICB9KVxuICAgICAgICAgIC50aGVuKGFzeW5jIChyKSA9PiAoeyBvazogci5vaywgajogYXdhaXQgci5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSkgfSkpXG4gICAgICAgICAgLnRoZW4oKHsgb2ssIGogfSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hd2FpdGluZ1Rvb2wgPSBmYWxzZVxuICAgICAgICAgICAgaWYgKG9rICYmIGo/LmF2YWlsYWJsZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICB0aGlzLnNwZWFrKGBUaGF0IHRpbWUgaXMgYXZhaWxhYmxlOiAke3RoaXMuZm10UmFuZ2Uoai5zdGFydCB8fCBwYXJzZWQuc3RhcnQsIGouZW5kIHx8IHBhcnNlZC5lbmQsIGoudGltZVpvbmUgfHwgdGhpcy50eil9LiBTaG91bGQgSSBib29rIGl0P2ApXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9rICYmIGo/LmF2YWlsYWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgY29uc3QgZGF0ZSA9IChqLnN0YXJ0IHx8IHBhcnNlZC5zdGFydCkuc2xpY2UoMCwgMTApXG4gICAgICAgICAgICAgIGZldGNoKCcvYXBpL2NhbGVuZGFyL3Nsb3RzJywge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgZGF0ZSwgc2xvdE1pbnV0ZXM6IDYwLCBjYWxlbmRhcklkczogdGhpcy5jYWxlbmRhcklkcyB9KVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKGFzeW5jIChyMikgPT4gKHsgb2syOiByMi5vaywgajI6IGF3YWl0IHIyLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKSB9KSlcbiAgICAgICAgICAgICAgICAudGhlbigoeyBvazIsIGoyIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChvazIgJiYgQXJyYXkuaXNBcnJheShqMj8uc2xvdHMpICYmIGoyLnNsb3RzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaXN0ID0gajIuc2xvdHMuc2xpY2UoMCwgNSkubWFwKChpdDogYW55KSA9PiB0aGlzLmZtdFJhbmdlKGl0LnN0YXJ0LCBpdC5lbmQsIGoyLnRpbWVab25lIHx8IHRoaXMudHopKS5qb2luKCcsICcpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3BlYWsoYFRoYXQgdGltZSBpcyBub3QgYXZhaWxhYmxlLiBIZXJlIGFyZSBzb21lIG9wdGlvbnM6ICR7bGlzdH0uYClcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3BlYWsoJ1RoYXQgdGltZSBpcyBub3QgYXZhaWxhYmxlIGFuZCBJIGNvdWxkIG5vdCByZXRyaWV2ZSBhbHRlcm5hdGl2ZSBzbG90cy4nKVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLnNwZWFrKCdJIGNvdWxkIG5vdCB2ZXJpZnkgdGhhdCB0aW1lIGp1c3Qgbm93LicpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2goKCkgPT4gdGhpcy5zcGVhaygnSSBjb3VsZCBub3QgdmVyaWZ5IHRoYXQgdGltZSBqdXN0IG5vdy4nKSlcbiAgICAgIH0sIDM1MDApXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzcGVhayh0ZXh0OiBzdHJpbmcpIHtcbiAgICB0aGlzLm9uVG9vbEV2ZW50Py4oeyBraW5kOiAnZXZlbnQnLCB0eXBlOiAnc3Bva2VuJywgdGV4dCB9KVxuICAgIHRoaXMuc2VuZE9BSSh7IHR5cGU6ICdyZXNwb25zZS5jcmVhdGUnLCByZXNwb25zZTogeyBpbnN0cnVjdGlvbnM6IHRleHQsIG1vZGFsaXRpZXM6IFsnYXVkaW8nLCAndGV4dCddIH0gfSlcbiAgfVxuXG4gIHByaXZhdGUgZm10VGltZShpc286IHN0cmluZywgdHo/OiBzdHJpbmcpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZCA9IG5ldyBEYXRlKGlzbylcbiAgICAgIGNvbnN0IGZtdCA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KCdlbi1VUycsIHsgdGltZVpvbmU6IHR6LCBob3VyOiAnMi1kaWdpdCcsIG1pbnV0ZTogJzItZGlnaXQnIH0pXG4gICAgICByZXR1cm4gZm10LmZvcm1hdChkKVxuICAgIH0gY2F0Y2ggeyByZXR1cm4gaXNvIH1cbiAgfVxuXG4gIHByaXZhdGUgZm10UmFuZ2Uoc3RhcnRJc286IHN0cmluZywgZW5kSXNvOiBzdHJpbmcsIHR6Pzogc3RyaW5nKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuZm10VGltZShzdGFydElzbywgdHopfSDigJMgJHt0aGlzLmZtdFRpbWUoZW5kSXNvLCB0eil9YFxuICB9XG5cbiAgYXN5bmMgY29ubmVjdChcbiAgICBzeXN0ZW1Qcm9tcHQ6IHN0cmluZyxcbiAgICBvcHRzPzogeyBvcmdhbml6YXRpb25JZD86IHN0cmluZzsgY2FsZW5kYXJJZD86IHN0cmluZzsgZ3JlZXRpbmc/OiBzdHJpbmc7IGxhbmd1YWdlPzogc3RyaW5nOyB0aW1lWm9uZT86IHN0cmluZyB9XG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBmZXRjaCgnL2FwaS9yZWFsdGltZS90b2tlbicsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHN5c3RlbVByb21wdCxcbiAgICAgICAgb3JnYW5pemF0aW9uSWQ6IG9wdHM/Lm9yZ2FuaXphdGlvbklkLFxuICAgICAgICBjYWxlbmRhcklkOiBvcHRzPy5jYWxlbmRhcklkIHx8ICdwcmltYXJ5JyxcbiAgICAgICAgZ3JlZXRpbmc6IG9wdHM/LmdyZWV0aW5nLFxuICAgICAgICBsYW5ndWFnZTogb3B0cz8ubGFuZ3VhZ2UgfHwgJ2VuLVVTJyxcbiAgICAgICAgdGltZVpvbmU6IG9wdHM/LnRpbWVab25lXG4gICAgICB9KVxuICAgIH0pLnRoZW4oKHIpID0+IHIuanNvbigpKVxuXG4gICAgaWYgKCFzZXNzaW9uPy5jbGllbnRfc2VjcmV0Py52YWx1ZSB8fCAhc2Vzc2lvbj8ubW9kZWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIG9idGFpbiBSZWFsdGltZSBzZXNzaW9uJylcbiAgICB9XG5cbiAgICB0aGlzLmRlZmF1bHRPcmdJZCA9IG9wdHM/Lm9yZ2FuaXphdGlvbklkXG4gICAgdGhpcy5kZWZhdWx0Q2FsZW5kYXJJZCA9IG9wdHM/LmNhbGVuZGFySWQgfHwgJ3ByaW1hcnknXG4gICAgdGhpcy50eiA9IG9wdHM/LnRpbWVab25lXG5cbiAgICBjb25zdCBwYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbigpXG4gICAgdGhpcy5wYyA9IHBjXG4gICAgcGMub250cmFjayA9IChlKSA9PiB7XG4gICAgICBjb25zdCBbc3RyZWFtXSA9IGUuc3RyZWFtc1xuICAgICAgdGhpcy5hdWRpb0VsLnNyY09iamVjdCA9IHN0cmVhbVxuICAgICAgdGhpcy5hdWRpb0VsLnBsYXkoKS5jYXRjaCgoKSA9PiB7fSlcbiAgICB9XG5cbiAgICAvLyBSZWNlaXZlIGV2ZW50cyBmcm9tIE9wZW5BSVxuICAgIHBjLm9uZGF0YWNoYW5uZWwgPSAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IGNoYW5uZWwgPSBldmVudC5jaGFubmVsXG4gICAgICBpZiAoY2hhbm5lbC5sYWJlbCAhPT0gJ29haS1ldmVudHMnKSByZXR1cm5cbiAgICAgIC8vIFByZWZlciB0aGUgaW5ib3VuZCBjaGFubmVsIGlmIE9wZW5BSSBjcmVhdGVzIGl0LlxuICAgICAgdGhpcy5hdHRhY2hEYXRhQ2hhbm5lbChjaGFubmVsKVxuICAgIH1cblxuICAgIGNvbnN0IGRjID0gcGMuY3JlYXRlRGF0YUNoYW5uZWwoJ29haS1ldmVudHMnKVxuICAgIHRoaXMuYXR0YWNoRGF0YUNoYW5uZWwoZGMpXG5cbiAgICB0aGlzLm1pYyA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHsgYXVkaW86IHRydWUgfSlcbiAgICB0aGlzLm1pYy5nZXRUcmFja3MoKS5mb3JFYWNoKCh0KSA9PiBwYy5hZGRUcmFjayh0LCB0aGlzLm1pYyEpKVxuXG4gICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCBwYy5jcmVhdGVPZmZlcigpXG4gICAgYXdhaXQgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcilcbiAgICBjb25zdCBiYXNlVXJsID0gJ2h0dHBzOi8vYXBpLm9wZW5haS5jb20vdjEvcmVhbHRpbWUnXG4gICAgY29uc3Qgc2RwUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtiYXNlVXJsfT9tb2RlbD0ke2VuY29kZVVSSUNvbXBvbmVudChzZXNzaW9uLm1vZGVsKX1gLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Nlc3Npb24uY2xpZW50X3NlY3JldC52YWx1ZX1gLFxuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3NkcCcsXG4gICAgICAgICdPcGVuQUktQmV0YSc6ICdyZWFsdGltZT12MSdcbiAgICAgIH0sXG4gICAgICBib2R5OiBvZmZlci5zZHBcbiAgICB9KVxuICAgIGlmICghc2RwUmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IHR4dCA9IGF3YWl0IHNkcFJlc3BvbnNlLnRleHQoKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWFsdGltZSBTRFAgZXJyb3I6ICR7c2RwUmVzcG9uc2Uuc3RhdHVzfSAke3R4dH1gKVxuICAgIH1cbiAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IGF3YWl0IHNkcFJlc3BvbnNlLnRleHQoKSB9IGFzIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXRcbiAgICBhd2FpdCBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpXG5cbiAgICAvLyBTcGVhayB0aGUgZXhwbGljaXQgZ3JlZXRpbmcgZmlyc3QgKGlmIHByb3ZpZGVkKSwgd2l0aG91dCBqdW1waW5nIGludG8gc2NoZWR1bGluZyB5ZXRcbiAgICBpZiAob3B0cz8uZ3JlZXRpbmcpIHtcbiAgICAgIGNvbnN0IHNhZmUgPSBvcHRzLmdyZWV0aW5nLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKVxuICAgICAgY29uc3QgZ3JlZXRPbmx5ID0gYFNheSBleGFjdGx5OiBcIiR7c2FmZX1cIi4gVGhlbiBzdG9wIHNwZWFraW5nIGFuZCB3YWl0IGZvciB0aGUgY2FsbGVyIHRvIHJlc3BvbmQuYFxuICAgICAgdGhpcy5zZW5kT0FJKHtcbiAgICAgICAgdHlwZTogJ3Jlc3BvbnNlLmNyZWF0ZScsXG4gICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgaW5zdHJ1Y3Rpb25zOiBncmVldE9ubHksXG4gICAgICAgICAgbW9kYWxpdGllczogWydhdWRpbycsICd0ZXh0J11cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBhc3luYyBkaXNjb25uZWN0KCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnNlbmRPQUkoeyB0eXBlOiAncmVzcG9uc2UuY2FuY2VsJyB9KVxuICAgIH0gY2F0Y2gge31cbiAgICB0aGlzLnBjPy5jbG9zZSgpXG4gICAgdGhpcy5wYyA9IG51bGxcbiAgICB0aGlzLm1pYz8uZ2V0VHJhY2tzKCkuZm9yRWFjaCgodCkgPT4gdC5zdG9wKCkpXG4gICAgdGhpcy5taWMgPSBudWxsXG4gICAgdGhpcy50b29sQXJnc0J1ZmZlcnMuY2xlYXIoKVxuICAgIHRoaXMuZGF0YUNoYW5uZWwgPSBudWxsXG4gICAgdGhpcy5wZW5kaW5nTWVzc2FnZXMgPSBbXVxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVPQUlFdmVudCA9IChyYXc6IGFueSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBtc2cgPSB0eXBlb2YgcmF3ID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UocmF3KSA6IHJhd1xuICAgICAgLy8gTGlnaHR3ZWlnaHQgZGVidWcgbG9nZ2luZyB0byBoZWxwIGRpYWdub3NlIHRvb2wgY2FsbGluZ1xuICAgICAgaWYgKG1zZz8udHlwZSkge1xuICAgICAgICBjb25zdCBrID0gbXNnLnR5cGUgYXMgc3RyaW5nXG4gICAgICAgIGlmIChcbiAgICAgICAgICBrLnN0YXJ0c1dpdGgoJ3Jlc3BvbnNlLmZ1bmN0aW9uX2NhbGwnKSB8fFxuICAgICAgICAgIGsuc3RhcnRzV2l0aCgncmVzcG9uc2Uub3V0cHV0X3RleHQnKSB8fFxuICAgICAgICAgIGsgPT09ICd0cmFuc2NyaXB0J1xuICAgICAgICApIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ1tvYWldJywgaylcbiAgICAgICAgICB0aGlzLm9uVG9vbEV2ZW50Py4oeyBraW5kOiAnZXZlbnQnLCB0eXBlOiBrIH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFNpbXBsZSB0cmFuc2NyaXB0IHRhcCBpZiBwcmVzZW50XG4gICAgICBpZiAobXNnLnR5cGUgPT09ICd0cmFuc2NyaXB0Jykge1xuICAgICAgICBpZiAodGhpcy5vblRyYW5zY3JpcHQpIHRoaXMub25UcmFuc2NyaXB0KG1zZy50ZXh0KVxuICAgICAgICAvLyBBZnRlciBmaXJzdCB1c2VyIHRyYW5zY3JpcHQsIGFybSB0b29sIHVzYWdlIHdpdGggZXhwbGljaXQgZ3VpZGFuY2UgKG9uY2UpXG4gICAgICAgIGlmICghdGhpcy50b29sSGludFNlbnQpIHtcbiAgICAgICAgICBjb25zdCB0b29sSGludCA9IGBVc2UgdG9vbHMgZm9yIHNjaGVkdWxpbmcuIFdoZW4gdGhlIGNhbGxlciBtZW50aW9ucyBhIHNwZWNpZmljIHRpbWUsIGNhbGwgY2hlY2tBdmFpbGFiaWxpdHkgd2l0aCBzdGFydCBhdCB0aGF0IGV4YWN0IGxvY2FsIHRpbWUgYW5kIGVuZD1zdGFydCs2MCBtaW51dGVzICh1bmxlc3MgdGhlIHVzZXIgcmVxdWVzdGVkIGEgZGlmZmVyZW50IGR1cmF0aW9uKS4gRG8gbm90IGNoZWNrIGEgd2hvbGUgZGF5IHdoZW4gYSBzcGVjaWZpYyB0aW1lIHdhcyByZXF1ZXN0ZWQuIElmIGNoZWNrQXZhaWxhYmlsaXR5IHNob3dzIGNvbmZsaWN0cywgZG8gbm90IHByb2NlZWQgdG8gYm9va2luZzsgcHJvcG9zZSB0aGUgbmV4dCBmcmVlIHRpbWVzLiBGb3JtYXQgZGF0ZXMgYXMgUkZDMzMzOSB3aXRoIHRpbWV6b25lIChlLmcuLCAyMDI1LTA5LTEwVDEwOjAwOjAwLTA0OjAwKS4gRGVmYXVsdCBvcmdhbml6YXRpb25JZD0ke3RoaXMuZGVmYXVsdE9yZ0lkIHx8ICd1bmtub3duJ30sIGNhbGVuZGFySWQ9JHt0aGlzLmRlZmF1bHRDYWxlbmRhcklkIHx8ICdwcmltYXJ5J30uYFxuICAgICAgICAgIHRoaXMuc2VuZE9BSSh7XG4gICAgICAgICAgICB0eXBlOiAncmVzcG9uc2UuY3JlYXRlJyxcbiAgICAgICAgICAgIHJlc3BvbnNlOiB7IGluc3RydWN0aW9uczogdG9vbEhpbnQsIHRvb2xfY2hvaWNlOiAnYXV0bycsIG1vZGFsaXRpZXM6IFsnYXVkaW8nLCAndGV4dCddIH1cbiAgICAgICAgICB9KVxuICAgICAgICAgIHRoaXMudG9vbEhpbnRTZW50ID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIC8vIEhldXJpc3RpYzogZGF5IGF2YWlsYWJpbGl0eSBxdWVzdGlvbiAtPiByZXF1aXJlIGdldEF2YWlsYWJsZVNsb3RzXG4gICAgICAgIGNvbnN0IHQgPSAobXNnLnRleHQgYXMgc3RyaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGNvbnN0IGhhc1RpbWUgPSAvXFxiKFxcZHsxLDJ9KSg/OjooXFxkezJ9KSk/XFxzPyhhbXxwbSk/XFxiLy50ZXN0KHQpIHx8IC9cXGJub29uXFxifFxcYm1pZG5pZ2h0XFxiLy50ZXN0KHQpXG4gICAgICAgIGNvbnN0IGRheVF1ZXJ5ID0gL1xcYih0b2RheXx0b21vcnJvd3xtb25kYXl8dHVlc2RheXx3ZWRuZXNkYXl8dGh1cnNkYXl8ZnJpZGF5fHNhdHVyZGF5fHN1bmRheXx0aGlzXFxzK3dlZWt8YXZhaWxhYmlsaXR5fGZyZWV8b3BlbilcXGIvLnRlc3QodClcbiAgICAgICAgaWYgKGRheVF1ZXJ5ICYmICFoYXNUaW1lKSB0aGlzLnJlcXVpcmVUb29sKCdzbG90cycpXG4gICAgICAgIGlmIChoYXNUaW1lKSB0aGlzLnJlcXVpcmVUb29sKCdjaGVjaycpXG4gICAgICB9XG5cbiAgICAgIC8vIFRvb2wgY2FsbGluZyAoZnVuY3Rpb24gY2FsbGluZykgaGFuZGxlcnMg4oCTIHN1cHBvcnQgY3VycmVudCBhbmQgbGVnYWN5IGV2ZW50IG5hbWVzXG4gICAgICBpZiAobXNnLnR5cGUgPT09ICdyZXNwb25zZS5mdW5jdGlvbl9jYWxsLmNyZWF0ZWQnKSB7XG4gICAgICAgIC8vIENhcHR1cmUgdGhlIGZ1bmN0aW9uIG5hbWUgZWFybHkgc28gbGF0ZXIgZGVsdGEvZG9uZSBldmVudHMgY2FuIGZpbmQgaXRcbiAgICAgICAgY29uc3QgY2FsbElkID0gKG1zZy5jYWxsX2lkIGFzIHN0cmluZykgfHwgKG1zZy5pZCBhcyBzdHJpbmcpXG4gICAgICAgIGNvbnN0IG5hbWUgPSAobXNnLm5hbWUgYXMgc3RyaW5nKSB8fCAndW5rbm93bidcbiAgICAgICAgaWYgKGNhbGxJZCkge1xuICAgICAgICAgIGNvbnN0IGN1ciA9IHRoaXMudG9vbEFyZ3NCdWZmZXJzLmdldChjYWxsSWQpIHx8IHsgbmFtZSwgYXJnczogJycgfVxuICAgICAgICAgIGN1ci5uYW1lID0gbmFtZVxuICAgICAgICAgIHRoaXMudG9vbEFyZ3NCdWZmZXJzLnNldChjYWxsSWQsIGN1cilcbiAgICAgICAgICB0aGlzLm9uVG9vbEV2ZW50Py4oeyBraW5kOiAnZXZlbnQnLCB0eXBlOiAncmVzcG9uc2UuZnVuY3Rpb25fY2FsbC5jcmVhdGVkJyB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIG1zZy50eXBlID09PSAncmVzcG9uc2UuZnVuY3Rpb25fY2FsbC5hcmd1bWVudHMuZGVsdGEnIHx8XG4gICAgICAgIG1zZy50eXBlID09PSAncmVzcG9uc2UuZnVuY3Rpb25fY2FsbF9hcmd1bWVudHMuZGVsdGEnXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5hd2FpdGluZ1Rvb2wgPSBmYWxzZVxuICAgICAgICBjb25zdCBjYWxsSWQgPSAobXNnLmNhbGxfaWQgYXMgc3RyaW5nKSB8fCAobXNnLmlkIGFzIHN0cmluZylcbiAgICAgICAgY29uc3QgbmFtZSA9IChtc2cubmFtZSBhcyBzdHJpbmcpIHx8ICh0aGlzLnRvb2xBcmdzQnVmZmVycy5nZXQoY2FsbElkKT8ubmFtZSA/PyAndW5rbm93bicpXG4gICAgICAgIGNvbnN0IGRlbHRhID0gKG1zZy5kZWx0YSBhcyBzdHJpbmcpIHx8ICcnXG4gICAgICAgIGlmICghY2FsbElkKSByZXR1cm5cbiAgICAgICAgY29uc3QgY3VyID0gdGhpcy50b29sQXJnc0J1ZmZlcnMuZ2V0KGNhbGxJZCkgfHwgeyBuYW1lLCBhcmdzOiAnJyB9XG4gICAgICAgIGN1ci5hcmdzICs9IGRlbHRhXG4gICAgICAgIGN1ci5uYW1lID0gbmFtZVxuICAgICAgICB0aGlzLnRvb2xBcmdzQnVmZmVycy5zZXQoY2FsbElkLCBjdXIpXG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIG1zZy50eXBlID09PSAncmVzcG9uc2UuZnVuY3Rpb25fY2FsbC5hcmd1bWVudHMuZG9uZScgfHxcbiAgICAgICAgbXNnLnR5cGUgPT09ICdyZXNwb25zZS5mdW5jdGlvbl9jYWxsX2FyZ3VtZW50cy5kb25lJ1xuICAgICAgKSB7XG4gICAgICAgIHRoaXMuYXdhaXRpbmdUb29sID0gZmFsc2VcbiAgICAgICAgY29uc3QgY2FsbElkID0gKG1zZy5jYWxsX2lkIGFzIHN0cmluZykgfHwgKG1zZy5pZCBhcyBzdHJpbmcpXG4gICAgICAgIGlmICghY2FsbElkKSByZXR1cm5cbiAgICAgICAgY29uc3QgYnVmID0gdGhpcy50b29sQXJnc0J1ZmZlcnMuZ2V0KGNhbGxJZClcbiAgICAgICAgaWYgKCFidWYpIHJldHVyblxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLmRlYnVnKCdbb2FpXSBmdW5jdGlvbl9jYWxsLmNvbXBsZXRlJywgYnVmLm5hbWUpXG4gICAgICAgIHRoaXMuaW52b2tlVG9vbChjYWxsSWQsIGJ1Zi5uYW1lLCBidWYuYXJncylcbiAgICAgIH1cbiAgICAgIGlmIChtc2cudHlwZSA9PT0gJ3Jlc3BvbnNlLmZ1bmN0aW9uX2NhbGwuY29tcGxldGVkJykge1xuICAgICAgICB0aGlzLmF3YWl0aW5nVG9vbCA9IGZhbHNlXG4gICAgICAgIC8vIFNvbWUgYmFja2VuZHMgZW1pdCBhIHNpbmdsZSBjb21wbGV0ZWQgZXZlbnQgd2l0aCBmdWxsIGFyZ3VtZW50c1xuICAgICAgICBjb25zdCBjYWxsSWQgPSAobXNnLmNhbGxfaWQgYXMgc3RyaW5nKSB8fCAobXNnLmlkIGFzIHN0cmluZylcbiAgICAgICAgY29uc3QgbmFtZSA9IChtc2cubmFtZSBhcyBzdHJpbmcpIHx8ICd1bmtub3duJ1xuICAgICAgICBjb25zdCBhcmdzID0gKG1zZy5hcmd1bWVudHMgYXMgc3RyaW5nKSB8fCB0aGlzLnRvb2xBcmdzQnVmZmVycy5nZXQoY2FsbElkIHx8ICcnKT8uYXJncyB8fCAnJ1xuICAgICAgICBpZiAoIWNhbGxJZCkgcmV0dXJuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUuZGVidWcoJ1tvYWldIGZ1bmN0aW9uX2NhbGwuY29tcGxldGVkJywgbmFtZSlcbiAgICAgICAgdGhpcy5pbnZva2VUb29sKGNhbGxJZCwgbmFtZSwgYXJncylcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBpZ25vcmUgcGFyc2UgZXJyb3JzXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBpbnZva2VUb29sKGNhbGxJZDogc3RyaW5nLCBuYW1lOiBzdHJpbmcsIGFyZ3NKc29uOiBzdHJpbmcpIHtcbiAgICBsZXQgYXJnczogYW55ID0ge31cbiAgICB0cnkge1xuICAgICAgYXJncyA9IGFyZ3NKc29uID8gSlNPTi5wYXJzZShhcmdzSnNvbikgOiB7fVxuICAgIH0gY2F0Y2gge1xuICAgICAgLy8gSWYgcGFyc2luZyBmYWlscywgcmV0dXJuIGFuIGVycm9yIHJlc3VsdFxuICAgICAgYXdhaXQgdGhpcy5zZW5kVG9vbFJlc3VsdChjYWxsSWQsIHsgZXJyb3I6ICdJbnZhbGlkIHRvb2wgYXJndW1lbnRzJyB9KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEhldXJpc3RpYyBtYXBwaW5nIGlmIG1vZGVsIG9taXR0ZWQgdGhlIGZ1bmN0aW9uIG5hbWVcbiAgICAgIGxldCBlZmZlY3RpdmUgPSBuYW1lXG4gICAgICBpZiAoIWVmZmVjdGl2ZSB8fCBlZmZlY3RpdmUgPT09ICd1bmtub3duJykge1xuICAgICAgICBpZiAoYXJncyAmJiB0eXBlb2YgYXJncyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBpZiAoYXJncy5zdGFydCAmJiBhcmdzLmVuZCAmJiAhYXJncy5jdXN0b21lcikgZWZmZWN0aXZlID0gJ2NoZWNrQXZhaWxhYmlsaXR5J1xuICAgICAgICAgIGVsc2UgaWYgKGFyZ3Muc3RhcnQgJiYgYXJncy5lbmQgJiYgYXJncy5jdXN0b21lcikgZWZmZWN0aXZlID0gJ2Jvb2tBcHBvaW50bWVudCdcbiAgICAgICAgICBlbHNlIGlmIChhcmdzLmRhdGUpIGVmZmVjdGl2ZSA9ICdnZXRBdmFpbGFibGVTbG90cydcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLm9uVG9vbEV2ZW50Py4oeyBraW5kOiAnY2FsbCcsIG5hbWU6IGVmZmVjdGl2ZSB8fCBuYW1lLCBhcmdzOiBhcmdzSnNvbiB9KVxuXG4gICAgICBpZiAoZWZmZWN0aXZlID09PSAnY2hlY2tBdmFpbGFiaWxpdHknKSB7XG4gICAgICAgIGNvbnN0IG9yZ2FuaXphdGlvbklkID0gYXJncy5vcmdhbml6YXRpb25JZCB8fCB0aGlzLmRlZmF1bHRPcmdJZFxuICAgICAgICBjb25zdCBjYWxlbmRhcklkID0gYXJncy5jYWxlbmRhcklkIHx8IHRoaXMuZGVmYXVsdENhbGVuZGFySWRcbiAgICAgICAgaWYgKCFhcmdzLnN0YXJ0IHx8ICFhcmdzLmVuZCkge1xuICAgICAgICAgIGF3YWl0IHRoaXMuc2VuZFRvb2xSZXN1bHQoY2FsbElkLCB7IGVycm9yOiAnTWlzc2luZyBzdGFydC9lbmQnIH0pXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICBjb25zdCByID0gYXdhaXQgZmV0Y2goJy9hcGkvY2FsZW5kYXIvY2hlY2stYXZhaWxhYmlsaXR5Jywge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgb3JnYW5pemF0aW9uSWQsIHN0YXJ0OiBhcmdzLnN0YXJ0LCBlbmQ6IGFyZ3MuZW5kLCBjYWxlbmRhcklkLCBjYWxlbmRhcklkczogdGhpcy5jYWxlbmRhcklkcyB9KVxuICAgICAgICAgIH0pXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGogPSBhd2FpdCByLmpzb24oKVxuICAgICAgICAgICAgcmV0dXJuIHIub2sgPyBqIDogeyBlcnJvcjogJ2h0dHBfZXJyb3InLCBzdGF0dXM6IHIuc3RhdHVzLCBkZXRhaWw6IGogfVxuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgY29uc3QgdCA9IGF3YWl0IHIudGV4dCgpLmNhdGNoKCgpID0+ICcnKVxuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6ICdodHRwX2Vycm9yJywgc3RhdHVzOiByLnN0YXR1cywgZGV0YWlsOiB0IH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pKClcbiAgICAgICAgdGhpcy5vblRvb2xFdmVudD8uKHsga2luZDogJ3Jlc3VsdCcsIG5hbWU6IGVmZmVjdGl2ZSwgcmVzdWx0OiByZXMgfSlcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kVG9vbFJlc3VsdChjYWxsSWQsIHJlcylcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoKHJlcyBhcyBhbnkpPy5lcnJvciA9PT0gJ2Jyb2FkX3dpbmRvdycpIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWlyZVRvb2woJ3Nsb3RzJylcbiAgICAgICAgICB9IGVsc2UgaWYgKChyZXMgYXMgYW55KT8uYXZhaWxhYmxlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCB0eiA9IChyZXMgYXMgYW55KT8udGltZVpvbmVcbiAgICAgICAgICAgIGNvbnN0IHMgPSAocmVzIGFzIGFueSk/LnN0YXJ0IHx8IGFyZ3Muc3RhcnRcbiAgICAgICAgICAgIGNvbnN0IGUgPSAocmVzIGFzIGFueSk/LmVuZCB8fCBhcmdzLmVuZFxuICAgICAgICAgICAgdGhpcy5zcGVhayhgVGhhdCB0aW1lIGlzIGF2YWlsYWJsZTogJHt0aGlzLmZtdFJhbmdlKHMsIGUsIHR6KX0uIFNob3VsZCBJIGJvb2sgaXQ/YClcbiAgICAgICAgICB9IGVsc2UgaWYgKChyZXMgYXMgYW55KT8uYXZhaWxhYmxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY29uc3QgZGF0ZSA9ICgocmVzIGFzIGFueSk/LnN0YXJ0IHx8IChhcmdzLnN0YXJ0IGFzIHN0cmluZykpLnNsaWNlKDAsIDEwKVxuICAgICAgICAgICAgY29uc3QgcjIgPSBhd2FpdCBmZXRjaCgnL2FwaS9jYWxlbmRhci9zbG90cycsIHtcbiAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGRhdGUsIHNsb3RNaW51dGVzOiA2MCwgY2FsZW5kYXJJZHM6IHRoaXMuY2FsZW5kYXJJZHMgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBsZXQgajogYW55ID0gbnVsbFxuICAgICAgICAgICAgdHJ5IHsgaiA9IGF3YWl0IHIyLmpzb24oKSB9IGNhdGNoIHt9XG4gICAgICAgICAgICBpZiAocjIub2sgJiYgaj8uc2xvdHM/Lmxlbmd0aCkge1xuICAgICAgICAgICAgICBjb25zdCB0ejIgPSBqLnRpbWVab25lXG4gICAgICAgICAgICAgIHRyeSB7IHRoaXMub25TbG90cz8uKGouc2xvdHMsIHR6MikgfSBjYXRjaCB7fVxuICAgICAgICAgICAgICBjb25zdCBsaXN0ID0gai5zbG90cy5zbGljZSgwLCA1KS5tYXAoKGl0OiBhbnkpID0+IHRoaXMuZm10UmFuZ2UoaXQuc3RhcnQsIGl0LmVuZCwgdHoyKSkuam9pbignLCAnKVxuICAgICAgICAgICAgICB0aGlzLnNwZWFrKGBUaGF0IHRpbWUgaXMgbm90IGF2YWlsYWJsZS4gSGVyZSBhcmUgc29tZSBvcHRpb25zOiAke2xpc3R9LmApXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLnNwZWFrKCdUaGF0IHRpbWUgaXMgbm90IGF2YWlsYWJsZSBhbmQgSSBjb3VsZCBub3QgcmV0cmlldmUgYWx0ZXJuYXRpdmUgc2xvdHMuJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2gge31cbiAgICAgIH0gZWxzZSBpZiAoZWZmZWN0aXZlID09PSAnYm9va0FwcG9pbnRtZW50Jykge1xuICAgICAgICBjb25zdCBvcmdhbml6YXRpb25JZCA9IGFyZ3Mub3JnYW5pemF0aW9uSWQgfHwgdGhpcy5kZWZhdWx0T3JnSWRcbiAgICAgICAgY29uc3QgY2FsZW5kYXJJZCA9IGFyZ3MuY2FsZW5kYXJJZCB8fCB0aGlzLmRlZmF1bHRDYWxlbmRhcklkXG4gICAgICAgIGlmICghb3JnYW5pemF0aW9uSWQpIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLnNlbmRUb29sUmVzdWx0KGNhbGxJZCwgeyBlcnJvcjogJ01pc3Npbmcgb3JnYW5pemF0aW9uSWQnIH0pXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICBjb25zdCByID0gYXdhaXQgZmV0Y2goJy9hcGkvYXBwb2ludG1lbnRzL2Jvb2snLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBvcmdhbml6YXRpb25JZCwgY3VzdG9tZXI6IGFyZ3MuY3VzdG9tZXIsIHN0YXJ0OiBhcmdzLnN0YXJ0LCBlbmQ6IGFyZ3MuZW5kLCBub3RlczogYXJncy5ub3RlcywgY2FsZW5kYXJJZCB9KVxuICAgICAgICAgIH0pXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGogPSBhd2FpdCByLmpzb24oKVxuICAgICAgICAgICAgcmV0dXJuIHIub2sgPyBqIDogeyBlcnJvcjogJ2h0dHBfZXJyb3InLCBzdGF0dXM6IHIuc3RhdHVzLCBkZXRhaWw6IGogfVxuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgY29uc3QgdCA9IGF3YWl0IHIudGV4dCgpLmNhdGNoKCgpID0+ICcnKVxuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6ICdodHRwX2Vycm9yJywgc3RhdHVzOiByLnN0YXR1cywgZGV0YWlsOiB0IH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pKClcbiAgICAgICAgdGhpcy5vblRvb2xFdmVudD8uKHsga2luZDogJ3Jlc3VsdCcsIG5hbWU6IGVmZmVjdGl2ZSwgcmVzdWx0OiByZXMgfSlcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kVG9vbFJlc3VsdChjYWxsSWQsIHJlcylcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAocmVzPy5lcnJvciA9PT0gJ2NvbmZsaWN0Jykge1xuICAgICAgICAgICAgdGhpcy5zcGVhaygnVGhhdCB0aW1lIGlzIGJ1c3kuIFdvdWxkIHlvdSBsaWtlIG1lIHRvIHN1Z2dlc3QgYWx0ZXJuYXRpdmVzPycpXG4gICAgICAgICAgfSBlbHNlIGlmIChyZXM/LmFwcG9pbnRtZW50KSB7XG4gICAgICAgICAgICBjb25zdCB0eiA9IHJlcz8udGltZVpvbmVcbiAgICAgICAgICAgIGNvbnN0IHMgPSByZXM/LnN0YXJ0IHx8IGFyZ3Muc3RhcnRcbiAgICAgICAgICAgIGNvbnN0IGUgPSByZXM/LmVuZCB8fCBhcmdzLmVuZFxuICAgICAgICAgICAgdGhpcy5zcGVhayhgQm9va2VkOiAke3RoaXMuZm10UmFuZ2UocywgZSwgdHopfS4gSSBoYXZlIGFkZGVkIGl0IHRvIHRoZSBjYWxlbmRhci5gKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCB7fVxuICAgICAgfSBlbHNlIGlmIChlZmZlY3RpdmUgPT09ICdnZXRBdmFpbGFibGVTbG90cycpIHtcbiAgICAgICAgY29uc3Qgb3JnYW5pemF0aW9uSWQgPSBhcmdzLm9yZ2FuaXphdGlvbklkIHx8IHRoaXMuZGVmYXVsdE9yZ0lkXG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgciA9IGF3YWl0IGZldGNoKCcvYXBpL2NhbGVuZGFyL3Nsb3RzJywge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgb3JnYW5pemF0aW9uSWQsXG4gICAgICAgICAgICAgIGRhdGU6IGFyZ3MuZGF0ZSxcbiAgICAgICAgICAgICAgc2xvdE1pbnV0ZXM6IGFyZ3Muc2xvdE1pbnV0ZXMsXG4gICAgICAgICAgICAgIGJ1c2luZXNzSG91cnM6IGFyZ3MuYnVzaW5lc3NIb3VycyxcbiAgICAgICAgICAgICAgY2FsZW5kYXJJZHM6IHRoaXMuY2FsZW5kYXJJZHNcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaiA9IGF3YWl0IHIuanNvbigpXG4gICAgICAgICAgICByZXR1cm4gci5vayA/IGogOiB7IGVycm9yOiAnaHR0cF9lcnJvcicsIHN0YXR1czogci5zdGF0dXMsIGRldGFpbDogaiB9XG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICBjb25zdCB0ID0gYXdhaXQgci50ZXh0KCkuY2F0Y2goKCkgPT4gJycpXG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcjogJ2h0dHBfZXJyb3InLCBzdGF0dXM6IHIuc3RhdHVzLCBkZXRhaWw6IHQgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSkoKVxuICAgICAgICB0aGlzLm9uVG9vbEV2ZW50Py4oeyBraW5kOiAncmVzdWx0JywgbmFtZTogZWZmZWN0aXZlLCByZXN1bHQ6IHJlcyB9KVxuICAgICAgICBhd2FpdCB0aGlzLnNlbmRUb29sUmVzdWx0KGNhbGxJZCwgcmVzKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlcz8uc2xvdHMpKSB7XG4gICAgICAgICAgICBjb25zdCB0eiA9IHJlcz8udGltZVpvbmVcbiAgICAgICAgICAgIHRyeSB7IHRoaXMub25TbG90cz8uKHJlcy5zbG90cywgdHopIH0gY2F0Y2gge31cbiAgICAgICAgICAgIGlmIChyZXMuc2xvdHMubGVuZ3RoID09PSAwKSB0aGlzLnNwZWFrKCdObyBmcmVlIHNsb3RzIGZvdW5kIHRoYXQgZGF5LicpXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3QgbGlzdCA9IHJlcy5zbG90cy5zbGljZSgwLCA1KS5tYXAoKGl0OiBhbnkpID0+IHRoaXMuZm10UmFuZ2UoaXQuc3RhcnQsIGl0LmVuZCwgdHopKS5qb2luKCcsICcpXG4gICAgICAgICAgICAgIHRoaXMuc3BlYWsoYEF2YWlsYWJsZSBzbG90cyBhcmU6ICR7bGlzdH0uYClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHJlcz8uZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuc3BlYWsoJ0kgY291bGQgbm90IHJldHJpZXZlIHRoZSBkYXkgYXZhaWxhYmlsaXR5IGF0IHRoZSBtb21lbnQuJylcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2gge31cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGVyciA9IHsgZXJyb3I6IGBVbmtub3duIHRvb2wgJHtuYW1lIHx8ICd1bmtub3duJ31gIH1cbiAgICAgICAgdGhpcy5vblRvb2xFdmVudD8uKHsga2luZDogJ3Jlc3VsdCcsIG5hbWUsIHJlc3VsdDogZXJyIH0pXG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZFRvb2xSZXN1bHQoY2FsbElkLCBlcnIpXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc3QgZXJyID0geyBlcnJvcjogKGUgYXMgRXJyb3IpLm1lc3NhZ2UgfVxuICAgICAgdGhpcy5vblRvb2xFdmVudD8uKHsga2luZDogJ3Jlc3VsdCcsIG5hbWUsIHJlc3VsdDogZXJyIH0pXG4gICAgICBhd2FpdCB0aGlzLnNlbmRUb29sUmVzdWx0KGNhbGxJZCwgZXJyKVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgc2VuZFRvb2xSZXN1bHQoY2FsbElkOiBzdHJpbmcsIHJlc3VsdDogYW55KSB7XG4gICAgLy8gUHJvdmlkZSB0b29sIG91dHB1dCB0byB0aGUgbW9kZWwgYW5kIHJlcXVlc3QgaXQgdG8gY29udGludWVcbiAgICBjb25zdCBjcmVhdGVJdGVtID0ge1xuICAgICAgdHlwZTogJ2NvbnZlcnNhdGlvbi5pdGVtLmNyZWF0ZScsXG4gICAgICBpdGVtOiB7XG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbl9jYWxsX291dHB1dCcsXG4gICAgICAgIGNhbGxfaWQ6IGNhbGxJZCxcbiAgICAgICAgb3V0cHV0OiBKU09OLnN0cmluZ2lmeShyZXN1bHQpXG4gICAgICB9XG4gICAgfVxuICAgIC8vIERvIE5PVCBhdXRvLXRyaWdnZXIgYSBtb2RlbCByZXNwb25zZTsgd2Ugd2lsbCBzcGVhayBkZXRlcm1pbmlzdGljIHRleHQgZnJvbSB0b29sIHJlc3VsdHMuXG4gICAgdGhpcy5zZW5kT0FJKGNyZWF0ZUl0ZW0pXG4gIH1cblxuICBwcml2YXRlIGF0dGFjaERhdGFDaGFubmVsKGNoYW5uZWw6IFJUQ0RhdGFDaGFubmVsKSB7XG4gICAgdGhpcy5kYXRhQ2hhbm5lbCA9IGNoYW5uZWxcbiAgICBjaGFubmVsLm9ubWVzc2FnZSA9IChldikgPT4gdGhpcy5oYW5kbGVPQUlFdmVudChldi5kYXRhKVxuICAgIGNoYW5uZWwub25vcGVuID0gKCkgPT4ge1xuICAgICAgLy8gRmx1c2ggYW55IHF1ZXVlZCBtZXNzYWdlcyBvbmNlIGNoYW5uZWwgaXMgb3BlblxuICAgICAgaWYgKHRoaXMucGVuZGluZ01lc3NhZ2VzLmxlbmd0aCkge1xuICAgICAgICBmb3IgKGNvbnN0IG1zZyBvZiB0aGlzLnBlbmRpbmdNZXNzYWdlcykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjaGFubmVsLnNlbmQoSlNPTi5zdHJpbmdpZnkobXNnKSlcbiAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIC8vIGlnbm9yZSBzZW5kIGZhaWx1cmVzXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2VzID0gW11cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHNlbmRPQUkobXNnOiBhbnkpIHtcbiAgICBjb25zdCBkYyA9IHRoaXMuZGF0YUNoYW5uZWxcbiAgICBjb25zdCBwYXlsb2FkID0gSlNPTi5zdHJpbmdpZnkobXNnKVxuICAgIGlmIChkYyAmJiBkYy5yZWFkeVN0YXRlID09PSAnb3BlbicpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRjLnNlbmQocGF5bG9hZClcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICAvLyBJZiBzZW5kIGZhaWxzIHVuZXhwZWN0ZWRseSwgcXVldWUgaXQgZm9yIHJldHJ5IG9uIG5leHQgb3BlblxuICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlcy5wdXNoKG1zZylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZXMucHVzaChtc2cpXG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOlsiT3BlbkFJUmVhbHRpbWVBZ2VudCIsInNldENhbGVuZGFySWRzIiwiaWRzIiwiY2FsZW5kYXJJZHMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJyZXF1aXJlVG9vbCIsIm5hbWUiLCJvcHRzIiwic2VuZE9BSSIsInR5cGUiLCJpbnN0cnVjdGlvbnMiLCJyZXNwb25zZSIsInRvb2xfY2hvaWNlIiwibW9kYWxpdGllcyIsImF3YWl0aW5nVG9vbCIsImF3YWl0aW5nVG9vbFRpbWVyIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImZhbGxiYWNrVGltZXIiLCJwYXJzZWQiLCJwYXJzZVNsb3RGcm9tVHJhbnNjcmlwdCIsImxhc3RUcmFuc2NyaXB0IiwidHoiLCJvcmdhbml6YXRpb25JZCIsImRlZmF1bHRPcmdJZCIsImNhbGVuZGFySWQiLCJkZWZhdWx0Q2FsZW5kYXJJZCIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5Iiwic3RhcnQiLCJlbmQiLCJ0aGVuIiwiciIsIm9rIiwiaiIsImpzb24iLCJjYXRjaCIsImF2YWlsYWJsZSIsInNwZWFrIiwiZm10UmFuZ2UiLCJ0aW1lWm9uZSIsImRhdGUiLCJzbGljZSIsInNsb3RNaW51dGVzIiwicjIiLCJvazIiLCJqMiIsIkFycmF5IiwiaXNBcnJheSIsInNsb3RzIiwibGlzdCIsIm1hcCIsIml0Iiwiam9pbiIsInRleHQiLCJvblRvb2xFdmVudCIsImtpbmQiLCJmbXRUaW1lIiwiaXNvIiwiZCIsIkRhdGUiLCJmbXQiLCJJbnRsIiwiRGF0ZVRpbWVGb3JtYXQiLCJob3VyIiwibWludXRlIiwiZm9ybWF0Iiwic3RhcnRJc28iLCJlbmRJc28iLCJjb25uZWN0Iiwic3lzdGVtUHJvbXB0Iiwic2Vzc2lvbiIsImdyZWV0aW5nIiwibGFuZ3VhZ2UiLCJjbGllbnRfc2VjcmV0IiwidmFsdWUiLCJtb2RlbCIsIkVycm9yIiwicGMiLCJSVENQZWVyQ29ubmVjdGlvbiIsIm9udHJhY2siLCJlIiwic3RyZWFtIiwic3RyZWFtcyIsImF1ZGlvRWwiLCJzcmNPYmplY3QiLCJwbGF5Iiwib25kYXRhY2hhbm5lbCIsImV2ZW50IiwiY2hhbm5lbCIsImxhYmVsIiwiYXR0YWNoRGF0YUNoYW5uZWwiLCJkYyIsImNyZWF0ZURhdGFDaGFubmVsIiwibWljIiwibmF2aWdhdG9yIiwibWVkaWFEZXZpY2VzIiwiZ2V0VXNlck1lZGlhIiwiYXVkaW8iLCJnZXRUcmFja3MiLCJmb3JFYWNoIiwidCIsImFkZFRyYWNrIiwib2ZmZXIiLCJjcmVhdGVPZmZlciIsInNldExvY2FsRGVzY3JpcHRpb24iLCJiYXNlVXJsIiwic2RwUmVzcG9uc2UiLCJlbmNvZGVVUklDb21wb25lbnQiLCJBdXRob3JpemF0aW9uIiwic2RwIiwidHh0Iiwic3RhdHVzIiwiYW5zd2VyIiwic2V0UmVtb3RlRGVzY3JpcHRpb24iLCJzYWZlIiwicmVwbGFjZSIsImdyZWV0T25seSIsImRpc2Nvbm5lY3QiLCJjbG9zZSIsInN0b3AiLCJ0b29sQXJnc0J1ZmZlcnMiLCJjbGVhciIsImRhdGFDaGFubmVsIiwicGVuZGluZ01lc3NhZ2VzIiwiaW52b2tlVG9vbCIsImNhbGxJZCIsImFyZ3NKc29uIiwiYXJncyIsInBhcnNlIiwic2VuZFRvb2xSZXN1bHQiLCJlcnJvciIsImVmZmVjdGl2ZSIsImN1c3RvbWVyIiwicmVzIiwiZGV0YWlsIiwicmVzdWx0IiwicyIsInR6MiIsIm9uU2xvdHMiLCJub3RlcyIsImFwcG9pbnRtZW50IiwiYnVzaW5lc3NIb3VycyIsImVyciIsIm1lc3NhZ2UiLCJjcmVhdGVJdGVtIiwiaXRlbSIsImNhbGxfaWQiLCJvdXRwdXQiLCJvbm1lc3NhZ2UiLCJldiIsImhhbmRsZU9BSUV2ZW50IiwiZGF0YSIsIm9ub3BlbiIsIm1zZyIsInNlbmQiLCJwYXlsb2FkIiwicmVhZHlTdGF0ZSIsInB1c2giLCJjb25zdHJ1Y3RvciIsIk1hcCIsInRvb2xIaW50U2VudCIsInJhdyIsImsiLCJzdGFydHNXaXRoIiwiY29uc29sZSIsImRlYnVnIiwib25UcmFuc2NyaXB0IiwidG9vbEhpbnQiLCJ0b0xvd2VyQ2FzZSIsImhhc1RpbWUiLCJ0ZXN0IiwiZGF5UXVlcnkiLCJpZCIsImN1ciIsImdldCIsInNldCIsImRlbHRhIiwiYnVmIiwiYXJndW1lbnRzIiwiQXVkaW8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/agent/openai-realtime.ts\n"));

/***/ })

});