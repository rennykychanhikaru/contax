[{"/Users/rennychan/Personal Apps/contax/app/(home)/SignOutButton.tsx":"1","/Users/rennychan/Personal Apps/contax/app/(home)/UserDropdownMenu.tsx":"2","/Users/rennychan/Personal Apps/contax/app/(home)/layout.tsx":"3","/Users/rennychan/Personal Apps/contax/app/(home)/page.tsx":"4","/Users/rennychan/Personal Apps/contax/app/agent-settings/AgentResponseTypeForm.tsx":"5","/Users/rennychan/Personal Apps/contax/app/agent-settings/AgentSettingsForm.tsx":"6","/Users/rennychan/Personal Apps/contax/app/agent-settings/page.tsx":"7","/Users/rennychan/Personal Apps/contax/app/api/agents/[agent_id]/appointments/book/route.ts":"8","/Users/rennychan/Personal Apps/contax/app/api/agents/[agent_id]/calendar/check-availability/route.ts":"9","/Users/rennychan/Personal Apps/contax/app/api/agents/[agent_id]/calendar/list/route.ts":"10","/Users/rennychan/Personal Apps/contax/app/api/agents/[agent_id]/calendar/oauth/start/route.ts":"11","/Users/rennychan/Personal Apps/contax/app/api/agents/[agent_id]/calendar/slots/route.ts":"12","/Users/rennychan/Personal Apps/contax/app/api/agents/[agent_id]/calendar/status/route.ts":"13","/Users/rennychan/Personal Apps/contax/app/api/agents/default/route.ts":"14","/Users/rennychan/Personal Apps/contax/app/api/agents/route.ts":"15","/Users/rennychan/Personal Apps/contax/app/api/appointments/book/route.ts":"16","/Users/rennychan/Personal Apps/contax/app/api/calendar/check-availability/route.ts":"17","/Users/rennychan/Personal Apps/contax/app/api/calendar/list/route.ts":"18","/Users/rennychan/Personal Apps/contax/app/api/calendar/oauth/agent-callback/route.ts":"19","/Users/rennychan/Personal Apps/contax/app/api/calendar/slots/route.ts":"20","/Users/rennychan/Personal Apps/contax/app/api/calendar/status/route.ts":"21","/Users/rennychan/Personal Apps/contax/app/api/calendar/token/route.ts":"22","/Users/rennychan/Personal Apps/contax/app/api/google/oauth/callback/route.ts":"23","/Users/rennychan/Personal Apps/contax/app/api/google/oauth/start/route.ts":"24","/Users/rennychan/Personal Apps/contax/app/api/onboarding/route.ts":"25","/Users/rennychan/Personal Apps/contax/app/api/org/default/route.ts":"26","/Users/rennychan/Personal Apps/contax/app/api/realtime/token/route.ts":"27","/Users/rennychan/Personal Apps/contax/app/api/settings/twilio/route.ts":"28","/Users/rennychan/Personal Apps/contax/app/api/settings/webhook/route.ts":"29","/Users/rennychan/Personal Apps/contax/app/api/test-env/route.ts":"30","/Users/rennychan/Personal Apps/contax/app/api/webhook/[userId]/[token]/route.ts":"31","/Users/rennychan/Personal Apps/contax/app/api/webhook/agent/[token]/trigger/route.ts":"32","/Users/rennychan/Personal Apps/contax/app/api/webhook/agent/[token]/twiml/route.ts":"33","/Users/rennychan/Personal Apps/contax/app/api/webhook/call-status/route.ts":"34","/Users/rennychan/Personal Apps/contax/app/api/webhook/org/[token]/trigger-call/route.ts":"35","/Users/rennychan/Personal Apps/contax/app/api/webhook/outgoing-call/route.ts":"36","/Users/rennychan/Personal Apps/contax/app/api/webhook/trigger-call/route.ts":"37","/Users/rennychan/Personal Apps/contax/app/auth/callback/route.ts":"38","/Users/rennychan/Personal Apps/contax/app/auth/layout.tsx":"39","/Users/rennychan/Personal Apps/contax/app/auth/sign-in/page.tsx":"40","/Users/rennychan/Personal Apps/contax/app/auth/sign-up/page.tsx":"41","/Users/rennychan/Personal Apps/contax/app/layout.tsx":"42","/Users/rennychan/Personal Apps/contax/app/onboarding/page.tsx":"43","/Users/rennychan/Personal Apps/contax/app/settings/CalendarSettings.tsx":"44","/Users/rennychan/Personal Apps/contax/app/settings/TwilioIntegrationForm.tsx":"45","/Users/rennychan/Personal Apps/contax/app/settings/WebhookGenerator.tsx":"46","/Users/rennychan/Personal Apps/contax/app/settings/page.tsx":"47","/Users/rennychan/Personal Apps/contax/components/CalendarStatus.tsx":"48","/Users/rennychan/Personal Apps/contax/components/OutgoingCallTrigger.tsx":"49","/Users/rennychan/Personal Apps/contax/components/PromptModal.tsx":"50","/Users/rennychan/Personal Apps/contax/components/shared/Header.tsx":"51","/Users/rennychan/Personal Apps/contax/components/shared/VoiceAgent.tsx":"52","/Users/rennychan/Personal Apps/contax/components/shared/providers.tsx":"53","/Users/rennychan/Personal Apps/contax/components/ui/alert.tsx":"54","/Users/rennychan/Personal Apps/contax/components/ui/badge.tsx":"55","/Users/rennychan/Personal Apps/contax/components/ui/button.tsx":"56","/Users/rennychan/Personal Apps/contax/components/ui/card.tsx":"57","/Users/rennychan/Personal Apps/contax/components/ui/checkbox.tsx":"58","/Users/rennychan/Personal Apps/contax/components/ui/collapsible.tsx":"59","/Users/rennychan/Personal Apps/contax/components/ui/dialog.tsx":"60","/Users/rennychan/Personal Apps/contax/components/ui/input.tsx":"61","/Users/rennychan/Personal Apps/contax/components/ui/label.tsx":"62","/Users/rennychan/Personal Apps/contax/components/ui/select.tsx":"63","/Users/rennychan/Personal Apps/contax/components/ui/separator.tsx":"64","/Users/rennychan/Personal Apps/contax/components/ui/switch.tsx":"65","/Users/rennychan/Personal Apps/contax/components/ui/textarea.tsx":"66","/Users/rennychan/Personal Apps/contax/components/ui/tooltip.tsx":"67","/Users/rennychan/Personal Apps/contax/lib/adapters/types.ts":"68","/Users/rennychan/Personal Apps/contax/lib/agent/openai-realtime.ts":"69","/Users/rennychan/Personal Apps/contax/lib/security/crypto.ts":"70","/Users/rennychan/Personal Apps/contax/lib/security/rate-limiter.ts":"71","/Users/rennychan/Personal Apps/contax/lib/security/webhook-auth.ts":"72","/Users/rennychan/Personal Apps/contax/lib/security/webhook-test-helper.ts":"73","/Users/rennychan/Personal Apps/contax/lib/security/webhook.ts":"74","/Users/rennychan/Personal Apps/contax/lib/services/agent-calendar.ts":"75","/Users/rennychan/Personal Apps/contax/lib/services/calendar-service.ts":"76","/Users/rennychan/Personal Apps/contax/lib/services/google.ts":"77","/Users/rennychan/Personal Apps/contax/lib/services/token-service.ts":"78","/Users/rennychan/Personal Apps/contax/lib/telephony/twilio.ts":"79","/Users/rennychan/Personal Apps/contax/lib/utils/api-errors.ts":"80","/Users/rennychan/Personal Apps/contax/lib/utils/cookie-config.ts":"81","/Users/rennychan/Personal Apps/contax/lib/utils/date-utils.ts":"82","/Users/rennychan/Personal Apps/contax/lib/utils/logger.ts":"83","/Users/rennychan/Personal Apps/contax/lib/utils/utils.ts":"84","/Users/rennychan/Personal Apps/contax/lib/utils.ts":"85"},{"size":665,"mtime":1757792504229,"results":"86","hashOfConfig":"87"},{"size":2597,"mtime":1757792504244,"results":"88","hashOfConfig":"87"},{"size":309,"mtime":1757792504248,"results":"89","hashOfConfig":"87"},{"size":1917,"mtime":1757792504266,"results":"90","hashOfConfig":"87"},{"size":4551,"mtime":1757793277382,"results":"91","hashOfConfig":"87"},{"size":17076,"mtime":1757793378324,"results":"92","hashOfConfig":"87"},{"size":2381,"mtime":1757792504196,"results":"93","hashOfConfig":"87"},{"size":4921,"mtime":1757792734820,"results":"94","hashOfConfig":"87"},{"size":1735,"mtime":1757792213348,"results":"95","hashOfConfig":"87"},{"size":2161,"mtime":1757793324638,"results":"96","hashOfConfig":"87"},{"size":2881,"mtime":1757792752519,"results":"97","hashOfConfig":"87"},{"size":1595,"mtime":1757792213349,"results":"98","hashOfConfig":"87"},{"size":1557,"mtime":1757792213348,"results":"99","hashOfConfig":"87"},{"size":6621,"mtime":1757793397430,"results":"100","hashOfConfig":"87"},{"size":11370,"mtime":1757793302590,"results":"101","hashOfConfig":"87"},{"size":1959,"mtime":1757792213342,"results":"102","hashOfConfig":"87"},{"size":437,"mtime":1757792213341,"results":"103","hashOfConfig":"87"},{"size":270,"mtime":1757792213341,"results":"104","hashOfConfig":"87"},{"size":6080,"mtime":1757792762441,"results":"105","hashOfConfig":"87"},{"size":310,"mtime":1757792213342,"results":"106","hashOfConfig":"87"},{"size":274,"mtime":1757793521416,"results":"107","hashOfConfig":"87"},{"size":796,"mtime":1757792213340,"results":"108","hashOfConfig":"87"},{"size":2808,"mtime":1757792864047,"results":"109","hashOfConfig":"87"},{"size":1797,"mtime":1757792869756,"results":"110","hashOfConfig":"87"},{"size":3393,"mtime":1757792213350,"results":"111","hashOfConfig":"87"},{"size":1971,"mtime":1757792213342,"results":"112","hashOfConfig":"87"},{"size":5801,"mtime":1757793530722,"results":"113","hashOfConfig":"87"},{"size":8673,"mtime":1757793337307,"results":"114","hashOfConfig":"87"},{"size":7786,"mtime":1757793539034,"results":"115","hashOfConfig":"87"},{"size":1130,"mtime":1757792213350,"results":"116","hashOfConfig":"87"},{"size":3920,"mtime":1757792883690,"results":"117","hashOfConfig":"87"},{"size":4235,"mtime":1757792213339,"results":"118","hashOfConfig":"87"},{"size":2157,"mtime":1757792213339,"results":"119","hashOfConfig":"87"},{"size":2111,"mtime":1757792213339,"results":"120","hashOfConfig":"87"},{"size":6785,"mtime":1757792213338,"results":"121","hashOfConfig":"87"},{"size":3707,"mtime":1757792213337,"results":"122","hashOfConfig":"87"},{"size":13004,"mtime":1757792213338,"results":"123","hashOfConfig":"87"},{"size":1625,"mtime":1757792213334,"results":"124","hashOfConfig":"87"},{"size":632,"mtime":1757792504215,"results":"125","hashOfConfig":"87"},{"size":3712,"mtime":1757792504220,"results":"126","hashOfConfig":"87"},{"size":5271,"mtime":1757792504211,"results":"127","hashOfConfig":"87"},{"size":473,"mtime":1757792504271,"results":"128","hashOfConfig":"87"},{"size":3807,"mtime":1757792504279,"results":"129","hashOfConfig":"87"},{"size":5661,"mtime":1757792504139,"results":"130","hashOfConfig":"87"},{"size":6308,"mtime":1757792504117,"results":"131","hashOfConfig":"87"},{"size":3874,"mtime":1757792504104,"results":"132","hashOfConfig":"87"},{"size":2550,"mtime":1757792504143,"results":"133","hashOfConfig":"87"},{"size":2433,"mtime":1757792506631,"results":"134","hashOfConfig":"87"},{"size":4113,"mtime":1757792506654,"results":"135","hashOfConfig":"87"},{"size":1221,"mtime":1757792506647,"results":"136","hashOfConfig":"87"},{"size":1713,"mtime":1757792939973,"results":"137","hashOfConfig":"87"},{"size":27206,"mtime":1757792591236,"results":"138","hashOfConfig":"87"},{"size":389,"mtime":1757792506643,"results":"139","hashOfConfig":"87"},{"size":1813,"mtime":1757792506586,"results":"140","hashOfConfig":"87"},{"size":1172,"mtime":1757792506598,"results":"141","hashOfConfig":"87"},{"size":1842,"mtime":1757792506609,"results":"142","hashOfConfig":"87"},{"size":1541,"mtime":1757792506572,"results":"143","hashOfConfig":"87"},{"size":982,"mtime":1757792506611,"results":"144","hashOfConfig":"87"},{"size":335,"mtime":1757792506614,"results":"145","hashOfConfig":"87"},{"size":3853,"mtime":1757792506594,"results":"146","hashOfConfig":"87"},{"size":828,"mtime":1757792506628,"results":"147","hashOfConfig":"87"},{"size":715,"mtime":1757792506577,"results":"148","hashOfConfig":"87"},{"size":5101,"mtime":1757792506618,"results":"149","hashOfConfig":"87"},{"size":775,"mtime":1757792506605,"results":"150","hashOfConfig":"87"},{"size":1161,"mtime":1757792506590,"results":"151","hashOfConfig":"87"},{"size":777,"mtime":1757792506621,"results":"152","hashOfConfig":"87"},{"size":1161,"mtime":1757792506582,"results":"153","hashOfConfig":"87"},{"size":628,"mtime":1757792253492,"results":"154","hashOfConfig":"87"},{"size":28786,"mtime":1757792253487,"results":"155","hashOfConfig":"87"},{"size":5095,"mtime":1757792253423,"results":"156","hashOfConfig":"87"},{"size":7411,"mtime":1757792253428,"results":"157","hashOfConfig":"87"},{"size":5278,"mtime":1757792253412,"results":"158","hashOfConfig":"87"},{"size":3368,"mtime":1757792253436,"results":"159","hashOfConfig":"87"},{"size":11310,"mtime":1757792253433,"results":"160","hashOfConfig":"87"},{"size":6804,"mtime":1757792253512,"results":"161","hashOfConfig":"87"},{"size":24038,"mtime":1757792950809,"results":"162","hashOfConfig":"87"},{"size":7161,"mtime":1757792253509,"results":"163","hashOfConfig":"87"},{"size":9551,"mtime":1757792253505,"results":"164","hashOfConfig":"87"},{"size":3253,"mtime":1757792253497,"results":"165","hashOfConfig":"87"},{"size":10732,"mtime":1757792253482,"results":"166","hashOfConfig":"87"},{"size":3592,"mtime":1757792253473,"results":"167","hashOfConfig":"87"},{"size":3983,"mtime":1757792253467,"results":"168","hashOfConfig":"87"},{"size":3680,"mtime":1757792253478,"results":"169","hashOfConfig":"87"},{"size":165,"mtime":1757792253470,"results":"170","hashOfConfig":"87"},{"size":165,"mtime":1757792253463,"results":"171","hashOfConfig":"87"},{"filePath":"172","messages":"173","suppressedMessages":"174","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"ltsvej",{"filePath":"175","messages":"176","suppressedMessages":"177","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"178","messages":"179","suppressedMessages":"180","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"181","messages":"182","suppressedMessages":"183","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"184"},{"filePath":"185","messages":"186","suppressedMessages":"187","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"188","messages":"189","suppressedMessages":"190","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"191","messages":"192","suppressedMessages":"193","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"194","messages":"195","suppressedMessages":"196","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"197"},{"filePath":"198","messages":"199","suppressedMessages":"200","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"201"},{"filePath":"202","messages":"203","suppressedMessages":"204","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"205","messages":"206","suppressedMessages":"207","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"208"},{"filePath":"209","messages":"210","suppressedMessages":"211","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"212"},{"filePath":"213","messages":"214","suppressedMessages":"215","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"216"},{"filePath":"217","messages":"218","suppressedMessages":"219","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"220","messages":"221","suppressedMessages":"222","errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"223","messages":"224","suppressedMessages":"225","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"226","messages":"227","suppressedMessages":"228","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"229","messages":"230","suppressedMessages":"231","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"232","messages":"233","suppressedMessages":"234","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"235"},{"filePath":"236","messages":"237","suppressedMessages":"238","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"239","messages":"240","suppressedMessages":"241","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"242","messages":"243","suppressedMessages":"244","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"245","messages":"246","suppressedMessages":"247","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"248","messages":"249","suppressedMessages":"250","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"251","messages":"252","suppressedMessages":"253","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"254"},{"filePath":"255","messages":"256","suppressedMessages":"257","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"258"},{"filePath":"259","messages":"260","suppressedMessages":"261","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"262","messages":"263","suppressedMessages":"264","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"265","messages":"266","suppressedMessages":"267","errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"268","messages":"269","suppressedMessages":"270","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"271","messages":"272","suppressedMessages":"273","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"274","messages":"275","suppressedMessages":"276","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"277"},{"filePath":"278","messages":"279","suppressedMessages":"280","errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"281"},{"filePath":"282","messages":"283","suppressedMessages":"284","errorCount":4,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"285"},{"filePath":"286","messages":"287","suppressedMessages":"288","errorCount":4,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"289"},{"filePath":"290","messages":"291","suppressedMessages":"292","errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"293"},{"filePath":"294","messages":"295","suppressedMessages":"296","errorCount":4,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"297"},{"filePath":"298","messages":"299","suppressedMessages":"300","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"301","messages":"302","suppressedMessages":"303","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"304","messages":"305","suppressedMessages":"306","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"307","messages":"308","suppressedMessages":"309","errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"310"},{"filePath":"311","messages":"312","suppressedMessages":"313","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"314","messages":"315","suppressedMessages":"316","errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"317"},{"filePath":"318","messages":"319","suppressedMessages":"320","errorCount":10,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"321"},{"filePath":"322","messages":"323","suppressedMessages":"324","errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"325"},{"filePath":"326","messages":"327","suppressedMessages":"328","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"329"},{"filePath":"330","messages":"331","suppressedMessages":"332","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"333","messages":"334","suppressedMessages":"335","errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"336"},{"filePath":"337","messages":"338","suppressedMessages":"339","errorCount":1,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"340"},{"filePath":"341","messages":"342","suppressedMessages":"343","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"344","messages":"345","suppressedMessages":"346","errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"347"},{"filePath":"348","messages":"349","suppressedMessages":"350","errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"351"},{"filePath":"352","messages":"353","suppressedMessages":"354","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"355","messages":"356","suppressedMessages":"357","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"358","messages":"359","suppressedMessages":"360","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"361","messages":"362","suppressedMessages":"363","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"364","messages":"365","suppressedMessages":"366","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"367","messages":"368","suppressedMessages":"369","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"370","messages":"371","suppressedMessages":"372","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"373","messages":"374","suppressedMessages":"375","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"376","messages":"377","suppressedMessages":"378","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"379","messages":"380","suppressedMessages":"381","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"382","messages":"383","suppressedMessages":"384","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"385","messages":"386","suppressedMessages":"387","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"388","messages":"389","suppressedMessages":"390","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"391","messages":"392","suppressedMessages":"393","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"394","messages":"395","suppressedMessages":"396","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"397","messages":"398","suppressedMessages":"399","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"400","messages":"401","suppressedMessages":"402","errorCount":25,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"403"},{"filePath":"404","messages":"405","suppressedMessages":"406","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"407"},{"filePath":"408","messages":"409","suppressedMessages":"410","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"411"},{"filePath":"412","messages":"413","suppressedMessages":"414","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"415","messages":"416","suppressedMessages":"417","errorCount":1,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"418"},{"filePath":"419","messages":"420","suppressedMessages":"421","errorCount":5,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"422"},{"filePath":"423","messages":"424","suppressedMessages":"425","errorCount":4,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"426"},{"filePath":"427","messages":"428","suppressedMessages":"429","errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"430"},{"filePath":"431","messages":"432","suppressedMessages":"433","errorCount":1,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"434"},{"filePath":"435","messages":"436","suppressedMessages":"437","errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"438"},{"filePath":"439","messages":"440","suppressedMessages":"441","errorCount":2,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"442"},{"filePath":"443","messages":"444","suppressedMessages":"445","errorCount":20,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"446"},{"filePath":"447","messages":"448","suppressedMessages":"449","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"450"},{"filePath":"451","messages":"452","suppressedMessages":"453","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"454","messages":"455","suppressedMessages":"456","errorCount":1,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"457"},{"filePath":"458","messages":"459","suppressedMessages":"460","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"461","messages":"462","suppressedMessages":"463","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/rennychan/Personal Apps/contax/app/(home)/SignOutButton.tsx",[],[],"/Users/rennychan/Personal Apps/contax/app/(home)/UserDropdownMenu.tsx",[],[],"/Users/rennychan/Personal Apps/contax/app/(home)/layout.tsx",[],[],"/Users/rennychan/Personal Apps/contax/app/(home)/page.tsx",["464"],[],"'use client'\n\nimport { useState, useEffect } from 'react'\nimport { VoiceAgentStyled } from '../../components/shared/VoiceAgent'\nimport { Loader2 } from 'lucide-react'\n\ninterface AgentConfig {\n  id: string\n  name: string\n  display_name?: string\n  description?: string\n  prompt: string\n  greeting: string\n  language?: string\n  temperature?: number\n  max_tokens?: number\n  is_demo?: boolean\n  agent_type?: string\n}\n\ninterface Organization {\n  id: string\n  name: string\n}\n\nexport default function Page() {\n  const [loading, setLoading] = useState(true)\n  const [agent, setAgent] = useState<AgentConfig | null>(null)\n  const [organization, setOrganization] = useState<Organization | null>(null)\n\n  useEffect(() => {\n    fetchDefaultAgent()\n  }, [])\n\n  const fetchDefaultAgent = async () => {\n    try {\n      const res = await fetch('/api/agents/default')\n      if (res.ok) {\n        const data = await res.json()\n        if (data.agent) {\n          setAgent(data.agent)\n        }\n        if (data.organization) {\n          setOrganization(data.organization)\n        }\n      }\n    } catch (error) {\n      console.error('Failed to fetch agent:', error)\n    } finally {\n      setLoading(false)\n    }\n  }\n\n\n  if (loading) {\n    return (\n      <main className=\"container max-w-6xl mx-auto p-6\">\n        <div className=\"flex items-center justify-center h-64\">\n          <Loader2 className=\"h-8 w-8 animate-spin\" />\n        </div>\n      </main>\n    )\n  }\n\n  return (\n    <main className=\"container max-w-6xl mx-auto p-6\">\n      <VoiceAgentStyled \n        agentId={agent?.id}\n        systemPrompt={agent?.prompt || ''} \n        greeting={agent?.greeting || ''} \n        language={agent?.language || \"en-US\"}\n        agentName={agent?.display_name || 'Voice Scheduling Assistant'}\n        organizationName={organization?.name}\n        isDemo={agent?.is_demo}\n        agentDescription={agent?.description}\n      />\n    </main>\n  )\n}","/Users/rennychan/Personal Apps/contax/app/agent-settings/AgentResponseTypeForm.tsx",["465","466"],[],"/Users/rennychan/Personal Apps/contax/app/agent-settings/AgentSettingsForm.tsx",["467","468","469","470","471"],[],"/Users/rennychan/Personal Apps/contax/app/agent-settings/page.tsx",[],[],"/Users/rennychan/Personal Apps/contax/app/api/agents/[agent_id]/appointments/book/route.ts",["472","473","474","475"],[],"import { NextRequest } from 'next/server';\nimport { cookies } from 'next/headers';\nimport { createServerClient } from '@supabase/ssr';\nimport { CalendarService } from '../../../../../../lib/services/calendar-service';\nimport { validateAgentAccess } from '@/lib/services/agent-calendar';\n\nexport async function POST(\n  req: NextRequest,\n  { params }: { params: Promise<{ agent_id: string }> }\n) {\n  try {\n    const { agent_id } = await params;\n    const cookieStore = await cookies();\n    const supabase = createServerClient(\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\n      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n      {\n        cookies: {\n          getAll() {\n            return cookieStore.getAll();\n          },\n          setAll(cookiesToSet) {\n            try {\n              cookiesToSet.forEach(({ name, value, options }) => {\n                cookieStore.set(name, value, options);\n              });\n            } catch (error) {\n              console.error('Error setting cookies:', error);\n            }\n          },\n        },\n      }\n    );\n\n    const { data: { user } } = await supabase.auth.getUser();\n    if (!user) {\n      return CalendarService.createResponse({ success: false, error: 'Unauthorized' }, 401);\n    }\n\n    // Validate agent access\n    const agentAccess = await validateAgentAccess(agent_id, user.id);\n    if (!agentAccess) {\n      return CalendarService.createResponse({ success: false, error: 'Agent not found or access denied' }, 404);\n    }\n\n    const body = await req.json();\n    const { customer, start, end, notes, calendarId } = body;\n\n    if (!start || !end) {\n      return CalendarService.createResponse({\n        success: false,\n        error: 'Start and end times are required'\n      }, 400);\n    }\n\n    // Check availability first\n    const availabilityCheck = await CalendarService.checkAvailability({\n      start,\n      end,\n      calendarId\n    }, agent_id, user.id);\n\n    if (availabilityCheck.success && !availabilityCheck.data?.available) {\n      return CalendarService.createResponse({\n        success: false,\n        error: 'Time slot is not available',\n        data: { conflicts: availabilityCheck.data.conflicts }\n      }, 409);\n    }\n\n    // Book the appointment\n    const bookingRequest = {\n      summary: customer?.name ? `Meeting with ${customer.name}` : 'Meeting',\n      description: notes || `Booked via Agent: ${agentAccess.agent.name}`,\n      start,\n      end,\n      attendees: customer?.email ? [{ email: customer.email }] : [],\n      calendarId,\n      createMeetLink: true\n    };\n\n    const result = await CalendarService.bookAppointment(bookingRequest, agent_id, user.id);\n\n    if (!result.success) {\n      return CalendarService.createResponse(result, 500);\n    }\n\n    // Store appointment in database\n    try {\n      const { data: appointment, error: dbError } = await supabase\n        .from('appointments')\n        .insert({\n          organization_id: agentAccess.organization.id,\n          agent_id: agent_id,\n          customer_name: customer?.name,\n          customer_email: customer?.email,\n          customer_phone: customer?.phone,\n          scheduled_start: start,\n          scheduled_end: end,\n          google_event_id: result.data?.id,\n          google_calendar_id: calendarId || 'primary',\n          notes: notes,\n          status: 'scheduled'\n        })\n        .select()\n        .single();\n\n      if (dbError) {\n        console.error('Failed to store appointment in database:', dbError);\n      }\n\n      const responseData = {\n        success: true,\n        event: {\n          id: result.data?.id,\n          htmlLink: result.data?.htmlLink,\n          start: result.data?.start,\n          end: result.data?.end,\n          summary: result.data?.summary,\n          meetLink: result.data?.hangoutLink\n        },\n        appointment\n      };\n\n      return CalendarService.createResponse({\n        success: true,\n        data: responseData,\n        cookies: result.cookies\n      });\n    } catch (dbError) {\n      console.error('Database error storing appointment:', dbError);\n      // Still return success since the calendar event was created\n      const responseData = {\n        success: true,\n        event: {\n          id: result.data?.id,\n          htmlLink: result.data?.htmlLink,\n          start: result.data?.start,\n          end: result.data?.end,\n          summary: result.data?.summary,\n          meetLink: result.data?.hangoutLink\n        },\n        appointment: null,\n        warning: 'Event created but failed to store in database'\n      };\n\n      return CalendarService.createResponse({\n        success: true,\n        data: responseData,\n        cookies: result.cookies\n      });\n    }\n  } catch (error) {\n    console.error('Error booking appointment:', error);\n    return CalendarService.createResponse({\n      success: false,\n      error: error instanceof Error ? error.message : 'Failed to book appointment'\n    }, 500);\n  }\n}","/Users/rennychan/Personal Apps/contax/app/api/agents/[agent_id]/calendar/check-availability/route.ts",["476","477"],[],"import { NextRequest } from 'next/server';\nimport { cookies } from 'next/headers';\nimport { createServerClient } from '@supabase/ssr';\nimport { CalendarService } from '../../../../../../lib/services/calendar-service';\n\nexport async function POST(\n  req: NextRequest,\n  { params }: { params: Promise<{ agent_id: string }> }\n) {\n  try {\n    const { agent_id } = await params;\n    const cookieStore = await cookies();\n    const supabase = createServerClient(\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\n      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n      {\n        cookies: {\n          getAll() {\n            return cookieStore.getAll();\n          },\n          setAll(cookiesToSet) {\n            try {\n              cookiesToSet.forEach(({ name, value, options }) => {\n                cookieStore.set(name, value, options);\n              });\n            } catch (error) {\n              console.error('Error setting cookies:', error);\n            }\n          },\n        },\n      }\n    );\n\n    const { data: { user } } = await supabase.auth.getUser();\n    if (!user) {\n      return CalendarService.createResponse({ success: false, error: 'Unauthorized' }, 401);\n    }\n\n    const body = await req.json();\n    const result = await CalendarService.checkAvailability(body, agent_id, user.id);\n\n    if (result.success && result.data?.error === 'broad_window') {\n      return CalendarService.createResponse(result, 422);\n    }\n\n    return CalendarService.createResponse(result);\n  } catch (error) {\n    console.error('Error checking agent calendar availability:', error);\n    return CalendarService.createResponse({\n      success: false,\n      error: error instanceof Error ? error.message : 'Failed to check availability'\n    }, 500);\n  }\n}","/Users/rennychan/Personal Apps/contax/app/api/agents/[agent_id]/calendar/list/route.ts",["478","479"],[],"/Users/rennychan/Personal Apps/contax/app/api/agents/[agent_id]/calendar/oauth/start/route.ts",["480","481"],[],"import { NextRequest, NextResponse } from 'next/server';\nimport { cookies } from 'next/headers';\nimport { createServerClient } from '@supabase/ssr';\nimport { validateAgentAccess } from '@/lib/services/agent-calendar';\n\nconst GOOGLE_AUTH_URL = 'https://accounts.google.com/o/oauth2/v2/auth';\nconst GOOGLE_SCOPES = [\n  'https://www.googleapis.com/auth/calendar',\n  'https://www.googleapis.com/auth/userinfo.email'\n];\n\nexport async function GET(\n  req: NextRequest,\n  { params }: { params: Promise<{ agent_id: string }> }\n) {\n  try {\n    const { agent_id } = await params;\n    const cookieStore = await cookies();\n    const supabase = createServerClient(\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\n      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n      {\n        cookies: {\n          getAll() {\n            return cookieStore.getAll();\n          },\n          setAll(cookiesToSet) {\n            try {\n              cookiesToSet.forEach(({ name, value, options }) => {\n                cookieStore.set(name, value, options);\n              });\n            } catch (error) {\n              console.error('Error setting cookies:', error);\n            }\n          },\n        },\n      }\n    );\n    const { data: { user } } = await supabase.auth.getUser();\n    \n    if (!user) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n    \n    // Validate agent access\n    const agentAccess = await validateAgentAccess(agent_id, user.id);\n    if (!agentAccess) {\n      return NextResponse.json({ error: 'Agent not found or access denied' }, { status: 404 });\n    }\n    \n    const clientId = process.env.GOOGLE_CLIENT_ID;\n    const baseUrl = process.env.NEXT_PUBLIC_SITE_URL || req.nextUrl.origin;\n    \n    if (!clientId) {\n      return NextResponse.json(\n        { error: 'Google Calendar integration not configured' },\n        { status: 500 }\n      );\n    }\n    \n    // Create state parameter with agent_id\n    const state = Buffer.from(JSON.stringify({\n      agent_id: agent_id,\n      redirect_url: req.nextUrl.searchParams.get('redirect') || '/settings'\n    })).toString('base64');\n    \n    // Build OAuth URL\n    const authUrl = new URL(GOOGLE_AUTH_URL);\n    authUrl.searchParams.set('client_id', clientId);\n    authUrl.searchParams.set('redirect_uri', `${baseUrl}/api/calendar/oauth/agent-callback`);\n    authUrl.searchParams.set('response_type', 'code');\n    authUrl.searchParams.set('scope', GOOGLE_SCOPES.join(' '));\n    authUrl.searchParams.set('access_type', 'offline');\n    authUrl.searchParams.set('prompt', 'consent');\n    authUrl.searchParams.set('state', state);\n    \n    return NextResponse.redirect(authUrl.toString());\n  } catch (error) {\n    console.error('Error starting OAuth flow:', error);\n    return NextResponse.json(\n      { error: error instanceof Error ? error.message : 'Failed to start OAuth flow' },\n      { status: 500 }\n    );\n  }\n}","/Users/rennychan/Personal Apps/contax/app/api/agents/[agent_id]/calendar/slots/route.ts",["482","483"],[],"import { NextRequest } from 'next/server';\nimport { cookies } from 'next/headers';\nimport { createServerClient } from '@supabase/ssr';\nimport { CalendarService } from '../../../../../../lib/services/calendar-service';\n\nexport async function POST(\n  req: NextRequest,\n  { params }: { params: Promise<{ agent_id: string }> }\n) {\n  try {\n    const { agent_id } = await params;\n    const cookieStore = await cookies();\n    const supabase = createServerClient(\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\n      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n      {\n        cookies: {\n          getAll() {\n            return cookieStore.getAll();\n          },\n          setAll(cookiesToSet) {\n            try {\n              cookiesToSet.forEach(({ name, value, options }) => {\n                cookieStore.set(name, value, options);\n              });\n            } catch (error) {\n              console.error('Error setting cookies:', error);\n            }\n          },\n        },\n      }\n    );\n\n    const { data: { user } } = await supabase.auth.getUser();\n    if (!user) {\n      return CalendarService.createResponse({ success: false, error: 'Unauthorized' }, 401);\n    }\n\n    const body = await req.json();\n    const result = await CalendarService.getAvailableSlots(body, agent_id, user.id);\n    return CalendarService.createResponse(result);\n  } catch (error) {\n    console.error('Error getting agent calendar slots:', error);\n    return CalendarService.createResponse({\n      success: false,\n      error: error instanceof Error ? error.message : 'Failed to get available slots'\n    }, 500);\n  }\n}","/Users/rennychan/Personal Apps/contax/app/api/agents/[agent_id]/calendar/status/route.ts",["484","485"],[],"import { NextRequest } from 'next/server';\nimport { cookies } from 'next/headers';\nimport { createServerClient } from '@supabase/ssr';\nimport { CalendarService } from '../../../../../../lib/services/calendar-service';\n\nexport async function GET(\n  req: NextRequest,\n  { params }: { params: Promise<{ agent_id: string }> }\n) {\n  try {\n    const { agent_id } = await params;\n    const cookieStore = await cookies();\n    const supabase = createServerClient(\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\n      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n      {\n        cookies: {\n          getAll() {\n            return cookieStore.getAll();\n          },\n          setAll(cookiesToSet) {\n            try {\n              cookiesToSet.forEach(({ name, value, options }) => {\n                cookieStore.set(name, value, options);\n              });\n            } catch (error) {\n              console.error('Error setting cookies:', error);\n            }\n          },\n        },\n      }\n    );\n\n    const { data: { user } } = await supabase.auth.getUser();\n    if (!user) {\n      return CalendarService.createResponse({ success: false, error: 'Unauthorized' }, 401);\n    }\n\n    const result = await CalendarService.getCalendarStatus(agent_id, user.id);\n    return CalendarService.createResponse(result);\n  } catch (error) {\n    console.error('Error checking agent calendar status:', error);\n    return CalendarService.createResponse({\n      success: false,\n      error: error instanceof Error ? error.message : 'Failed to check calendar status'\n    }, 500);\n  }\n}","/Users/rennychan/Personal Apps/contax/app/api/agents/default/route.ts",["486","487"],[],"/Users/rennychan/Personal Apps/contax/app/api/agents/route.ts",["488","489","490","491","492","493","494","495"],[],"/Users/rennychan/Personal Apps/contax/app/api/appointments/book/route.ts",[],[],"/Users/rennychan/Personal Apps/contax/app/api/calendar/check-availability/route.ts",[],[],"/Users/rennychan/Personal Apps/contax/app/api/calendar/list/route.ts",[],[],"/Users/rennychan/Personal Apps/contax/app/api/calendar/oauth/agent-callback/route.ts",["496","497","498","499"],[],"import { NextRequest, NextResponse } from 'next/server';\nimport { cookies } from 'next/headers';\nimport { createServerClient } from '@supabase/ssr';\nimport { storeAgentCalendarTokens, validateAgentAccess, storeAgentCalendars } from '@/lib/services/agent-calendar';\nimport { listCalendars } from '@/lib/services/google';\n\nconst GOOGLE_TOKEN_URL = 'https://oauth2.googleapis.com/token';\n\nexport async function GET(req: NextRequest) {\n  try {\n    const code = req.nextUrl.searchParams.get('code');\n    const state = req.nextUrl.searchParams.get('state');\n    const error = req.nextUrl.searchParams.get('error');\n    \n    // Handle OAuth errors\n    if (error) {\n      const errorUrl = new URL('/settings', req.nextUrl.origin);\n      errorUrl.searchParams.set('error', `OAuth error: ${error}`);\n      return NextResponse.redirect(errorUrl.toString());\n    }\n    \n    if (!code || !state) {\n      const errorUrl = new URL('/settings', req.nextUrl.origin);\n      errorUrl.searchParams.set('error', 'Missing authorization code or state');\n      return NextResponse.redirect(errorUrl.toString());\n    }\n    \n    // Decode state to get agent_id and redirect URL\n    let stateData: { agent_id: string; redirect_url: string };\n    try {\n      stateData = JSON.parse(Buffer.from(state, 'base64').toString());\n    } catch {\n      const errorUrl = new URL('/settings', req.nextUrl.origin);\n      errorUrl.searchParams.set('error', 'Invalid state parameter');\n      return NextResponse.redirect(errorUrl.toString());\n    }\n    \n    // Authenticate user\n    const cookieStore = await cookies();\n    const supabase = createServerClient(\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\n      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n      {\n        cookies: {\n          getAll() {\n            return cookieStore.getAll();\n          },\n          setAll(cookiesToSet) {\n            try {\n              cookiesToSet.forEach(({ name, value, options }) => {\n                cookieStore.set(name, value, options);\n              });\n            } catch (error) {\n              console.error('Error setting cookies:', error);\n            }\n          },\n        },\n      }\n    );\n    const { data: { user } } = await supabase.auth.getUser();\n    \n    if (!user) {\n      const errorUrl = new URL('/auth/sign-in', req.nextUrl.origin);\n      errorUrl.searchParams.set('redirect', req.url);\n      return NextResponse.redirect(errorUrl.toString());\n    }\n    \n    // Validate agent access using agent_id from state\n    const agentAccess = await validateAgentAccess(stateData.agent_id, user.id);\n    if (!agentAccess) {\n      const errorUrl = new URL('/settings', req.nextUrl.origin);\n      errorUrl.searchParams.set('error', 'Agent not found or access denied');\n      return NextResponse.redirect(errorUrl.toString());\n    }\n    \n    const clientId = process.env.GOOGLE_CLIENT_ID;\n    const clientSecret = process.env.GOOGLE_CLIENT_SECRET;\n    const baseUrl = process.env.NEXT_PUBLIC_SITE_URL || req.nextUrl.origin;\n    \n    if (!clientId || !clientSecret) {\n      const errorUrl = new URL('/settings', req.nextUrl.origin);\n      errorUrl.searchParams.set('error', 'Google Calendar integration not configured');\n      return NextResponse.redirect(errorUrl.toString());\n    }\n    \n    // Exchange code for tokens\n    const tokenResponse = await fetch(GOOGLE_TOKEN_URL, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n      },\n      body: new URLSearchParams({\n        code,\n        client_id: clientId,\n        client_secret: clientSecret,\n        redirect_uri: `${baseUrl}/api/calendar/oauth/agent-callback`,\n        grant_type: 'authorization_code',\n      }),\n    });\n    \n    if (!tokenResponse.ok) {\n      const errorData = await tokenResponse.text();\n      console.error('Token exchange failed:', errorData);\n      const errorUrl = new URL(stateData.redirect_url, req.nextUrl.origin);\n      errorUrl.searchParams.set('error', 'Failed to exchange authorization code');\n      return NextResponse.redirect(errorUrl.toString());\n    }\n    \n    const tokenData = await tokenResponse.json();\n    \n    // Get user info from Google\n    const userInfoResponse = await fetch('https://www.googleapis.com/oauth2/v2/userinfo', {\n      headers: {\n        Authorization: `Bearer ${tokenData.access_token}`,\n      },\n    });\n    \n    let userEmail = null;\n    let primaryCalendarId = null;\n    \n    if (userInfoResponse.ok) {\n      const userInfo = await userInfoResponse.json();\n      userEmail = userInfo.email;\n      primaryCalendarId = userInfo.email; // Primary calendar is usually the email\n    }\n    \n    // Store tokens in database for the agent\n    const stored = await storeAgentCalendarTokens(\n      stateData.agent_id,\n      tokenData.access_token,\n      tokenData.refresh_token,\n      tokenData.expires_in,\n      userEmail,\n      primaryCalendarId\n    );\n    \n    if (!stored) {\n      const errorUrl = new URL(stateData.redirect_url, req.nextUrl.origin);\n      errorUrl.searchParams.set('error', 'Failed to store calendar tokens');\n      return NextResponse.redirect(errorUrl.toString());\n    }\n    \n    // Fetch and store calendar list\n    try {\n      const calendars = await listCalendars(tokenData.access_token);\n      if (calendars && calendars.length > 0) {\n        await storeAgentCalendars(stateData.agent_id, calendars);\n      }\n    } catch (error) {\n      console.error('Failed to fetch calendar list:', error);\n    }\n    \n    // Redirect to settings with success message\n    const successUrl = new URL(stateData.redirect_url, req.nextUrl.origin);\n    successUrl.searchParams.set('success', 'Calendar connected successfully');\n    successUrl.searchParams.set('agent_id', stateData.agent_id);\n    return NextResponse.redirect(successUrl.toString());\n  } catch (error) {\n    console.error('OAuth callback error:', error);\n    const errorUrl = new URL('/settings', req.nextUrl.origin);\n    errorUrl.searchParams.set('error', error instanceof Error ? error.message : 'OAuth callback failed');\n    return NextResponse.redirect(errorUrl.toString());\n  }\n}","/Users/rennychan/Personal Apps/contax/app/api/calendar/slots/route.ts",[],[],"/Users/rennychan/Personal Apps/contax/app/api/calendar/status/route.ts",[],[],"/Users/rennychan/Personal Apps/contax/app/api/calendar/token/route.ts",[],[],"/Users/rennychan/Personal Apps/contax/app/api/google/oauth/callback/route.ts",[],[],"/Users/rennychan/Personal Apps/contax/app/api/google/oauth/start/route.ts",[],[],"/Users/rennychan/Personal Apps/contax/app/api/onboarding/route.ts",["500","501","502","503"],[],"import { NextRequest, NextResponse } from 'next/server';\nimport { cookies } from 'next/headers';\nimport { createServerClient } from '@supabase/ssr';\n\nexport async function POST(request: NextRequest) {\n  const { organizationName } = await request.json();\n  \n  if (!organizationName?.trim()) {\n    return NextResponse.json({ error: 'Organization name is required' }, { status: 400 });\n  }\n\n  const cookieStore = await cookies();\n  const supabase = createServerClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.SUPABASE_SERVICE_ROLE_KEY!,\n    {\n      cookies: {\n        getAll() {\n          return cookieStore.getAll();\n        },\n        setAll(cookiesToSet) {\n          try {\n            cookiesToSet.forEach(({ name, value, options }) => {\n              cookieStore.set(name, value, options);\n            });\n          } catch (error) {\n            console.error('Error setting cookies:', error);\n          }\n        },\n      },\n    }\n  );\n\n  // Get authenticated user\n  const { data: { user } } = await supabase.auth.getUser();\n  \n  if (!user) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n  }\n\n  try {\n    // Check if user already has an organization\n    const { data: existingMembership } = await supabase\n      .from('organization_members')\n      .select('organization_id')\n      .eq('user_id', user.id)\n      .single();\n\n    if (existingMembership) {\n      return NextResponse.json({ success: true, message: 'Organization already exists' });\n    }\n\n    // Create organization\n    const { data: org, error: orgError } = await supabase\n      .from('organizations')\n      .insert({\n        name: organizationName.trim(),\n        timezone: 'America/New_York',\n        business_hours: {\n          monday: { start: '09:00', end: '17:00', enabled: true },\n          tuesday: { start: '09:00', end: '17:00', enabled: true },\n          wednesday: { start: '09:00', end: '17:00', enabled: true },\n          thursday: { start: '09:00', end: '17:00', enabled: true },\n          friday: { start: '09:00', end: '17:00', enabled: true },\n          saturday: { start: '09:00', end: '17:00', enabled: false },\n          sunday: { start: '09:00', end: '17:00', enabled: false }\n        },\n        settings: {\n          allowBooking: true,\n          bufferTime: 15,\n          maxAdvanceBooking: 30\n        }\n      })\n      .select()\n      .single();\n\n    if (orgError) {\n      console.error('Error creating organization:', orgError);\n      return NextResponse.json({ error: `Failed to create organization: ${orgError.message}` }, { status: 500 });\n    }\n\n    // Add user as owner\n    const { error: memberError } = await supabase\n      .from('organization_members')\n      .insert({\n        organization_id: org.id,\n        user_id: user.id,\n        role: 'owner'\n      });\n\n    if (memberError) {\n      console.error('Error adding user to organization:', memberError);\n      return NextResponse.json({ error: `Failed to add user to organization: ${memberError.message}` }, { status: 500 });\n    }\n\n    // Mark user as onboarded\n    await supabase\n      .from('users')\n      .update({ onboarded: true })\n      .eq('id', user.id);\n\n    return NextResponse.json({ success: true, organization: org });\n  } catch (error) {\n    console.error('Onboarding error:', error);\n    return NextResponse.json({ error: 'An unexpected error occurred' }, { status: 500 });\n  }\n}","/Users/rennychan/Personal Apps/contax/app/api/org/default/route.ts",["504","505"],[],"import { NextRequest, NextResponse } from 'next/server'\nimport { cookies } from 'next/headers'\nimport { createServerClient } from '@supabase/ssr'\n\nexport async function GET(_req: NextRequest) {\n  const cookieStore = await cookies()\n  const supabase = createServerClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.SUPABASE_SERVICE_ROLE_KEY!,\n    {\n      cookies: {\n        getAll() {\n          return cookieStore.getAll()\n        },\n        setAll(cookiesToSet) {\n          try {\n            cookiesToSet.forEach(({ name, value, options }) => {\n              cookieStore.set(name, value, options)\n            })\n          } catch (error) {\n            console.error('Error setting cookies:', error)\n          }\n        },\n      },\n    }\n  )\n\n  // Get authenticated user\n  const { data: { user } } = await supabase.auth.getUser()\n  \n  if (!user) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  }\n\n  try {\n    // Get user's default organization through the membership table\n    const { data: membership, error: memberError } = await supabase\n      .from('organization_members')\n      .select('organization_id, organizations(id, name)')\n      .eq('user_id', user.id)\n      .order('created_at', { ascending: true })\n      .limit(1)\n      .single()\n\n    if (memberError || !membership) {\n      // If no organization exists, this shouldn't happen after migration\n      // but we'll handle it gracefully\n      return NextResponse.json({ \n        error: 'No organization found for user. Please contact support.' \n      }, { status: 404 })\n    }\n\n    // Return the organization\n    return NextResponse.json({ \n      organization: membership.organizations \n    }, {\n      status: 200,\n      headers: { 'Content-Type': 'application/json' }\n    })\n  } catch (error) {\n    console.error('Error fetching user organization:', error)\n    return NextResponse.json({ \n      error: 'Failed to fetch organization' \n    }, { status: 500 })\n  }\n}\n\n","/Users/rennychan/Personal Apps/contax/app/api/realtime/token/route.ts",[],[],"/Users/rennychan/Personal Apps/contax/app/api/settings/twilio/route.ts",["506","507","508"],[],"/Users/rennychan/Personal Apps/contax/app/api/settings/webhook/route.ts",["509","510","511","512","513","514","515"],[],"/Users/rennychan/Personal Apps/contax/app/api/test-env/route.ts",[],[],"/Users/rennychan/Personal Apps/contax/app/api/webhook/[userId]/[token]/route.ts",[],[],"/Users/rennychan/Personal Apps/contax/app/api/webhook/agent/[token]/trigger/route.ts",["516","517","518"],[],"import { NextRequest, NextResponse } from 'next/server';\nimport { createClient } from '@supabase/supabase-js';\nimport twilio from 'twilio';\n\nexport async function POST(\n  req: NextRequest,\n  { params }: { params: Promise<{ token: string }> }\n) {\n  try {\n    const { token } = await params;\n    \n    if (!token) {\n      return NextResponse.json({ error: 'Token is required' }, { status: 400 });\n    }\n\n    // Parse request body\n    const body = await req.json();\n    const { phoneNumber, phone_number, phone, to } = body;\n    \n    // Try different possible field names for phone number\n    const targetPhone = phoneNumber || phone_number || phone || to;\n    \n    if (!targetPhone) {\n      return NextResponse.json({ \n        error: 'Phone number is required. Use phoneNumber, phone_number, phone, or to field' \n      }, { status: 400 });\n    }\n\n    // Initialize Supabase client with service role\n    const supabase = createClient(\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\n      process.env.SUPABASE_SERVICE_ROLE_KEY!\n    );\n\n    // Find agent configuration by webhook token\n    const { data: agent, error: agentError } = await supabase\n      .from('agent_configurations')\n      .select('*, organization_id')\n      .eq('webhook_token', token)\n      .eq('webhook_enabled', true)\n      .single();\n\n    if (agentError || !agent) {\n      console.error('Agent not found or webhook disabled:', agentError);\n      return NextResponse.json({ \n        error: 'Invalid webhook token or webhook disabled' \n      }, { status: 404 });\n    }\n\n    // Get organization's Twilio settings\n    const { data: twilioSettings, error: twilioError } = await supabase\n      .from('twilio_settings')\n      .select('*')\n      .eq('organization_id', agent.organization_id)\n      .single();\n\n    if (twilioError || !twilioSettings) {\n      console.error('Twilio settings not found:', twilioError);\n      return NextResponse.json({ \n        error: 'Twilio not configured for this organization' \n      }, { status: 400 });\n    }\n\n    // Initialize Twilio client\n    const twilioClient = twilio(\n      twilioSettings.account_sid,\n      twilioSettings.auth_token\n    );\n\n    // Create TwiML response for the call\n    const twimlUrl = `${process.env.NEXT_PUBLIC_APP_URL || 'https://localhost:3000'}/api/webhook/agent/${token}/twiml`;\n\n    // Initiate the call\n    const call = await twilioClient.calls.create({\n      to: targetPhone,\n      from: twilioSettings.phone_number,\n      url: twimlUrl,\n      method: 'POST',\n      record: false,\n      statusCallback: `${process.env.NEXT_PUBLIC_APP_URL || 'https://localhost:3000'}/api/webhook/call-status`,\n      statusCallbackMethod: 'POST',\n      statusCallbackEvent: ['initiated', 'ringing', 'answered', 'completed']\n    });\n\n    // Log the call\n    await supabase\n      .from('call_logs')\n      .insert({\n        organization_id: agent.organization_id,\n        agent_id: agent.id,\n        call_sid: call.sid,\n        to_number: targetPhone,\n        from_number: twilioSettings.phone_number,\n        status: 'initiated',\n        direction: 'outbound',\n        webhook_triggered: true,\n        metadata: {\n          triggered_by: 'webhook',\n          token: token,\n          request_body: body\n        }\n      });\n\n    return NextResponse.json({\n      success: true,\n      message: 'Call initiated successfully',\n      callSid: call.sid,\n      to: targetPhone,\n      from: twilioSettings.phone_number,\n      status: call.status\n    });\n\n  } catch (error) {\n    console.error('Error triggering call via webhook:', error);\n    return NextResponse.json({ \n      error: 'Failed to trigger call',\n      details: error instanceof Error ? error.message : 'Unknown error'\n    }, { status: 500 });\n  }\n}\n\n// GET endpoint to show webhook info\nexport async function GET(\n  req: NextRequest,\n  { params }: { params: Promise<{ token: string }> }\n) {\n  const { token } = await params;\n  \n  return NextResponse.json({\n    message: 'Agent webhook endpoint',\n    token: token,\n    usage: {\n      method: 'POST',\n      body: {\n        phoneNumber: '+1234567890',\n        description: 'Phone number to call (with country code)'\n      },\n      alternativeFields: [\n        'phone_number',\n        'phone',\n        'to'\n      ]\n    }\n  });\n}","/Users/rennychan/Personal Apps/contax/app/api/webhook/agent/[token]/twiml/route.ts",["519","520"],[],"import { NextRequest, NextResponse } from 'next/server';\nimport { createClient } from '@supabase/supabase-js';\nimport twilio from 'twilio';\n\nexport async function POST(\n  req: NextRequest,\n  { params }: { params: Promise<{ token: string }> }\n) {\n  try {\n    const { token } = await params;\n    const VoiceResponse = twilio.twiml.VoiceResponse;\n    const response = new VoiceResponse();\n\n    // Initialize Supabase client\n    const supabase = createClient(\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\n      process.env.SUPABASE_SERVICE_ROLE_KEY!\n    );\n\n    // Find agent configuration by webhook token\n    const { data: agent, error: agentError } = await supabase\n      .from('agent_configurations')\n      .select('*')\n      .eq('webhook_token', token)\n      .single();\n\n    if (agentError || !agent) {\n      response.say('Sorry, this agent is not available. Goodbye.');\n      response.hangup();\n      return new NextResponse(response.toString(), {\n        headers: { 'Content-Type': 'text/xml' }\n      });\n    }\n\n    // Use the agent's greeting\n    const greeting = agent.greeting || 'Hello! How can I help you today?';\n    \n    // Connect to the agent (similar to existing webhook logic)\n    response.say({\n      voice: 'alice',\n      language: agent.language || 'en-US'\n    }, greeting);\n\n    // Add gather to capture user input\n    const gather = response.gather({\n      input: ['speech'],\n      timeout: 5,\n      language: agent.language || 'en-US',\n      speechTimeout: 'auto',\n      action: `/api/webhook/agent/${token}/process`,\n      method: 'POST'\n    });\n\n    // If no input, hang up\n    response.say('I didn\\'t hear anything. Goodbye.');\n    response.hangup();\n\n    return new NextResponse(response.toString(), {\n      headers: { 'Content-Type': 'text/xml' }\n    });\n\n  } catch (error) {\n    console.error('Error generating TwiML:', error);\n    \n    const VoiceResponse = twilio.twiml.VoiceResponse;\n    const response = new VoiceResponse();\n    response.say('An error occurred. Please try again later.');\n    response.hangup();\n    \n    return new NextResponse(response.toString(), {\n      headers: { 'Content-Type': 'text/xml' }\n    });\n  }\n}","/Users/rennychan/Personal Apps/contax/app/api/webhook/call-status/route.ts",["521","522","523","524","525","526","527"],[],"import { NextRequest, NextResponse } from 'next/server';\nimport { createServerClient } from '@supabase/ssr';\nimport { cookies } from 'next/headers';\n\nexport async function POST(req: NextRequest) {\n  try {\n    const formData = await req.formData();\n    \n    // Extract Twilio call status data\n    const callSid = formData.get('CallSid') as string;\n    const callStatus = formData.get('CallStatus') as string;\n    const from = formData.get('From') as string;\n    const to = formData.get('To') as string;\n    const direction = formData.get('Direction') as string;\n    const duration = formData.get('CallDuration') as string;\n    const timestamp = formData.get('Timestamp') as string;\n\n    // Initialize Supabase client\n    const cookieStore = await cookies();\n    const supabase = createServerClient(\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\n      process.env.SUPABASE_SERVICE_ROLE_KEY!,\n      {\n        cookies: {\n          getAll() {\n            return cookieStore.getAll();\n          },\n          setAll(cookiesToSet) {\n            try {\n              cookiesToSet.forEach(({ name, value, options }) => {\n                cookieStore.set(name, value, options);\n              });\n            } catch (error) {\n              // Handle error\n            }\n          },\n        },\n      }\n    );\n\n    // Update call log in database\n    const { error } = await supabase\n      .from('call_logs')\n      .update({\n        status: callStatus,\n        duration: duration ? parseInt(duration) : null,\n        updated_at: new Date().toISOString(),\n      })\n      .eq('call_sid', callSid);\n\n    if (error) {\n      console.error('Error updating call status:', error);\n      // Don't return error to Twilio, just log it\n    }\n\n    // Log the status change for debugging\n    console.log(`Call ${callSid} status changed to: ${callStatus}`);\n\n    // Return success response to Twilio\n    return new NextResponse('', { status: 200 });\n  } catch (error) {\n    console.error('Error processing call status webhook:', error);\n    // Return 200 to prevent Twilio from retrying\n    return new NextResponse('', { status: 200 });\n  }\n}","/Users/rennychan/Personal Apps/contax/app/api/webhook/org/[token]/trigger-call/route.ts",["528","529","530","531","532","533"],[],"/**\n * Secure webhook endpoint for triggering calls\n * Each organization has a unique webhook URL with token-based identification\n * \n * Security features:\n * - Token-based organization identification\n * - Secret key validation\n * - Rate limiting per organization\n * - Audit logging\n * - Auto-disable after failures\n */\n\nimport { NextRequest, NextResponse } from 'next/server'\nimport { createClient } from '@supabase/supabase-js'\nimport { validateWebhookRequest } from '@/lib/security/webhook'\nimport { z } from 'zod'\n\n// Input validation schema\nconst TriggerCallSchema = z.object({\n  phoneNumber: z.string()\n    .regex(/^\\+[1-9]\\d{1,14}$/, 'Invalid phone number format. Must be E.164 format (e.g., +1234567890)')\n    .max(15, 'Phone number too long'),\n  \n  customerName: z.string()\n    .min(1, 'Customer name is required')\n    .max(100, 'Customer name too long')\n    .optional(),\n  \n  context: z.string()\n    .max(1000, 'Context too long')\n    .optional(),\n  \n  // Optional: For backward compatibility, but ignored for security\n  organizationId: z.string().uuid().optional(),\n  \n  // Optional: Alternative way to provide webhook secret (not recommended)\n  webhook_secret: z.string().optional()\n})\n\nexport async function POST(\n  req: NextRequest,\n  { params }: { params: Promise<{ token: string }> }\n) {\n  const startTime = Date.now()\n  \n  try {\n    // Parse and validate request body\n    let body: any\n    try {\n      body = await req.json()\n    } catch (parseError) {\n      return NextResponse.json(\n        { error: 'Invalid JSON payload' },\n        { status: 400 }\n      )\n    }\n    \n    // Validate input data\n    const validation = TriggerCallSchema.safeParse(body)\n    if (!validation.success) {\n      return NextResponse.json(\n        { \n          error: 'Validation failed',\n          details: validation.error.issues.map(e => ({\n            field: e.path.join('.'),\n            message: e.message\n          }))\n        },\n        { status: 400 }\n      )\n    }\n    \n    const validatedData = validation.data\n    \n    // Extract webhook token from URL  \n    const webhookToken = (await params).token\n    \n    // Validate webhook request (handles auth, rate limiting, logging)\n    const validationResult = await validateWebhookRequest(\n      webhookToken,\n      req,\n      body\n    )\n    \n    if (!validationResult.valid) {\n      // Return appropriate error status based on error type\n      let status = 401 // Default to unauthorized\n      if (validationResult.error?.includes('Rate limit')) {\n        status = 429\n      } else if (validationResult.error?.includes('disabled')) {\n        status = 403\n      } else if (validationResult.error?.includes('Invalid webhook token format')) {\n        status = 400\n      }\n      \n      return NextResponse.json(\n        { error: validationResult.error || 'Webhook validation failed' },\n        { status }\n      )\n    }\n    \n    const organizationId = validationResult.organizationId!\n    \n    // Initialize Supabase client\n    const supabase = createClient(\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\n      process.env.SUPABASE_SERVICE_ROLE_KEY!,\n      { auth: { persistSession: false } }\n    )\n    \n    // Get organization details for processing the call\n    const { data: org, error: orgError } = await supabase\n      .from('organizations')\n      .select('*, organization_settings(*)')\n      .eq('id', organizationId)\n      .single()\n    \n    if (orgError || !org) {\n      return NextResponse.json(\n        { error: 'Organization not found' },\n        { status: 404 }\n      )\n    }\n    \n    // Check if organization has Twilio configured\n    const twilioPhone = org.settings?.twilio_phone_number\n    const twilioSid = org.settings?.twilio_account_sid\n    const twilioToken = org.settings?.twilio_auth_token_encrypted // This should be decrypted when used\n    \n    if (!twilioPhone || !twilioSid || !twilioToken) {\n      return NextResponse.json(\n        { error: 'Twilio not configured for this organization' },\n        { status: 503 }\n      )\n    }\n    \n    // Get agent configuration\n    const agentPrompt = org.settings?.agent_prompt || 'You are a helpful scheduling assistant.'\n    const voiceConfig = org.settings?.voice_config || { voice: 'alloy', model: 'gpt-4o-realtime-preview' }\n    \n    // Create call record\n    const { data: call, error: callError } = await supabase\n      .from('calls')\n      .insert({\n        organization_id: organizationId,\n        caller_phone: validatedData.phoneNumber,\n        status: 'initiated',\n        metadata: {\n          triggered_via: 'webhook',\n          customer_name: validatedData.customerName,\n          context: validatedData.context,\n          webhook_token: webhookToken.substring(0, 8) + '...', // Log partial token for debugging\n        }\n      })\n      .select()\n      .single()\n    \n    if (callError || !call) {\n      console.error('Failed to create call record:', callError)\n      return NextResponse.json(\n        { error: 'Failed to initiate call' },\n        { status: 500 }\n      )\n    }\n    \n    // TODO: Integrate with actual call triggering service (Twilio, etc.)\n    // For now, we'll just simulate the call being triggered\n    \n    // In production, you would:\n    // 1. Decrypt the Twilio auth token\n    // 2. Use Twilio SDK to initiate the call\n    // 3. Pass the agent configuration and context\n    // 4. Update the call record with Twilio call SID\n    \n    // Simulated response for now\n    const response = {\n      success: true,\n      message: 'Call initiated successfully',\n      callId: call.id,\n      organizationId: organizationId,\n      phoneNumber: validatedData.phoneNumber,\n      processingTime: Date.now() - startTime\n    }\n    \n    // Update call status to 'connecting'\n    await supabase\n      .from('calls')\n      .update({ status: 'connecting' })\n      .eq('id', call.id)\n    \n    return NextResponse.json(response, { status: 200 })\n    \n  } catch (error) {\n    console.error('Webhook processing error:', error)\n    \n    // Don't leak internal errors in production\n    if (process.env.NODE_ENV === 'production') {\n      return NextResponse.json(\n        { error: 'Internal server error' },\n        { status: 500 }\n      )\n    } else {\n      return NextResponse.json(\n        { \n          error: 'Internal server error',\n          details: error instanceof Error ? error.message : 'Unknown error'\n        },\n        { status: 500 }\n      )\n    }\n  }\n}\n\n// OPTIONS request for CORS preflight\nexport async function OPTIONS(req: NextRequest) {\n  return new NextResponse(null, {\n    status: 200,\n    headers: {\n      'Access-Control-Allow-Origin': '*',\n      'Access-Control-Allow-Methods': 'POST, OPTIONS',\n      'Access-Control-Allow-Headers': 'Content-Type, X-Webhook-Secret, Authorization',\n      'Access-Control-Max-Age': '86400',\n    },\n  })\n}","/Users/rennychan/Personal Apps/contax/app/api/webhook/outgoing-call/route.ts",["534","535"],[],"import { NextRequest, NextResponse } from 'next/server';\nimport { cookies } from 'next/headers';\nimport { createServerClient } from '@supabase/ssr';\nimport { TwilioTelephonyAdapter } from '../../../../lib/telephony/twilio';\n\nexport async function POST(req: NextRequest) {\n  try {\n    const body = await req.json();\n    const { phoneNumber, organizationId, userId, agentId } = body;\n\n    if (!phoneNumber) {\n      return NextResponse.json({ error: 'Phone number is required' }, { status: 400 });\n    }\n\n    // Initialize Supabase client\n    const cookieStore = await cookies();\n    const supabase = createServerClient(\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\n      process.env.SUPABASE_SERVICE_ROLE_KEY!,\n      {\n        cookies: {\n          getAll() {\n            return cookieStore.getAll();\n          },\n          setAll(cookiesToSet) {\n            try {\n              cookiesToSet.forEach(({ name, value, options }) => {\n                cookieStore.set(name, value, options);\n              });\n            } catch (error) {\n              // Handle error\n            }\n          },\n        },\n      }\n    );\n\n    // Get organization ID if not provided\n    let orgId = organizationId;\n    if (!orgId && userId) {\n      const { data: member } = await supabase\n        .from('organization_members')\n        .select('organization_id')\n        .eq('user_id', userId)\n        .single();\n      \n      if (member) {\n        orgId = member.organization_id;\n      }\n    }\n\n    if (!orgId) {\n      return NextResponse.json({ error: 'Organization ID is required' }, { status: 400 });\n    }\n\n    // Get Twilio settings for the organization\n    const { data: twilioSettings, error: settingsError } = await supabase\n      .from('twilio_settings')\n      .select('account_sid, auth_token, phone_number')\n      .eq('organization_id', orgId)\n      .single();\n\n    if (settingsError || !twilioSettings) {\n      return NextResponse.json({ error: 'Twilio settings not found for organization' }, { status: 404 });\n    }\n\n    // Initialize Twilio adapter\n    const twilioAdapter = new TwilioTelephonyAdapter({\n      accountSid: twilioSettings.account_sid,\n      authToken: twilioSettings.auth_token,\n      phoneNumber: twilioSettings.phone_number,\n    });\n\n    // Get the base URL for callbacks\n    const baseUrl = process.env.NEXT_PUBLIC_APP_URL || `https://${req.headers.get('host')}`;\n\n    // Create the outgoing call using the adapter\n    await twilioAdapter.startOutboundCall(phoneNumber, {\n      baseUrl,\n      organizationId: orgId,\n      agentId: agentId || 'default',\n    });\n    \n    // Get the call SID from the adapter\n    const callSid = twilioAdapter.getCurrentCallSid();\n\n    if (!callSid) {\n      throw new Error('Failed to get call SID');\n    }\n\n    // Log the call in the database\n    await supabase\n      .from('call_logs')\n      .insert({\n        organization_id: orgId,\n        call_sid: callSid,\n        from_number: twilioSettings.phone_number,\n        to_number: phoneNumber,\n        direction: 'outbound',\n        status: 'initiated',\n        created_at: new Date().toISOString(),\n      });\n\n    return NextResponse.json({\n      success: true,\n      callSid: callSid,\n      status: 'initiated',\n      to: phoneNumber,\n      from: twilioSettings.phone_number,\n    });\n  } catch (error: any) {\n    console.error('Error creating outgoing call:', error);\n    \n    // Handle Twilio-specific errors\n    if (error.code) {\n      return NextResponse.json({\n        error: `Twilio error: ${error.message}`,\n        code: error.code,\n      }, { status: 400 });\n    }\n    \n    return NextResponse.json({\n      error: 'Failed to create outgoing call',\n      details: error.message,\n    }, { status: 500 });\n  }\n}","/Users/rennychan/Personal Apps/contax/app/api/webhook/trigger-call/route.ts",["536","537","538","539","540","541","542","543","544","545"],[],"import { NextRequest, NextResponse } from 'next/server';\nimport { createClient } from '@supabase/supabase-js';\nimport { TwilioTelephonyAdapter } from '../../../../lib/telephony/twilio';\nimport { validateWebhookFromRequest } from '../../../../lib/security/webhook-auth';\nimport { rateLimitMiddleware, RateLimitPresets } from '../../../../lib/security/rate-limiter';\n\n// Universal webhook endpoint that accepts calls from any system (Make, HubSpot, Zapier, etc.)\n// Intelligently extracts phone numbers and organization IDs from various field names\n// Helper function to extract phone number from various possible field names\nfunction extractPhoneNumber(body: any): string | null {\n  // Common field names used by different systems\n  const phoneFields = [\n    'phoneNumber', 'phone_number', 'phone', 'Phone', 'PhoneNumber',\n    'mobile', 'Mobile', 'mobileNumber', 'mobile_number',\n    'telephone', 'Telephone', 'tel', 'Tel',\n    'contact', 'Contact', 'contactNumber', 'contact_number',\n    'number', 'Number', 'to', 'To', 'recipient',\n    'customer_phone', 'customerPhone', 'client_phone', 'clientPhone',\n    // HubSpot specific\n    'hs_phone', 'phone_number_1', 'mobilephone',\n    // Salesforce specific\n    'Phone__c', 'MobilePhone__c',\n    // Generic nested structures\n    'data.phone', 'data.phoneNumber', 'contact.phone', 'customer.phone'\n  ];\n\n  for (const field of phoneFields) {\n    // Check direct field\n    if (body[field]) return body[field];\n    \n    // Check nested fields (e.g., data.phone)\n    if (field.includes('.')) {\n      const parts = field.split('.');\n      let value = body;\n      for (const part of parts) {\n        value = value?.[part];\n        if (!value) break;\n      }\n      if (value) return value;\n    }\n  }\n  \n  // Check if body.data exists and search within it\n  if (body.data && typeof body.data === 'object') {\n    return extractPhoneNumber(body.data);\n  }\n  \n  // Check if body.contact exists and search within it\n  if (body.contact && typeof body.contact === 'object') {\n    return extractPhoneNumber(body.contact);\n  }\n  \n  return null;\n}\n\n// Helper function to extract organization ID from various possible field names\nfunction extractOrganizationId(body: any): string | null {\n  const orgFields = [\n    'organizationId', 'organization_id', 'orgId', 'org_id',\n    'organisationId', 'organisation_id', 'OrganizationId',\n    'companyId', 'company_id', 'accountId', 'account_id',\n    'tenantId', 'tenant_id', 'customerId', 'customer_id',\n    // HubSpot specific\n    'hs_company_id', 'companyid', 'associatedcompanyid',\n    // Salesforce specific\n    'AccountId', 'Account__c',\n    // Generic nested structures\n    'data.organizationId', 'data.orgId', 'company.id', 'organization.id'\n  ];\n\n  for (const field of orgFields) {\n    // Check direct field\n    if (body[field]) return body[field];\n    \n    // Check nested fields\n    if (field.includes('.')) {\n      const parts = field.split('.');\n      let value = body;\n      for (const part of parts) {\n        value = value?.[part];\n        if (!value) break;\n      }\n      if (value) return value;\n    }\n  }\n  \n  // Check nested objects\n  if (body.data && typeof body.data === 'object') {\n    const nested = extractOrganizationId(body.data);\n    if (nested) return nested;\n  }\n  \n  if (body.organization && typeof body.organization === 'object') {\n    if (body.organization.id) return body.organization.id;\n    const nested = extractOrganizationId(body.organization);\n    if (nested) return nested;\n  }\n  \n  if (body.company && typeof body.company === 'object') {\n    if (body.company.id) return body.company.id;\n    const nested = extractOrganizationId(body.company);\n    if (nested) return nested;\n  }\n  \n  return null;\n}\n\nexport async function POST(req: NextRequest) {\n  try {\n    // Apply rate limiting to prevent abuse\n    const rateLimitResponse = rateLimitMiddleware(req, RateLimitPresets.webhook);\n    if (rateLimitResponse) {\n      return rateLimitResponse;\n    }\n\n    // Get the raw body for signature validation\n    const rawBody = await req.text();\n\n    // Validate webhook signature if webhook secret is configured\n    const webhookSecret = process.env.WEBHOOK_SECRET;\n    if (webhookSecret) {\n      const validation = validateWebhookFromRequest(req, rawBody, {\n        secret: webhookSecret,\n        maxAge: 300, // 5 minutes\n        signatureHeader: 'x-signature',\n        timestampHeader: 'x-timestamp'\n      });\n\n      if (!validation.valid) {\n        console.error('Webhook signature validation failed:', validation.error);\n        return NextResponse.json({\n          error: 'Unauthorized',\n          message: 'Invalid webhook signature or timestamp',\n          code: validation.errorCode\n        }, { status: 401 });\n      }\n    } else {\n      console.warn('WEBHOOK_SECRET not configured - webhook signature validation skipped');\n    }\n\n    // Parse the validated request body\n    const body = JSON.parse(rawBody);\n    \n    // Log the incoming webhook for debugging (you can remove this in production)\n    console.log('Incoming webhook payload:', JSON.stringify(body, null, 2));\n    \n    // Try to extract phone number from various possible field names\n    const targetPhone = extractPhoneNumber(body);\n    \n    if (!targetPhone) {\n      return NextResponse.json({ \n        error: 'Phone number not found',\n        message: 'Could not extract phone number from the webhook payload. Please ensure the phone number is included in a recognized field.',\n        hint: 'Common field names: phoneNumber, phone, mobile, telephone, contact, etc.',\n        received: Object.keys(body)\n      }, { status: 400 });\n    }\n    \n    // Try to extract organization ID from various possible field names\n    let orgId = extractOrganizationId(body);\n    \n    // If no organization ID found, try to use a default from environment or headers\n    if (!orgId) {\n      // Check if there's a default org ID in headers (for API key based auth)\n      const apiKey = req.headers.get('x-api-key') || req.headers.get('authorization');\n      if (apiKey) {\n        // You could look up org ID by API key here if you implement that\n        // For now, we'll require the org ID in the payload\n      }\n      \n      // Check for a default organization ID in environment variables\n      orgId = process.env.DEFAULT_ORGANIZATION_ID || null;\n      \n      if (!orgId) {\n        return NextResponse.json({ \n          error: 'Organization ID not found',\n          message: 'Could not extract organization ID from the webhook payload. Please include it in the request.',\n          hint: 'Common field names: organizationId, orgId, companyId, accountId, etc.',\n          received: Object.keys(body)\n        }, { status: 400 });\n      }\n    }\n\n    // Initialize Supabase client with service role key\n    const supabase = createClient(\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\n      process.env.SUPABASE_SERVICE_ROLE_KEY!\n    );\n\n    // Get agent settings to check if phone calls are enabled\n    const { data: agentSettings, error: agentError } = await supabase\n      .from('agent_settings')\n      .select('phone_call_enabled, greeting, display_name')\n      .eq('organization_id', orgId)\n      .eq('name', 'default')\n      .single();\n\n    if (agentError) {\n      console.error('Error fetching agent settings:', agentError);\n      return NextResponse.json({ \n        error: 'Failed to fetch agent settings',\n        details: agentError.message \n      }, { status: 500 });\n    }\n\n    // Check if phone calls are enabled\n    if (!agentSettings || agentSettings.phone_call_enabled === false) {\n      return NextResponse.json({ \n        error: 'Phone calls are disabled for this agent',\n        phone_call_enabled: false,\n        message: 'Please enable phone calls in Agent Settings to make outgoing calls'\n      }, { status: 403 });\n    }\n\n    // Get Twilio settings for the organization\n    const { data: twilioSettings, error: twilioError } = await supabase\n      .from('twilio_settings')\n      .select('account_sid, auth_token, phone_number')\n      .eq('organization_id', orgId)\n      .single();\n\n    if (twilioError || !twilioSettings) {\n      return NextResponse.json({ \n        error: 'Twilio settings not configured',\n        message: 'Please configure Twilio settings in the Settings page'\n      }, { status: 404 });\n    }\n\n    // Validate that all Twilio settings are present\n    if (!twilioSettings.account_sid || !twilioSettings.auth_token || !twilioSettings.phone_number) {\n      return NextResponse.json({ \n        error: 'Incomplete Twilio configuration',\n        message: 'Please ensure Account SID, Auth Token, and Phone Number are all configured'\n      }, { status: 400 });\n    }\n\n    // Initialize Twilio adapter\n    const twilioAdapter = new TwilioTelephonyAdapter({\n      accountSid: twilioSettings.account_sid,\n      authToken: twilioSettings.auth_token,\n      phoneNumber: twilioSettings.phone_number,\n    });\n\n    // Get the base URL for callbacks\n    const baseUrl = process.env.NEXT_PUBLIC_APP_URL || `https://${req.headers.get('host')}`;\n\n    // Create the outgoing call\n    await twilioAdapter.startOutboundCall(targetPhone, {\n      baseUrl,\n      organizationId: orgId,\n      agentId: 'default',\n    });\n    \n    // Get the call SID from the adapter\n    const callSid = twilioAdapter.getCurrentCallSid();\n\n    if (!callSid) {\n      throw new Error('Failed to initiate call - no call SID returned');\n    }\n\n    // Log the call in the database\n    const { error: logError } = await supabase\n      .from('call_logs')\n      .insert({\n        organization_id: orgId,\n        call_sid: callSid,\n        from_number: twilioSettings.phone_number,\n        to_number: targetPhone,\n        direction: 'outbound',\n        status: 'initiated',\n        metadata: {\n          source: req.headers.get('user-agent') || 'webhook',\n          webhook_source: body.source || body.platform || 'unknown',\n          agent_name: agentSettings.display_name || 'AI Assistant',\n          greeting: agentSettings.greeting,\n          original_payload: JSON.stringify(body).substring(0, 500) // Store first 500 chars of payload\n        },\n        created_at: new Date().toISOString(),\n      });\n\n    if (logError) {\n      console.error('Error logging call:', logError);\n      // Don't fail the request if logging fails\n    }\n\n    return NextResponse.json({\n      success: true,\n      message: 'Outgoing call initiated successfully',\n      data: {\n        callSid: callSid,\n        status: 'initiated',\n        to: targetPhone,\n        from: twilioSettings.phone_number,\n        agentName: agentSettings.display_name || 'AI Assistant',\n        greeting: agentSettings.greeting || 'Hello, how can I help you today?'\n      }\n    });\n\n  } catch (error: any) {\n    console.error('Error in Make webhook:', error);\n    \n    // Handle Twilio-specific errors\n    if (error.code) {\n      return NextResponse.json({\n        error: `Twilio error: ${error.message}`,\n        code: error.code,\n        details: error.message\n      }, { status: 400 });\n    }\n    \n    return NextResponse.json({\n      error: 'Failed to process webhook',\n      details: error.message || 'Unknown error occurred'\n    }, { status: 500 });\n  }\n}\n\n// GET method to verify webhook is working and show supported formats\nexport async function GET(req: NextRequest) {\n  return NextResponse.json({\n    status: 'ok',\n    message: 'Universal webhook endpoint is active',\n    description: 'This endpoint accepts webhooks from any system (Make, HubSpot, Zapier, Salesforce, etc.)',\n    supportedPhoneFields: [\n      'phoneNumber', 'phone_number', 'phone', 'mobile', 'telephone',\n      'contact', 'number', 'to', 'recipient', 'customer_phone',\n      'hs_phone (HubSpot)', 'mobilephone (HubSpot)', \n      'Phone__c (Salesforce)', 'MobilePhone__c (Salesforce)',\n      'Nested: data.phone, contact.phone, customer.phone'\n    ],\n    supportedOrgFields: [\n      'organizationId', 'organization_id', 'orgId', 'companyId',\n      'accountId', 'tenantId', 'customerId',\n      'hs_company_id (HubSpot)', 'companyid (HubSpot)',\n      'AccountId (Salesforce)', 'Account__c (Salesforce)',\n      'Nested: data.organizationId, company.id, organization.id'\n    ],\n    examplePayloads: {\n      make: {\n        phoneNumber: '+1234567890',\n        organizationId: 'org-123'\n      },\n      hubspot: {\n        hs_phone: '+1234567890',\n        hs_company_id: 'org-123'\n      },\n      zapier: {\n        phone: '+1234567890',\n        orgId: 'org-123'\n      },\n      generic: {\n        data: {\n          phone: '+1234567890',\n          organizationId: 'org-123'\n        }\n      }\n    },\n    features: {\n      intelligentExtraction: 'Automatically extracts phone and org ID from various field names',\n      phoneCallCheck: 'Verifies if phone calls are enabled in agent settings',\n      twilioIntegration: 'Uses configured Twilio settings to make calls',\n      agentGreeting: 'Uses the configured agent greeting message',\n      multiPlatform: 'Works with Make, HubSpot, Zapier, Salesforce, and custom systems'\n    }\n  });\n}","/Users/rennychan/Personal Apps/contax/app/auth/callback/route.ts",[],[],"/Users/rennychan/Personal Apps/contax/app/auth/layout.tsx",[],[],"/Users/rennychan/Personal Apps/contax/app/auth/sign-in/page.tsx",[],[],"/Users/rennychan/Personal Apps/contax/app/auth/sign-up/page.tsx",["546"],[],"'use client';\n\nimport Link from 'next/link';\nimport { useState } from 'react';\nimport { useRouter } from 'next/navigation';\nimport { createBrowserClient } from '@supabase/ssr';\nimport pathsConfig from '../../../config/paths.config';\n\nexport default function SignUpPage() {\n  const [email, setEmail] = useState('');\n  const [password, setPassword] = useState('');\n  const [confirmPassword, setConfirmPassword] = useState('');\n  const [error, setError] = useState<string | null>(null);\n  const [loading, setLoading] = useState(false);\n  const [success, setSuccess] = useState(false);\n  const router = useRouter();\n\n  const supabase = createBrowserClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n  );\n\n  const handleSignUp = async (e: React.FormEvent) => {\n    e.preventDefault();\n    setError(null);\n\n    if (password !== confirmPassword) {\n      setError('Passwords do not match');\n      return;\n    }\n\n    if (password.length < 6) {\n      setError('Password must be at least 6 characters');\n      return;\n    }\n\n    setLoading(true);\n\n    try {\n      const { data, error } = await supabase.auth.signUp({\n        email,\n        password,\n      });\n\n      if (error) {\n        setError(error.message);\n      } else if (data?.user) {\n        setSuccess(true);\n      }\n    } catch (err) {\n      setError('An unexpected error occurred');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  if (success) {\n    return (\n      <div className=\"text-center\">\n        <div className=\"mb-4\">\n          <div className=\"mx-auto w-12 h-12 bg-primary/10 rounded-full flex items-center justify-center\">\n            <svg className=\"w-6 h-6 text-primary\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M5 13l4 4L19 7\" />\n            </svg>\n          </div>\n        </div>\n        <h3 className=\"text-lg font-semibold text-foreground mb-2\">Check your email</h3>\n        <p className=\"text-sm text-muted-foreground mb-4\">\n          We've sent you a confirmation link to verify your email address.\n        </p>\n        <Link\n          href={pathsConfig.auth.signIn}\n          className=\"text-primary hover:underline text-sm\"\n        >\n          Back to sign in\n        </Link>\n      </div>\n    );\n  }\n\n  return (\n    <>\n      <div className=\"text-center mb-6\">\n        <h2 className=\"text-xl font-semibold text-foreground\">Create an account</h2>\n        <p className=\"text-sm text-muted-foreground mt-1\">Get started with Contax</p>\n      </div>\n\n      <form onSubmit={handleSignUp} className=\"space-y-4\">\n        {error && (\n          <div className=\"bg-destructive/10 border border-destructive/20 text-destructive px-4 py-3 rounded\">\n            {error}\n          </div>\n        )}\n\n        <div>\n          <label htmlFor=\"email\" className=\"block text-sm font-medium text-foreground mb-1\">\n            Email\n          </label>\n          <input\n            id=\"email\"\n            type=\"email\"\n            value={email}\n            onChange={(e) => setEmail(e.target.value)}\n            required\n            className=\"w-full px-3 py-2 border border-input bg-background text-foreground rounded-md focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent\"\n            placeholder=\"you@example.com\"\n          />\n        </div>\n\n        <div>\n          <label htmlFor=\"password\" className=\"block text-sm font-medium text-foreground mb-1\">\n            Password\n          </label>\n          <input\n            id=\"password\"\n            type=\"password\"\n            value={password}\n            onChange={(e) => setPassword(e.target.value)}\n            required\n            className=\"w-full px-3 py-2 border border-input bg-background text-foreground rounded-md focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent\"\n            placeholder=\"\"\n          />\n        </div>\n\n        <div>\n          <label htmlFor=\"confirmPassword\" className=\"block text-sm font-medium text-foreground mb-1\">\n            Confirm Password\n          </label>\n          <input\n            id=\"confirmPassword\"\n            type=\"password\"\n            value={confirmPassword}\n            onChange={(e) => setConfirmPassword(e.target.value)}\n            required\n            className=\"w-full px-3 py-2 border border-input bg-background text-foreground rounded-md focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent\"\n            placeholder=\"\"\n          />\n        </div>\n\n        <button\n          type=\"submit\"\n          disabled={loading}\n          className=\"w-full bg-primary text-primary-foreground py-2 px-4 rounded-md hover:bg-primary/90 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary disabled:opacity-50 disabled:cursor-not-allowed\"\n        >\n          {loading ? 'Creating account...' : 'Sign up'}\n        </button>\n      </form>\n\n      <div className=\"mt-6 text-center\">\n        <p className=\"text-sm text-muted-foreground\">\n          Already have an account?{' '}\n          <Link href={pathsConfig.auth.signIn} className=\"text-primary hover:underline\">\n            Sign in\n          </Link>\n        </p>\n      </div>\n    </>\n  );\n}","/Users/rennychan/Personal Apps/contax/app/layout.tsx",[],[],"/Users/rennychan/Personal Apps/contax/app/onboarding/page.tsx",["547"],[],"'use client';\n\nimport { useState } from 'react';\nimport { useRouter } from 'next/navigation';\nimport { createBrowserClient } from '@supabase/ssr';\nimport { log } from '@/lib/utils/logger';\n\nexport default function OnboardingPage() {\n  const [organizationName, setOrganizationName] = useState('');\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const router = useRouter();\n\n  const supabase = createBrowserClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n  );\n\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n    setError(null);\n\n    if (!organizationName.trim()) {\n      setError('Please enter your organization name');\n      return;\n    }\n\n    setLoading(true);\n\n    try {\n      // Call the API route to create organization\n      const response = await fetch('/api/onboarding', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          organizationName: organizationName.trim()\n        }),\n      });\n\n      const data = await response.json();\n\n      if (!response.ok) {\n        log.error('Onboarding API error', undefined, { error: data.error, organizationName });\n        setError(data.error || 'Failed to create organization');\n        return;\n      }\n\n      log.userAction('organization_created', { organizationName, organizationId: data.organizationId });\n\n      // Redirect to home page\n      router.push('/');\n    } catch (err) {\n      log.error('Onboarding error', err as Error, { organizationName });\n      setError('An unexpected error occurred');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <div className=\"min-h-screen bg-background flex items-center justify-center px-4\">\n      <div className=\"max-w-md w-full space-y-8\">\n        <div className=\"text-center\">\n          <h1 className=\"text-3xl font-bold text-foreground\">Welcome to Contax!</h1>\n          <p className=\"mt-2 text-muted-foreground\">Let's set up your organization</p>\n        </div>\n\n        <div className=\"bg-card p-8 rounded-lg shadow-lg\">\n          <form onSubmit={handleSubmit} className=\"space-y-6\">\n            {error && (\n              <div className=\"bg-destructive/10 border border-destructive/20 text-destructive px-4 py-3 rounded\">\n                {error}\n              </div>\n            )}\n\n            <div>\n              <label htmlFor=\"organizationName\" className=\"block text-sm font-medium text-foreground mb-2\">\n                What's your organization called?\n              </label>\n              <input\n                id=\"organizationName\"\n                type=\"text\"\n                value={organizationName}\n                onChange={(e) => setOrganizationName(e.target.value)}\n                className=\"w-full px-4 py-3 border border-input bg-background text-foreground rounded-md focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent text-lg\"\n                placeholder=\"e.g., Acme Corp\"\n                autoFocus\n                required\n              />\n              <p className=\"text-xs text-muted-foreground mt-2\">\n                This will be the name of your workspace in Contax\n              </p>\n            </div>\n\n            <button\n              type=\"submit\"\n              disabled={loading || !organizationName.trim()}\n              className=\"w-full bg-primary text-primary-foreground py-3 px-4 rounded-md hover:bg-primary/90 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary disabled:opacity-50 disabled:cursor-not-allowed font-medium\"\n            >\n              {loading ? 'Setting up...' : 'Continue'}\n            </button>\n          </form>\n        </div>\n      </div>\n    </div>\n  );\n}","/Users/rennychan/Personal Apps/contax/app/settings/CalendarSettings.tsx",["548","549","550","551","552","553","554","555","556","557"],[],"'use client';\n\nimport { useEffect, useState } from 'react';\nimport { Card, CardContent, CardHeader, CardTitle } from '../../components/ui/card';\nimport { Checkbox } from '../../components/ui/checkbox';\nimport { Label } from '../../components/ui/label';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '../../components/ui/select';\nimport { Badge } from '../../components/ui/badge';\nimport { Calendar } from 'lucide-react';\nimport { CalendarStatus } from '../../components/CalendarStatus';\n\ntype GCalendar = {\n  id: string;\n  summary: string;\n  primary?: boolean;\n  selected?: boolean;\n  timeZone?: string;\n};\n\ninterface CalendarSettingsProps {\n  userId: string;\n}\n\nexport default function CalendarSettings({ userId }: CalendarSettingsProps) {\n  const [calendars, setCalendars] = useState<GCalendar[]>([]);\n  const [selectedCalIds, setSelectedCalIds] = useState<string[]>([]);\n  const [calendarId, setCalendarId] = useState<string>('primary');\n  const [useUnion, setUseUnion] = useState(false);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    // Load persisted preferences\n    try {\n      const savedUnion = localStorage.getItem('cal_union');\n      if (savedUnion === '1') setUseUnion(true);\n      const savedSel = localStorage.getItem('cal_selected');\n      if (savedSel) setSelectedCalIds(JSON.parse(savedSel));\n      const savedBook = localStorage.getItem('cal_book');\n      if (savedBook) setCalendarId(savedBook);\n    } catch {}\n\n    // Fetch calendar list\n    fetch('/api/calendar/list')\n      .then((r) => (r.ok ? r.json() : null))\n      .then((j) => {\n        if (!j?.calendars) return;\n        const cals = j.calendars as GCalendar[];\n        setCalendars(cals);\n        \n        // Auto-select primary calendar if not already selected\n        const primary = cals.find((c) => c.primary);\n        if (primary && !selectedCalIds.length) {\n          setSelectedCalIds([primary.id]);\n        }\n      })\n      .catch(() => {})\n      .finally(() => setLoading(false));\n  }, []);\n\n  useEffect(() => {\n    try { \n      localStorage.setItem('cal_union', useUnion ? '1' : '0');\n    } catch {}\n  }, [useUnion]);\n\n  useEffect(() => {\n    try { \n      localStorage.setItem('cal_selected', JSON.stringify(selectedCalIds));\n    } catch {}\n  }, [selectedCalIds]);\n\n  useEffect(() => {\n    try { \n      localStorage.setItem('cal_book', calendarId);\n    } catch {}\n  }, [calendarId]);\n\n  return (\n    <div className=\"space-y-6\">\n      {/* Google Calendar Status */}\n      <section className=\"bg-gray-900/50 p-6 rounded-lg border border-gray-800\">\n        <h3 className=\"text-lg font-semibold mb-4 text-white\">Google Calendar Integration</h3>\n        <p className=\"text-sm text-gray-400 mb-4\">\n          Connect your Google Calendar to enable scheduling and availability checking.\n        </p>\n        <CalendarStatus />\n      </section>\n\n      {/* Calendar Configuration */}\n      {calendars.length > 0 && (\n        <section className=\"bg-gray-900/50 p-6 rounded-lg border border-gray-800\">\n          <h3 className=\"text-lg font-semibold mb-4 text-white flex items-center gap-2\">\n            <Calendar className=\"h-4 w-4\" />\n            Calendar Configuration\n          </h3>\n          \n          <div className=\"space-y-4\">\n            <div className=\"space-y-2\">\n              <Label>Calendars to check for availability</Label>\n              <div className=\"grid grid-cols-1 md:grid-cols-2 gap-2\">\n                {calendars.map((c) => (\n                  <div key={c.id} className=\"flex items-center space-x-2\">\n                    <Checkbox\n                      id={`cal-${c.id}`}\n                      checked={selectedCalIds.includes(c.id)}\n                      onCheckedChange={(checked) => {\n                        setSelectedCalIds((prev) => {\n                          const next = checked \n                            ? Array.from(new Set([...prev, c.id])) \n                            : prev.filter((x) => x !== c.id);\n                          return next;\n                        });\n                      }}\n                    />\n                    <Label \n                      htmlFor={`cal-${c.id}`} \n                      className=\"text-sm font-normal cursor-pointer text-gray-300\"\n                    >\n                      {c.summary} {c.primary && <Badge variant=\"outline\" className=\"ml-1\">Primary</Badge>}\n                    </Label>\n                  </div>\n                ))}\n              </div>\n            </div>\n\n            <div className=\"flex items-center space-x-2\">\n              <Checkbox\n                id=\"use-union\"\n                checked={useUnion}\n                onCheckedChange={(checked) => setUseUnion(checked as boolean)}\n              />\n              <Label htmlFor=\"use-union\" className=\"cursor-pointer text-gray-300\">\n                Use selected calendars for availability checking\n              </Label>\n            </div>\n\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"book-calendar\" className=\"text-gray-300\">Book appointments on</Label>\n              <Select value={calendarId} onValueChange={setCalendarId}>\n                <SelectTrigger id=\"book-calendar\" className=\"bg-gray-800 border-gray-700\">\n                  <SelectValue />\n                </SelectTrigger>\n                <SelectContent>\n                  {calendars.map((c) => (\n                    <SelectItem key={c.id} value={c.id}>\n                      {c.summary}\n                    </SelectItem>\n                  ))}\n                </SelectContent>\n              </Select>\n            </div>\n          </div>\n        </section>\n      )}\n    </div>\n  );\n}","/Users/rennychan/Personal Apps/contax/app/settings/TwilioIntegrationForm.tsx",["558","559","560"],[],"'use client';\n\nimport { useState, useEffect } from 'react';\nimport { createBrowserClient } from '@supabase/ssr';\nimport { Button } from '../../components/ui/button';\n\ninterface TwilioIntegrationFormProps {\n  userId: string;\n}\n\nexport default function TwilioIntegrationForm({ userId }: TwilioIntegrationFormProps) {\n  const [accountSid, setAccountSid] = useState('');\n  const [authToken, setAuthToken] = useState('');\n  const [phoneNumber, setPhoneNumber] = useState('');\n  const [isLoading, setIsLoading] = useState(false);\n  const [isSaved, setIsSaved] = useState(false);\n  const [error, setError] = useState('');\n  const [showAuthToken, setShowAuthToken] = useState(false);\n\n  const supabase = createBrowserClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n  );\n\n  useEffect(() => {\n    // Load existing Twilio configuration\n    loadTwilioConfig();\n  }, []);\n\n  const loadTwilioConfig = async () => {\n    try {\n      const response = await fetch('/api/settings/twilio');\n      if (response.ok) {\n        const data = await response.json();\n        if (data.accountSid) setAccountSid(data.accountSid);\n        if (data.phoneNumber) setPhoneNumber(data.phoneNumber);\n        if (data.authToken) setAuthToken(data.authToken);\n      }\n    } catch (err) {\n      console.error('Failed to load Twilio config:', err);\n    }\n  };\n\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n    setIsLoading(true);\n    setError('');\n    setIsSaved(false);\n\n    try {\n      const response = await fetch('/api/settings/twilio', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          accountSid,\n          authToken,\n          phoneNumber,\n        }),\n      });\n\n      if (!response.ok) {\n        const data = await response.json();\n        throw new Error(data.error || 'Failed to save Twilio configuration');\n      }\n\n      setIsSaved(true);\n      setTimeout(() => setIsSaved(false), 3000);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'An error occurred');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleDisconnect = async () => {\n    if (!confirm('Are you sure you want to disconnect your Twilio account?')) {\n      return;\n    }\n\n    setIsLoading(true);\n    setError('');\n\n    try {\n      const response = await fetch('/api/settings/twilio', {\n        method: 'DELETE',\n      });\n\n      if (!response.ok) {\n        throw new Error('Failed to disconnect Twilio');\n      }\n\n      setAccountSid('');\n      setAuthToken('');\n      setPhoneNumber('');\n      setIsSaved(true);\n      setTimeout(() => setIsSaved(false), 3000);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'An error occurred');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit} className=\"space-y-4\">\n      <div>\n        <label htmlFor=\"accountSid\" className=\"block text-sm font-medium text-gray-300 mb-1\">\n          Account SID\n        </label>\n        <input\n          type=\"text\"\n          id=\"accountSid\"\n          value={accountSid}\n          onChange={(e) => setAccountSid(e.target.value)}\n          placeholder=\"ACxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"\n          className=\"w-full px-3 py-2 border border-gray-700 bg-gray-800 text-white rounded-md focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent\"\n          required\n        />\n        <p className=\"mt-1 text-xs text-gray-500\">\n          Found in your Twilio Console dashboard\n        </p>\n      </div>\n\n      <div>\n        <label htmlFor=\"authToken\" className=\"block text-sm font-medium text-gray-300 mb-1\">\n          Auth Token\n        </label>\n        <div className=\"relative\">\n          <input\n            type={showAuthToken ? 'text' : 'password'}\n            id=\"authToken\"\n            value={authToken}\n            onChange={(e) => setAuthToken(e.target.value)}\n            placeholder=\"********************************\"\n            className=\"w-full px-3 py-2 pr-20 border border-gray-700 bg-gray-800 text-white rounded-md focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent\"\n            required\n          />\n          <Button\n            type=\"button\"\n            variant=\"ghost\"\n            size=\"sm\"\n            onClick={() => setShowAuthToken(!showAuthToken)}\n            className=\"absolute right-2 top-1/2 -translate-y-1/2\"\n          >\n            {showAuthToken ? 'Hide' : 'Show'}\n          </Button>\n        </div>\n        <p className=\"mt-1 text-xs text-gray-500\">\n          Keep this secret! Found in your Twilio Console\n        </p>\n      </div>\n\n      <div>\n        <label htmlFor=\"phoneNumber\" className=\"block text-sm font-medium text-gray-300 mb-1\">\n          Twilio Phone Number\n        </label>\n        <input\n          type=\"tel\"\n          id=\"phoneNumber\"\n          value={phoneNumber}\n          onChange={(e) => setPhoneNumber(e.target.value)}\n          placeholder=\"+1234567890\"\n          className=\"w-full px-3 py-2 border border-gray-700 bg-gray-800 text-white rounded-md focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent\"\n          required\n        />\n        <p className=\"mt-1 text-xs text-gray-500\">\n          Your Twilio phone number (with country code)\n        </p>\n      </div>\n\n      {error && (\n        <div className=\"p-3 bg-red-900/20 border border-red-800 rounded-md\">\n          <p className=\"text-sm text-red-400\">{error}</p>\n        </div>\n      )}\n\n      {isSaved && (\n        <div className=\"p-3 bg-green-900/20 border border-green-800 rounded-md\">\n          <p className=\"text-sm text-green-400\">Twilio configuration saved successfully!</p>\n        </div>\n      )}\n\n      <div className=\"flex gap-3\">\n        <Button\n          type=\"submit\"\n          variant=\"outline\"\n          disabled={isLoading}\n        >\n          {isLoading ? 'Saving...' : 'Save Configuration'}\n        </Button>\n\n        {(accountSid || authToken || phoneNumber) && (\n          <Button\n            type=\"button\"\n            variant=\"outline\"\n            onClick={handleDisconnect}\n            disabled={isLoading}\n          >\n            Disconnect Twilio\n          </Button>\n        )}\n      </div>\n    </form>\n  );\n}","/Users/rennychan/Personal Apps/contax/app/settings/WebhookGenerator.tsx",["561","562"],[],"'use client';\n\nimport { useState } from 'react';\nimport { Copy, RefreshCw, ExternalLink } from 'lucide-react';\nimport { Button } from '../../components/ui/button';\n\ninterface WebhookGeneratorProps {\n  userId: string;\n}\n\nexport default function WebhookGenerator({ userId }: WebhookGeneratorProps) {\n  const [webhookUrl, setWebhookUrl] = useState<string>('');\n  const [isGenerating, setIsGenerating] = useState(false);\n  const [copied, setCopied] = useState(false);\n\n  const generateWebhookUrl = async () => {\n    setIsGenerating(true);\n    try {\n      const response = await fetch('/api/settings/webhook', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ userId }),\n      });\n\n      if (!response.ok) {\n        throw new Error('Failed to generate webhook URL');\n      }\n\n      const data = await response.json();\n      setWebhookUrl(data.webhookUrl);\n    } catch (error) {\n      console.error('Error generating webhook URL:', error);\n      alert('Failed to generate webhook URL. Please try again.');\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n\n  const copyToClipboard = async () => {\n    try {\n      await navigator.clipboard.writeText(webhookUrl);\n      setCopied(true);\n      setTimeout(() => setCopied(false), 2000);\n    } catch (error) {\n      console.error('Failed to copy:', error);\n    }\n  };\n\n  return (\n    <div className=\"space-y-4\">\n      {!webhookUrl ? (\n        <Button\n          onClick={generateWebhookUrl}\n          disabled={isGenerating}\n          variant=\"outline\"\n        >\n          {isGenerating ? (\n            <>\n              <RefreshCw className=\"h-4 w-4 animate-spin\" />\n              Generating...\n            </>\n          ) : (\n            <>\n              <ExternalLink className=\"h-4 w-4\" />\n              Generate Webhook URL\n            </>\n          )}\n        </Button>\n      ) : (\n        <div className=\"space-y-3\">\n          <div className=\"flex items-center gap-2\">\n            <input\n              type=\"text\"\n              value={webhookUrl}\n              readOnly\n              className=\"flex-1 px-3 py-2 bg-gray-800 border border-gray-700 rounded-lg text-sm text-gray-300 font-mono\"\n            />\n            <Button\n              onClick={copyToClipboard}\n              variant=\"ghost\"\n              size=\"icon\"\n              title=\"Copy to clipboard\"\n            >\n              <Copy className=\"h-4 w-4\" />\n            </Button>\n          </div>\n          {copied && (\n            <p className=\"text-sm text-green-500\">Copied to clipboard!</p>\n          )}\n          <Button\n            onClick={generateWebhookUrl}\n            variant=\"ghost\"\n            size=\"sm\"\n            className=\"text-blue-400 hover:text-blue-300\"\n          >\n            <RefreshCw className=\"h-3 w-3 mr-1\" />\n            Regenerate URL\n          </Button>\n        </div>\n      )}\n      <div className=\"space-y-2\">\n        <p className=\"text-xs text-gray-500\">\n          Use this webhook URL to receive notifications from external services when appointments are booked or calendar events are updated.\n        </p>\n        {webhookUrl && webhookUrl.includes('localhost') && (\n          <div className=\"p-2 bg-yellow-900/20 border border-yellow-800 rounded text-xs text-yellow-400\">\n            <p className=\"font-semibold mb-1\">Local Development Mode</p>\n            <p>This webhook URL uses localhost and won't be accessible from external services. To test webhooks locally, use a tunneling service like:</p>\n            <ul className=\"list-disc list-inside mt-1 space-y-0.5\">\n              <li>ngrok: <code className=\"text-yellow-300\">ngrok http 3000</code></li>\n              <li>Cloudflare Tunnel: <code className=\"text-yellow-300\">cloudflared tunnel --url http://localhost:3000</code></li>\n            </ul>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}","/Users/rennychan/Personal Apps/contax/app/settings/page.tsx",[],[],"/Users/rennychan/Personal Apps/contax/components/CalendarStatus.tsx",["563"],[],"'use client'\n\nimport { useEffect, useState } from 'react'\nimport { Card, CardHeader, CardContent } from './ui/card'\nimport { Button } from './ui/button'\n\ntype GCalStatus = {\n  connected: boolean\n  hasToken: boolean\n  scopes?: string[]\n  calendars?: { id: string; summary: string; primary?: boolean }[]\n  primaryReachable?: boolean\n  errors?: { step: string; message: string }[]\n}\n\nexport function CalendarStatus() {\n  const [loading, setLoading] = useState(false)\n  const [status, setStatus] = useState<GCalStatus | null>(null)\n\n  async function refresh() {\n    setLoading(true)\n    try {\n      const res = await fetch('/api/calendar/status').then((r) => r.json())\n      setStatus(res)\n    } catch (e) {\n      setStatus({ connected: false, hasToken: false, errors: [{ step: 'client', message: (e as Error).message }] })\n    } finally {\n      setLoading(false)\n    }\n  }\n\n  useEffect(() => {\n    refresh()\n  }, [])\n\n  const connected = status?.connected\n  const color = connected ? '#0a7' : '#c33'\n\n  return (\n    <Card className={connected ? 'bg-green-900/50 border-green-700' : ''}>\n      <CardHeader>\n        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', width: '100%' }}>\n          <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>\n            <div style={{ width: 10, height: 10, borderRadius: 6, background: color }} />\n            <div>\n              <strong>Google Calendar:</strong>{' '}\n              {status ? (connected ? 'Connected' : status.hasToken ? 'Token present, but connection failed' : 'Token missing') : 'Checking'}\n            </div>\n          </div>\n          <Button variant=\"secondary\" onClick={() => (window.location.href = '/api/google/oauth/start')}>Connect Google Calendar</Button>\n        </div>\n      </CardHeader>\n      <CardContent>\n        {/* Hidden: Scopes and Calendars\n        {status?.scopes && (\n          <div className=\"mk-label\">Scopes: <code>{status.scopes.join(' ')}</code></div>\n        )}\n        {status?.calendars && (\n          <div className=\"mk-label\">Calendars: {status.calendars.map((c) => `${c.summary}${c.primary ? ' (primary)' : ''}`).join(', ')}\n          </div>\n        )}\n        */}\n        {status?.errors && status.errors.length > 0 && (\n          <div style={{ color: '#a00' }}>Errors: {status.errors.map((e) => `${e.step}: ${e.message}`).join(' | ')}</div>\n        )}\n      </CardContent>\n    </Card>\n  )\n}\n","/Users/rennychan/Personal Apps/contax/components/OutgoingCallTrigger.tsx",["564","565","566"],[],"'use client';\n\nimport { useState } from 'react';\nimport { Button } from './ui/button';\nimport { Input } from './ui/input';\nimport { Label } from './ui/label';\nimport { Phone, PhoneOff, Loader2 } from 'lucide-react';\nimport { log } from '@/lib/utils/logger';\n\ninterface OutgoingCallTriggerProps {\n  organizationId?: string;\n  userId?: string;\n  agentId?: string;\n}\n\nexport function OutgoingCallTrigger({ \n  organizationId, \n  userId, \n  agentId \n}: OutgoingCallTriggerProps) {\n  const [phoneNumber, setPhoneNumber] = useState('');\n  const [isLoading, setIsLoading] = useState(false);\n  const [callSid, setCallSid] = useState<string | null>(null);\n  const [error, setError] = useState<string | null>(null);\n\n  const handleCall = async () => {\n    if (!phoneNumber) {\n      setError('Please enter a phone number');\n      return;\n    }\n\n    // Basic phone number validation\n    const cleanedNumber = phoneNumber.replace(/\\D/g, '');\n    if (cleanedNumber.length < 10) {\n      setError('Please enter a valid phone number');\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const response = await fetch('/api/webhook/outgoing-call', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          phoneNumber: phoneNumber.startsWith('+') ? phoneNumber : `+1${cleanedNumber}`,\n          organizationId,\n          userId,\n          agentId,\n        }),\n      });\n\n      const data = await response.json();\n\n      if (!response.ok) {\n        throw new Error(data.error || 'Failed to initiate call');\n      }\n\n      setCallSid(data.callSid);\n      log.userAction('call_initiated', {\n        organizationId,\n        userId,\n        agentId,\n        phoneNumber: phoneNumber.startsWith('+') ? phoneNumber : `+1${cleanedNumber}`,\n        callSid: data.callSid\n      });\n    } catch (err: any) {\n      setError(err.message || 'Failed to initiate call');\n      console.error('Error initiating call:', err);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleHangup = async () => {\n    if (!callSid) return;\n\n    setIsLoading(true);\n    try {\n      // You can implement a hangup endpoint if needed\n      log.userAction('call_hung_up', { callSid, organizationId, userId, agentId });\n      setCallSid(null);\n      setPhoneNumber('');\n    } catch (err) {\n      console.error('Error hanging up:', err);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  return (\n    <div className=\"space-y-4\">\n\n      <div className=\"space-y-2\">\n        <Label htmlFor=\"phone\">Phone Number</Label>\n        <Input\n          id=\"phone\"\n          type=\"tel\"\n          placeholder=\"+1 (555) 123-4567\"\n          value={phoneNumber}\n          onChange={(e) => setPhoneNumber(e.target.value)}\n          disabled={isLoading || !!callSid}\n        />\n        {error && (\n          <p className=\"text-sm text-red-600\">{error}</p>\n        )}\n      </div>\n\n      <div className=\"flex gap-2\">\n        {!callSid ? (\n          <Button\n            onClick={handleCall}\n            disabled={isLoading || !phoneNumber}\n            className=\"flex items-center gap-2\"\n          >\n            {isLoading ? (\n              <>\n                <Loader2 className=\"h-4 w-4 animate-spin\" />\n                Initiating...\n              </>\n            ) : (\n              <>\n                <Phone className=\"h-4 w-4\" />\n                Call\n              </>\n            )}\n          </Button>\n        ) : (\n          <Button\n            onClick={handleHangup}\n            variant=\"destructive\"\n            disabled={isLoading}\n            className=\"flex items-center gap-2\"\n          >\n            <PhoneOff className=\"h-4 w-4\" />\n            Hang Up\n          </Button>\n        )}\n      </div>\n\n      {callSid && (\n        <div className=\"p-3 bg-green-50 border border-green-200 rounded\">\n          <p className=\"text-sm text-green-800\">\n            Call initiated successfully!\n          </p>\n          <p className=\"text-xs text-green-600 mt-1\">\n            Call SID: {callSid}\n          </p>\n        </div>\n      )}\n    </div>\n  );\n}","/Users/rennychan/Personal Apps/contax/components/PromptModal.tsx",[],[],"/Users/rennychan/Personal Apps/contax/components/shared/Header.tsx",["567"],[],"import { cookies } from 'next/headers';\nimport { createServerClient } from '@supabase/ssr';\nimport UserDropdownMenu from '../../app/(home)/UserDropdownMenu';\nimport Link from 'next/link';\n\nexport default async function Header() {\n  const cookieStore = await cookies();\n  const supabase = createServerClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n    {\n      cookies: {\n        getAll() {\n          return cookieStore.getAll();\n        },\n        setAll(cookiesToSet) {\n          try {\n            cookiesToSet.forEach(({ name, value, options }) => {\n              cookieStore.set(name, value, options);\n            });\n          } catch (error) {\n            // Handle error\n          }\n        },\n      },\n    }\n  );\n\n  const { data: { user } } = await supabase.auth.getUser();\n  \n  let organizationName = null;\n  if (user) {\n    const { data: membership } = await supabase\n      .from('organization_members')\n      .select('organizations(name)')\n      .eq('user_id', user.id)\n      .single();\n    \n    organizationName = (membership?.organizations as any)?.name || null;\n  }\n\n  return (\n    <header className=\"border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60\">\n      <div className=\"container flex h-14 items-center justify-between\">\n        <div className=\"flex items-center\">\n          <Link \n            href=\"/\" \n            className=\"text-2xl font-bold text-white hover:text-gray-200 transition-colors\"\n          >\n            Contax\n          </Link>\n        </div>\n        {user && (\n          <UserDropdownMenu email={user.email!} organizationName={organizationName} />\n        )}\n      </div>\n    </header>\n  );\n}","/Users/rennychan/Personal Apps/contax/components/shared/VoiceAgent.tsx",["568","569","570","571","572","573","574"],[],"'use client'\n\nimport { useEffect, useRef, useState } from 'react'\nimport { OpenAIRealtimeAgent } from '@/lib/agent/openai-realtime'\nimport { CalendarStatus } from '../CalendarStatus'\nimport Link from 'next/link'\nimport type { ToolEvent } from '@/types/agent'\nimport type { GoogleCalendar, TimeSlot } from '@/types/google'\nimport type { CalendarListResponse, ApiResponse, CheckAvailabilityResponse } from '@/types/api'\n\n// Import UI components\nimport { Button } from '../ui/button'\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '../ui/card'\nimport { Checkbox } from '../ui/checkbox'\nimport { Label } from '../ui/label'\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '../ui/select'\nimport { Badge } from '../ui/badge'\nimport { Alert, AlertDescription } from '../ui/alert'\nimport { Collapsible, CollapsibleContent, CollapsibleTrigger } from '../ui/collapsible'\nimport { Separator } from '../ui/separator'\nimport { ChevronDown, Mic, MicOff, Phone, PhoneOff, Eye, EyeOff, Calendar, TestTube, Clock, Bug, TestTube2, Settings } from 'lucide-react'\nimport { cn } from '@/lib/utils/utils'\n\n// Use the proper GoogleCalendar type from types/google.ts\n\ninterface VoiceAgentProps {\n  agentId?: string\n  systemPrompt?: string\n  greeting?: string\n  language?: string\n  agentName?: string\n  organizationName?: string\n  isDemo?: boolean\n  agentDescription?: string\n  variant?: 'default' | 'styled'\n  showCalendarConfig?: boolean\n  showDebugByDefault?: boolean\n}\n\nexport function VoiceAgent({\n  agentId,\n  systemPrompt = '',\n  greeting = 'Hi, how can I help?',\n  language = 'en-US',\n  agentName = 'Voice Scheduling Assistant',\n  organizationName,\n  isDemo = false,\n  agentDescription,\n  variant = 'default',\n  showCalendarConfig = true,\n  showDebugByDefault = false\n}: VoiceAgentProps) {\n  const [connected, setConnected] = useState(false)\n  const [transcript, setTranscript] = useState<string[]>([])\n  const [org, setOrg] = useState<{ id: string; name: string } | null>(null)\n  const [calendarId, setCalendarId] = useState<string>('primary')\n  const [calendarTz, setCalendarTz] = useState<string | null>(null)\n  const [calendars, setCalendars] = useState<GoogleCalendar[]>([])\n  const [selectedCalIds, setSelectedCalIds] = useState<string[]>([])\n  const [useUnion, setUseUnion] = useState<boolean>(variant === 'default')\n  const agentRef = useRef<OpenAIRealtimeAgent | null>(null)\n  const [debugOpen, setDebugOpen] = useState(showDebugByDefault)\n  const [toolEvents, setToolEvents] = useState<Array<{ t: number; data: ToolEvent }>>([])\n  const [testResult, setTestResult] = useState<CheckAvailabilityResponse | null>(null)\n  const [agentSays, setAgentSays] = useState<string[]>([])\n  const [actualAgentTranscript, setActualAgentTranscript] = useState<string[]>([])\n  const [availableSlots, setAvailableSlots] = useState<TimeSlot[]>([])\n  const [slotsTz, setSlotsTz] = useState<string | null>(null)\n  const [showUserTranscript, setShowUserTranscript] = useState<boolean>(false)\n  const [showAgentTranscript, setShowAgentTranscript] = useState<boolean>(variant === 'styled')\n\n  useEffect(() => {\n    agentRef.current = new OpenAIRealtimeAgent({\n      onTranscript: (text) => setTranscript((prev) => [...prev, text]),\n      onAgentTranscript: (text, final) => {\n        if (final) {\n          // When we get a final transcript, add it to the list\n          setActualAgentTranscript((prev) => [...prev, text])\n        }\n      },\n      onToolEvent: (e) => {\n        setToolEvents((prev) => [...prev.slice(-19), { t: Date.now(), data: e }])\n        if (e.kind === 'event' && e.type === 'spoken' && 'text' in e && e.text) {\n          setAgentSays((prev) => [...prev, String(e.text)])\n        }\n      },\n      onSlots: (slots, tz) => {\n        setAvailableSlots(slots)\n        setSlotsTz(tz || null)\n      }\n    })\n    // Restore persisted selections\n    try {\n      const savedUnion = localStorage.getItem('cal_union')\n      if (savedUnion != null) setUseUnion(savedUnion === '1')\n      const savedSel = localStorage.getItem('cal_selected')\n      if (savedSel) setSelectedCalIds(JSON.parse(savedSel))\n      const savedBook = localStorage.getItem('cal_book')\n      if (savedBook) setCalendarId(savedBook)\n    } catch {}\n\n    // Fetch default org\n    fetch('/api/org/default')\n      .then((r) => r.json())\n      .then((j) => j.organization && setOrg(j.organization))\n      .catch(() => {})\n\n    // Fetch calendar status for timezone\n    const statusUrl = agentId ? `/api/agents/${agentId}/calendar/status` : '/api/calendar/status'\n    fetch(statusUrl)\n      .then((r) => r.json())\n      .then((j) => setCalendarTz(j.accountTimeZone || j.primaryTimeZone || null))\n      .catch(() => {})\n\n    // Fetch calendars list\n    const listUrl = agentId ? `/api/agents/${agentId}/calendar/list` : '/api/calendar/list'\n    fetch(listUrl)\n      .then((r) => (r.ok ? r.json() : null))\n      .then((j: CalendarListResponse) => {\n        if (!j?.calendars) return\n        setCalendars(j.calendars)\n        // Default to all calendars the user has selected in Google, plus primary\n        const defaults = j.calendars.filter((c) => c.selected || c.primary).map((c) => c.id)\n        const sel = defaults.length ? defaults : j.calendars.map((c) => c.id)\n        // If we have a persisted selection, prefer it; else default\n        const nextSel = selectedCalIds.length ? selectedCalIds : sel\n        setSelectedCalIds(nextSel)\n        agentRef.current?.setCalendarIds(useUnion ? nextSel : [calendarId])\n        const primary = j.calendars.find((c) => c.primary) || j.calendars[0]\n        if (primary) {\n          setCalendarId(primary.id)\n          if (primary.timeZone) setCalendarTz(primary.timeZone)\n        }\n      })\n      .catch(() => {})\n    return () => {\n      agentRef.current?.disconnect().catch(() => {})\n      agentRef.current = null\n    }\n  }, [agentId])\n\n  async function start() {\n    try {\n      // Ensure agent uses the latest calendar selection before connecting\n      agentRef.current?.setCalendarIds(useUnion ? selectedCalIds : [calendarId])\n      await agentRef.current!.connect(systemPrompt, {\n        organizationId: org?.id,\n        agentId,\n        calendarId,\n        greeting,\n        language,\n        // Pass the active calendar timezone so the agent speaks and reasons in local time\n        timeZone: calendarTz || undefined\n      })\n    } catch (e) {\n      alert((e as Error).message)\n      return\n    }\n    setConnected(true)\n  }\n\n  async function stop() {\n    setConnected(false)\n    await agentRef.current?.disconnect()\n  }\n\n  // Persist selections\n  useEffect(() => {\n    try { localStorage.setItem('cal_union', useUnion ? '1' : '0') } catch {}\n    // update agent calendarIds when toggle changes\n    agentRef.current?.setCalendarIds(useUnion ? selectedCalIds : [calendarId])\n  }, [useUnion])\n\n  useEffect(() => {\n    try { localStorage.setItem('cal_selected', JSON.stringify(selectedCalIds)) } catch {}\n    agentRef.current?.setCalendarIds(useUnion ? selectedCalIds : [calendarId])\n  }, [selectedCalIds])\n\n  useEffect(() => {\n    try { localStorage.setItem('cal_book', calendarId) } catch {}\n    agentRef.current?.setCalendarIds(useUnion ? selectedCalIds : [calendarId])\n  }, [calendarId])\n\n  // Helper functions for date/time formatting\n  const fmtDateLocal = (iso: string, tz?: string) => {\n    try {\n      const d = new Date(iso)\n      const fmt = new Intl.DateTimeFormat('en-US', {\n        timeZone: tz,\n        weekday: 'short',\n        year: 'numeric',\n        month: 'short',\n        day: '2-digit'\n      })\n      return fmt.format(d)\n    } catch {\n      return iso.slice(0, 10)\n    }\n  }\n\n  const fmtTimeLocal = (iso: string, tz?: string) => {\n    try {\n      const d = new Date(iso)\n      const fmt = new Intl.DateTimeFormat('en-US', {\n        timeZone: tz,\n        hour: '2-digit',\n        minute: '2-digit'\n      })\n      return fmt.format(d)\n    } catch {\n      return iso\n    }\n  }\n\n  const fmtRangeLocal = (startIso: string, endIso: string, tz?: string) => {\n    try {\n      return `${fmtTimeLocal(startIso, tz)}  ${fmtTimeLocal(endIso, tz)}`\n    } catch {\n      return `${startIso}  ${endIso}`\n    }\n  }\n\n  if (variant === 'styled') {\n    return (\n      <div className=\"space-y-4\">\n        {/* Header Card - Styled Version */}\n        <Card>\n          <CardHeader>\n            <div className=\"flex items-center justify-between\">\n              <CardTitle className=\"flex items-center gap-2\">\n                <Phone className=\"h-5 w-5\" />\n                {agentName}\n                {isDemo && (\n                  <Badge variant=\"outline\" className=\"text-xs ml-2\">\n                    DEMO\n                  </Badge>\n                )}\n              </CardTitle>\n              {calendarTz && (\n                <Badge variant=\"secondary\" className=\"flex items-center gap-1\">\n                  <Clock className=\"h-3 w-3\" />\n                  {calendarTz}\n                </Badge>\n              )}\n            </div>\n            <CardDescription>\n              {isDemo && agentDescription ? agentDescription : 'AI-powered voice agent for calendar management'}\n            </CardDescription>\n          </CardHeader>\n          <CardContent className=\"space-y-4\">\n            {/* Action Buttons */}\n            <div className=\"flex gap-2 flex-wrap\">\n              {!connected ? (\n                <Button onClick={start} className=\"flex items-center gap-2\">\n                  <Mic className=\"h-4 w-4\" />\n                  Call {organizationName ? `${organizationName}'s` : \"the\"} Office\n                </Button>\n              ) : (\n                <Button onClick={stop} variant=\"destructive\" className=\"flex items-center gap-2\">\n                  <PhoneOff className=\"h-4 w-4\" />\n                  Hang Up\n                </Button>\n              )}\n\n              <Button\n                variant=\"outline\"\n                onClick={() => setShowAgentTranscript(!showAgentTranscript)}\n                className=\"flex items-center gap-2\"\n              >\n                {showAgentTranscript ? <EyeOff className=\"h-4 w-4\" /> : <Eye className=\"h-4 w-4\" />}\n                {showAgentTranscript ? 'Hide' : 'Show'} Agent Transcript\n              </Button>\n\n              <Button\n                variant=\"outline\"\n                onClick={() => setDebugOpen(!debugOpen)}\n                className=\"flex items-center gap-2\"\n              >\n                <Bug className=\"h-4 w-4\" />\n                {debugOpen ? 'Hide' : 'Show'} Debug\n              </Button>\n\n              <Link href=\"/agent-settings\">\n                <Button\n                  variant=\"outline\"\n                  className=\"flex items-center gap-2\"\n                >\n                  <Settings className=\"h-4 w-4\" />\n                  Agent Settings\n                </Button>\n              </Link>\n            </div>\n\n            {/* Status Badge */}\n            <div className=\"flex items-center gap-2\">\n              <span className=\"text-sm text-muted-foreground\">Status:</span>\n              <Badge variant={connected ? \"default\" : \"secondary\"}>\n                {connected ? 'Connected' : 'Idle'}\n              </Badge>\n            </div>\n          </CardContent>\n        </Card>\n\n        {/* Rest of styled components */}\n        {renderTranscripts()}\n        {renderAvailableSlots()}\n        {renderDebugPanel()}\n      </div>\n    )\n  }\n\n  // Default variant\n  return (\n    <div className=\"space-y-6\">\n      <OrgBar org={org} setOrg={setOrg} calendarId={calendarId} />\n      {calendarTz && (\n        <div className=\"text-sm text-muted-foreground\">\n          <strong>Active Timezone:</strong> {calendarTz}\n        </div>\n      )}\n      <CalendarStatus />\n\n      {showCalendarConfig && calendars.length > 0 && renderCalendarConfig()}\n\n      <Card>\n        <CardHeader>\n          <CardTitle className=\"flex items-center gap-2\">\n            <Phone className=\"h-5 w-5\" />\n            Voice Agent Control\n          </CardTitle>\n        </CardHeader>\n        <CardContent className=\"space-y-4\">\n          <div className=\"flex flex-wrap gap-2\">\n            {!connected ? (\n              <Button onClick={start} className=\"flex items-center gap-2\">\n                <Mic className=\"h-4 w-4\" />\n                Start Voice Session\n              </Button>\n            ) : (\n              <Button variant=\"destructive\" onClick={stop} className=\"flex items-center gap-2\">\n                <PhoneOff className=\"h-4 w-4\" />\n                Hang Up\n              </Button>\n            )}\n            <Button variant=\"outline\" onClick={() => setDebugOpen((v) => !v)}>\n              {debugOpen ? <EyeOff className=\"h-4 w-4 mr-2\" /> : <Eye className=\"h-4 w-4 mr-2\" />}\n              {debugOpen ? 'Hide Debug' : 'Show Debug'}\n            </Button>\n            <Button variant=\"outline\" onClick={() => setShowUserTranscript((v) => !v)}>\n              {showUserTranscript ? 'Hide Transcript' : 'Show Transcript'}\n            </Button>\n            <Button variant=\"outline\" onClick={() => setShowAgentTranscript((v) => !v)}>\n              {showAgentTranscript ? 'Hide Agent Transcript' : 'Show Agent Transcript'}\n            </Button>\n            <Button\n              variant=\"outline\"\n              onClick={async () => {\n                if (!org) return alert('No organization loaded')\n                const now = new Date()\n                const startIso = new Date(now.getFullYear(), now.getMonth(), now.getDate(), now.getHours() + 1, 0, 0)\n                  .toISOString()\n                const endIso = new Date(now.getFullYear(), now.getMonth(), now.getDate(), now.getHours() + 2, 0, 0)\n                  .toISOString()\n                const availabilityUrl = agentId\n                  ? `/api/agents/${agentId}/calendar/check-availability`\n                  : '/api/calendar/check-availability'\n                const res = await fetch(availabilityUrl, {\n                  method: 'POST',\n                  headers: { 'Content-Type': 'application/json' },\n                  body: JSON.stringify({ organizationId: org.id, start: startIso, end: endIso, calendarId })\n                }).then((r) => r.json())\n                setTestResult(res)\n              }}\n              className=\"flex items-center gap-2\"\n            >\n              <TestTube className=\"h-4 w-4\" />\n              Test Availability (next hour)\n            </Button>\n          </div>\n          <div className=\"flex items-center gap-2\">\n            <div className={`h-2 w-2 rounded-full ${connected ? 'bg-green-500' : 'bg-gray-400'}`} />\n            <span className=\"text-sm text-muted-foreground\">\n              <strong>Status:</strong> {connected ? 'Connected' : 'Idle'}\n            </span>\n          </div>\n        </CardContent>\n      </Card>\n\n      {renderTranscripts()}\n      {renderAvailableSlots()}\n      {renderDebugPanel()}\n    </div>\n  )\n\n  function renderCalendarConfig() {\n    return (\n      <Card>\n        <CardHeader>\n          <CardTitle className=\"text-lg\">Calendar Configuration</CardTitle>\n          <CardDescription>Select calendars and settings for the voice agent</CardDescription>\n        </CardHeader>\n        <CardContent className=\"space-y-4\">\n          <div>\n            <Label className=\"text-sm font-medium\">Calendars to consider (availability):</Label>\n            <div className=\"mt-2 flex flex-wrap gap-3\">\n              {calendars.map((c) => (\n                <div key={c.id} className=\"flex items-center space-x-2\">\n                  <Checkbox\n                    id={`calendar-${c.id}`}\n                    checked={selectedCalIds.includes(c.id)}\n                    onCheckedChange={(checked) => {\n                      setSelectedCalIds((prev) => {\n                        const next = checked ? Array.from(new Set([...prev, c.id])) : prev.filter((x) => x !== c.id)\n                        agentRef.current?.setCalendarIds(next)\n                        return next\n                      })\n                    }}\n                  />\n                  <Label htmlFor={`calendar-${c.id}`} className=\"text-sm\">\n                    {c.summary} {c.primary ? <Badge variant=\"secondary\" className=\"ml-1 text-xs\">primary</Badge> : ''}\n                  </Label>\n                </div>\n              ))}\n            </div>\n          </div>\n          <div className=\"flex items-center space-x-2\">\n            <Checkbox\n              id=\"use-union\"\n              checked={useUnion}\n              onCheckedChange={(checked) => setUseUnion(!!checked)}\n            />\n            <Label htmlFor=\"use-union\" className=\"text-sm\">Use selected calendars for availability</Label>\n          </div>\n          <div>\n            <Label className=\"text-sm font-medium\">Book appointments on:</Label>\n            <Select\n              value={calendarId}\n              onValueChange={(value) => {\n                setCalendarId(value)\n                const found = calendars.find((c) => c.id === value)\n                if (found?.timeZone) setCalendarTz(found.timeZone)\n              }}\n            >\n              <SelectTrigger className=\"mt-1\">\n                <SelectValue />\n              </SelectTrigger>\n              <SelectContent>\n                {calendars.map((c) => (\n                  <SelectItem key={c.id} value={c.id}>\n                    {c.summary}\n                  </SelectItem>\n                ))}\n              </SelectContent>\n            </Select>\n          </div>\n        </CardContent>\n      </Card>\n    )\n  }\n\n  function renderTranscripts() {\n    return (\n      <>\n        {/* User Transcript */}\n        {showUserTranscript && (\n          <Card>\n            <CardHeader>\n              <CardTitle className={variant === 'styled' ? 'text-base' : 'text-lg'}>User Transcript</CardTitle>\n              {variant === 'default' && <CardDescription>Your speech recognized by the system</CardDescription>}\n            </CardHeader>\n            <CardContent>\n              {transcript.length === 0 ? (\n                <p className=\"text-sm text-muted-foreground\">No speech detected yet.</p>\n              ) : (\n                <ul className={variant === 'styled' ? 'space-y-1' : 'space-y-2'}>\n                  {transcript.map((t, i) => (\n                    <li key={i} className={variant === 'styled' ? 'text-sm' : 'text-sm bg-muted p-2 rounded'}>{t}</li>\n                  ))}\n                </ul>\n              )}\n            </CardContent>\n          </Card>\n        )}\n\n        {/* Agent Transcript */}\n        {showAgentTranscript && (actualAgentTranscript.length > 0 || agentSays.length > 0) && (\n          <Card>\n            <CardHeader>\n              <CardTitle className={variant === 'styled' ? 'text-base' : 'text-lg'}>Agent Transcript</CardTitle>\n              {variant === 'default' && <CardDescription>What the AI agent is saying</CardDescription>}\n            </CardHeader>\n            <CardContent className=\"space-y-4\">\n              {actualAgentTranscript.length === 0 && agentSays.length === 0 ? (\n                <p className=\"text-sm text-muted-foreground\">No agent speech yet.</p>\n              ) : (\n                <>\n                  {actualAgentTranscript.length > 0 && (\n                    <div>\n                      {variant === 'default' && <h4 className=\"font-medium text-sm mb-2\">Actual Speech</h4>}\n                      <ul className={variant === 'styled' ? 'space-y-1' : 'space-y-2'}>\n                        {actualAgentTranscript.map((t, i) => (\n                          <li key={i} className={variant === 'styled'\n                            ? 'text-sm'\n                            : 'text-sm bg-blue-50 p-2 rounded dark:bg-blue-900/20'\n                          }>{t}</li>\n                        ))}\n                      </ul>\n                    </div>\n                  )}\n                  {agentSays.length > 0 && (\n                    <Collapsible>\n                      <CollapsibleTrigger className=\"flex items-center gap-2 text-sm text-muted-foreground hover:text-foreground\">\n                        <ChevronDown className=\"h-4 w-4\" />\n                        Intended responses ({agentSays.length})\n                      </CollapsibleTrigger>\n                      <CollapsibleContent className=\"mt-2\">\n                        <ul className={variant === 'styled' ? 'space-y-1 opacity-60' : 'space-y-2 opacity-70'}>\n                          {agentSays.map((t, i) => (\n                            <li key={i} className={variant === 'styled' ? 'text-sm' : 'text-sm bg-muted p-2 rounded'}>{t}</li>\n                          ))}\n                        </ul>\n                      </CollapsibleContent>\n                    </Collapsible>\n                  )}\n                </>\n              )}\n            </CardContent>\n          </Card>\n        )}\n      </>\n    )\n  }\n\n  function renderAvailableSlots() {\n    if (availableSlots.length === 0) return null\n\n    return (\n      <Card>\n        <CardHeader>\n          <CardTitle className={cn(\n            \"flex items-center gap-2\",\n            variant === 'styled' ? 'text-base' : 'text-lg'\n          )}>\n            {variant === 'default' && <Calendar className=\"h-5 w-5\" />}\n            {variant === 'styled'\n              ? `Available Slots - ${fmtDateLocal(availableSlots[0].start, slotsTz || calendarTz || undefined)}`\n              : 'Available Slots'\n            }\n          </CardTitle>\n          <CardDescription>\n            {variant === 'styled'\n              ? `${slotsTz || calendarTz || 'local'} timezone`\n              : `Availability on ${fmtDateLocal(availableSlots[0].start, slotsTz || calendarTz || undefined)} (${slotsTz || calendarTz || 'local'})`\n            }\n          </CardDescription>\n        </CardHeader>\n        <CardContent>\n          {variant === 'styled' ? (\n            <div className=\"grid grid-cols-2 md:grid-cols-3 gap-2\">\n              {availableSlots.map((s, i) => (\n                <Badge key={i} variant=\"secondary\" className=\"justify-center py-1.5\">\n                  {fmtRangeLocal(s.start, s.end, slotsTz || calendarTz || undefined)}\n                </Badge>\n              ))}\n            </div>\n          ) : (\n            <ul className=\"space-y-2\">\n              {availableSlots.map((s, i) => (\n                <li key={i} className=\"flex items-center gap-2\">\n                  <Badge variant=\"outline\" className=\"font-mono\">\n                    {fmtRangeLocal(s.start, s.end, slotsTz || calendarTz || undefined)}\n                  </Badge>\n                </li>\n              ))}\n            </ul>\n          )}\n        </CardContent>\n      </Card>\n    )\n  }\n\n  function renderDebugPanel() {\n    if (!debugOpen) return null\n\n    return (\n      <Card className={variant === 'styled' ? 'bg-black text-green-400 font-mono' : ''}>\n        <CardHeader>\n          <CardTitle className={cn(\n            \"flex items-center gap-2\",\n            variant === 'styled'\n              ? 'text-base text-green-400'\n              : 'text-lg text-green-600 dark:text-green-400'\n          )}>\n            {variant === 'default' && <TestTube className=\"h-5 w-5\" />}\n            {variant === 'styled'\n              ? `Tool Debug (last ${toolEvents.length} events)`\n              : 'Debug Console'\n            }\n          </CardTitle>\n          {variant === 'default' && (\n            <CardDescription>\n              Last {toolEvents.length} tool events and system information\n            </CardDescription>\n          )}\n        </CardHeader>\n        <CardContent className=\"space-y-4\">\n          <pre className={cn(\n            \"text-xs whitespace-pre-wrap overflow-x-auto\",\n            variant === 'styled' ? '' : 'bg-black text-green-400 p-4 rounded font-mono'\n          )}>\n            {JSON.stringify(toolEvents, null, 2)}\n          </pre>\n\n          {testResult && (\n            <>\n              {variant === 'styled' && <Separator className=\"bg-green-800\" />}\n              <div className={variant === 'default' ? 'mt-4' : ''}>\n                <h4 className={cn(\n                  \"font-medium mb-2\",\n                  variant === 'styled' ? 'font-bold text-green-400' : 'text-sm'\n                )}>\n                  Test Availability Result\n                </h4>\n                <div className={variant === 'styled' ? '' : 'bg-muted p-3 rounded'}>\n                  <pre className=\"text-xs whitespace-pre-wrap overflow-x-auto\">\n                    {JSON.stringify(testResult, null, 2)}\n                  </pre>\n                  {Array.isArray(testResult?.usedGoogleCalendars) && (\n                    <div className={cn(\n                      \"mt-2\",\n                      variant === 'styled' ? 'text-xs' : 'pt-2 border-t'\n                    )}>\n                      <strong className={variant === 'styled' ? '' : 'text-sm'}>\n                        Calendars considered:\n                      </strong>{' '}\n                      <span className={variant === 'styled' ? '' : 'text-sm text-muted-foreground'}>\n                        {testResult.usedGoogleCalendars.join(', ')}\n                      </span>\n                    </div>\n                  )}\n                </div>\n              </div>\n            </>\n          )}\n        </CardContent>\n      </Card>\n    )\n  }\n}\n\nfunction OrgBar({\n  org,\n  setOrg,\n  calendarId\n}: {\n  org: { id: string; name: string } | null\n  setOrg: (o: { id: string; name: string } | null) => void\n  calendarId: string\n}) {\n  const [manualId, setManualId] = useState('')\n  const [error, setError] = useState<string | null>(null)\n\n  useEffect(() => {\n    if (org) setError(null)\n  }, [org])\n\n  return (\n    <Card>\n      <CardHeader>\n        <CardTitle className=\"text-lg\">System Configuration</CardTitle>\n      </CardHeader>\n      <CardContent className=\"space-y-3\">\n        <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4 text-sm\">\n          <div>\n            <Label className=\"font-medium\">Calendar:</Label>\n            <div className=\"mt-1\">\n              <code className=\"text-sm bg-muted px-2 py-1 rounded\">{calendarId}</code>\n            </div>\n          </div>\n        </div>\n        {!org && (\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"org-id\">Manual Organization ID</Label>\n            <div className=\"flex gap-2\">\n              <input\n                id=\"org-id\"\n                className=\"flex-1 px-3 py-2 text-sm border border-input rounded-md bg-background\"\n                placeholder=\"Paste Organization ID\"\n                value={manualId}\n                onChange={(e) => setManualId(e.target.value)}\n              />\n              <Button\n                onClick={() => {\n                  if (manualId.trim()) setOrg({ id: manualId.trim(), name: 'Manual' })\n                  else setError('Organization ID is required')\n                }}\n                size=\"sm\"\n              >\n                Use This Org ID\n              </Button>\n            </div>\n            {error && (\n              <Alert>\n                <AlertDescription className=\"text-destructive\">{error}</AlertDescription>\n              </Alert>\n            )}\n          </div>\n        )}\n      </CardContent>\n    </Card>\n  )\n}\n\n// Export the unified VoiceAgent as VoiceAgentStyled for backward compatibility\nexport const VoiceAgentStyled = VoiceAgent\n\n// CalendarStatus moved to separate component file\n","/Users/rennychan/Personal Apps/contax/components/shared/providers.tsx",[],[],"/Users/rennychan/Personal Apps/contax/components/ui/alert.tsx",[],[],"/Users/rennychan/Personal Apps/contax/components/ui/badge.tsx",[],[],"/Users/rennychan/Personal Apps/contax/components/ui/button.tsx",[],[],"/Users/rennychan/Personal Apps/contax/components/ui/card.tsx",[],[],"/Users/rennychan/Personal Apps/contax/components/ui/checkbox.tsx",[],[],"/Users/rennychan/Personal Apps/contax/components/ui/collapsible.tsx",[],[],"/Users/rennychan/Personal Apps/contax/components/ui/dialog.tsx",[],[],"/Users/rennychan/Personal Apps/contax/components/ui/input.tsx",[],[],"/Users/rennychan/Personal Apps/contax/components/ui/label.tsx",[],[],"/Users/rennychan/Personal Apps/contax/components/ui/select.tsx",[],[],"/Users/rennychan/Personal Apps/contax/components/ui/separator.tsx",[],[],"/Users/rennychan/Personal Apps/contax/components/ui/switch.tsx",[],[],"/Users/rennychan/Personal Apps/contax/components/ui/textarea.tsx",[],[],"/Users/rennychan/Personal Apps/contax/components/ui/tooltip.tsx",[],[],"/Users/rennychan/Personal Apps/contax/lib/adapters/types.ts",[],[],"/Users/rennychan/Personal Apps/contax/lib/agent/openai-realtime.ts",["575","576","577","578","579","580","581","582","583","584","585","586","587","588","589","590","591","592","593","594","595","596","597","598","599"],["600","601","602"],"import type { AgentAdapter } from '../adapters/types'\nimport type {\n  ToolEvent,\n  AgentConnectionOptions,\n  AgentOptions,\n  RealtimeMessage,\n  TranscriptMessage,\n  ResponseStartedMessage,\n  ResponseDeltaMessage,\n  ResponseDoneMessage,\n  FunctionCallCreatedMessage,\n  FunctionCallArgumentsDeltaMessage,\n  FunctionCallArgumentsDoneMessage,\n  FunctionCallCompletedMessage,\n  CreateResponseMessage,\n  CreateConversationItemMessage,\n  ToolBuffer,\n  TimerHandle,\n  CheckAvailabilityArgs,\n  BookAppointmentArgs,\n  GetAvailableSlotsArgs\n} from '../../types/agent'\nimport type { TimeSlot } from '../../types/google'\n\nexport class OpenAIRealtimeAgent implements AgentAdapter {\n  private pc: RTCPeerConnection | null = null\n  private mic: MediaStream | null = null\n  private audioEl: HTMLAudioElement\n  private onTranscript?: (text: string) => void\n  private onAgentTranscript?: (text: string, final: boolean) => void\n  private currentAgentTranscript: string = ''\n  private toolArgsBuffers = new Map<string, { name: string; args: string }>()\n  private dataChannel: RTCDataChannel | null = null\n  private pendingMessages: RealtimeMessage[] = []\n  private defaultOrgId: string | undefined\n  private defaultCalendarId: string | undefined\n  private defaultAgentId: string | undefined\n  private toolHintSent = false\n  private onToolEvent?: (e: ToolEvent) => void\n  private onSlots?: (slots: Array<{ start: string; end: string }>, tz?: string) => void\n  private calendarIds: string[] | undefined\n  private awaitingTool: boolean = false\n  private awaitingToolTimer: TimerHandle = null\n  private fallbackTimer: TimerHandle = null\n  private lastTranscript: string = ''\n  private tz: string | undefined\n\n  constructor(opts?: AgentOptions) {\n    this.audioEl = new Audio()\n    this.onTranscript = opts?.onTranscript\n    this.onAgentTranscript = opts?.onAgentTranscript\n    this.onToolEvent = opts?.onToolEvent\n    this.onSlots = opts?.onSlots\n  }\n\n  setCalendarIds(ids: string[] | undefined) {\n    this.calendarIds = ids && ids.length ? [...ids] : undefined\n  }\n\n  private requireTool(name: 'check' | 'slots', opts?: { text?: string }) {\n    // Cancel any current generation and require a tool call\n    try { this.sendOAI({ type: 'response.cancel' }) } catch {}\n    const instructions =\n      name === 'slots'\n        ? 'User asked for day availability. Call getAvailableSlots with the requested date (YYYY-MM-DD). Do not state times unless they come from the tool result.'\n        : 'User asked for a specific time. Call checkAvailability with start at that exact local time and end=start+60 minutes (unless user specified a duration). Do not speak availability before tool result.'\n    this.sendOAI({ type: 'response.create', response: { instructions, tool_choice: 'required', modalities: ['audio', 'text'] } })\n    this.awaitingTool = true\n    if (this.awaitingToolTimer) clearTimeout(this.awaitingToolTimer)\n    this.awaitingToolTimer = setTimeout(() => {\n      if (this.awaitingTool) {\n        // Re-prompt once\n        this.sendOAI({ type: 'response.create', response: { instructions, tool_choice: 'required', modalities: ['audio', 'text'] } })\n      }\n    }, 2000)\n\n    // Fallback after 3500ms for specific-time queries: parse transcript and call API directly\n    if (name === 'check') {\n      if (this.fallbackTimer) clearTimeout(this.fallbackTimer)\n      this.fallbackTimer = setTimeout(() => {\n        if (!this.awaitingTool) return\n        const parsed = this.parseSlotFromTranscript(this.lastTranscript, this.tz)\n        if (!parsed) return\n        const organizationId = this.defaultOrgId\n        const calendarId = this.defaultCalendarId\n        const agentId = this.defaultAgentId\n        const apiUrl = agentId ? `/api/agents/${agentId}/calendar/check-availability` : '/api/calendar/check-availability'\n        fetch(apiUrl, {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({ organizationId, start: parsed.start, end: parsed.end, calendarId, calendarIds: this.calendarIds })\n        })\n          .then(async (r) => ({ ok: r.ok, j: await r.json().catch(() => ({})) }))\n          .then(({ ok, j }) => {\n            this.awaitingTool = false\n            if (ok && j?.available === true) {\n              this.speak(`That time is available: ${this.fmtRange(j.start || parsed.start, j.end || parsed.end, j.timeZone || this.tz)}. Should I book it?`)\n            } else if (ok && j?.available === false) {\n              const date = (j.start || parsed.start).slice(0, 10)\n              const slotsApiUrl = agentId ? `/api/agents/${agentId}/calendar/slots` : '/api/calendar/slots'\n              fetch(slotsApiUrl, {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({ date, slotMinutes: 60, calendarIds: this.calendarIds })\n              })\n                .then(async (r2) => ({ ok2: r2.ok, j2: await r2.json().catch(() => ({})) }))\n                .then(({ ok2, j2 }) => {\n                  if (ok2 && Array.isArray(j2?.slots) && j2.slots.length) {\n                    const list = j2.slots.slice(0, 5).map((it: any) => this.fmtRange(it.start, it.end, j2.timeZone || this.tz)).join(', ')\n                    this.speak(`That time is not available. Here are some options: ${list}.`)\n                  } else {\n                    this.speak('That time is not available and I could not retrieve alternative slots.')\n                  }\n                })\n            } else {\n              this.speak('I could not verify that time just now.')\n            }\n          })\n          .catch(() => this.speak('I could not verify that time just now.'))\n      }, 3500)\n    }\n  }\n\n  private speak(text: string) {\n    // Try to cancel any ongoing response first\n    try { this.sendOAI({ type: 'response.cancel' }) } catch {}\n    \n    // Report what we're trying to say\n    this.onToolEvent?.({ kind: 'event', type: 'spoken', text })\n    \n    // Tell OpenAI to speak EXACTLY this text\n    const exactInstructions = `Say exactly this and nothing else: \"${text.replace(/\"/g, '\\\\\"')}\"`\n    this.sendOAI({ \n      type: 'response.create', \n      response: { \n        instructions: exactInstructions,\n        modalities: ['audio', 'text'] \n      } \n    })\n  }\n\n  private parseSlotFromTranscript(transcript: string, tz?: string): { start: string; end: string } | null {\n    // Simple time parser for fallback - tries to extract a time from the transcript\n    const timeMatch = transcript.match(/\\b(\\d{1,2})(?::(\\d{2}))?\\s?(am|pm|AM|PM)?\\b/i)\n    if (!timeMatch) return null\n    \n    try {\n      const hours = parseInt(timeMatch[1])\n      const minutes = parseInt(timeMatch[2] || '0')\n      const isPM = /pm/i.test(timeMatch[3] || '')\n      \n      let hour24 = hours\n      if (isPM && hours !== 12) hour24 += 12\n      if (!isPM && hours === 12) hour24 = 0\n      \n      const now = new Date()\n      const slotDate = new Date(now)\n      slotDate.setHours(hour24, minutes, 0, 0)\n      \n      // If time is in the past, assume tomorrow\n      if (slotDate < now) {\n        slotDate.setDate(slotDate.getDate() + 1)\n      }\n      \n      const endDate = new Date(slotDate)\n      endDate.setHours(endDate.getHours() + 1)\n      \n      return {\n        start: slotDate.toISOString(),\n        end: endDate.toISOString()\n      }\n    } catch {\n      return null\n    }\n  }\n\n  private fmtTime(iso: string, tz?: string) {\n    try {\n      const d = new Date(iso)\n      const fmt = new Intl.DateTimeFormat('en-US', { timeZone: tz, hour: '2-digit', minute: '2-digit' })\n      return fmt.format(d)\n    } catch { return iso }\n  }\n\n  private fmtRange(startIso: string, endIso: string, tz?: string) {\n    return `${this.fmtTime(startIso, tz)}  ${this.fmtTime(endIso, tz)}`\n  }\n\n  async connect(\n    systemPrompt: string,\n    opts?: AgentConnectionOptions\n  ): Promise<void> {\n    const session = await fetch('/api/realtime/token', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        systemPrompt,\n        organizationId: opts?.organizationId,\n        calendarId: opts?.calendarId || 'primary',\n        greeting: opts?.greeting,\n        language: opts?.language || 'en-US',\n        timeZone: opts?.timeZone\n      })\n    }).then((r) => r.json())\n\n    if (!session?.client_secret?.value || !session?.model) {\n      throw new Error('Failed to obtain Realtime session')\n    }\n\n    this.defaultOrgId = opts?.organizationId\n    this.defaultCalendarId = opts?.calendarId || 'primary'\n    this.defaultAgentId = opts?.agentId\n    this.tz = opts?.timeZone\n\n    const pc = new RTCPeerConnection()\n    this.pc = pc\n    pc.ontrack = (e) => {\n      const [stream] = e.streams\n      this.audioEl.srcObject = stream\n      this.audioEl.play().catch(() => {})\n    }\n\n    // Receive events from OpenAI\n    pc.ondatachannel = (event) => {\n      const channel = event.channel\n      if (channel.label !== 'oai-events') return\n      // Prefer the inbound channel if OpenAI creates it.\n      this.attachDataChannel(channel)\n    }\n\n    const dc = pc.createDataChannel('oai-events')\n    this.attachDataChannel(dc)\n\n    this.mic = await navigator.mediaDevices.getUserMedia({ audio: true })\n    this.mic.getTracks().forEach((t) => pc.addTrack(t, this.mic!))\n\n    const offer = await pc.createOffer()\n    await pc.setLocalDescription(offer)\n    const baseUrl = 'https://api.openai.com/v1/realtime'\n    const sdpResponse = await fetch(`${baseUrl}?model=${encodeURIComponent(session.model)}`, {\n      method: 'POST',\n      headers: {\n        Authorization: `Bearer ${session.client_secret.value}`,\n        'Content-Type': 'application/sdp',\n        'OpenAI-Beta': 'realtime=v1'\n      },\n      body: offer.sdp\n    })\n    if (!sdpResponse.ok) {\n      const txt = await sdpResponse.text()\n      throw new Error(`Realtime SDP error: ${sdpResponse.status} ${txt}`)\n    }\n    const answer = { type: 'answer', sdp: await sdpResponse.text() } as RTCSessionDescriptionInit\n    await pc.setRemoteDescription(answer)\n\n    // Speak the explicit greeting first (if provided), without jumping into scheduling yet\n    if (opts?.greeting) {\n      const safe = opts.greeting.replace(/\"/g, '\\\\\"')\n      const greetOnly = `Say exactly: \"${safe}\". Then stop speaking and wait for the caller to respond.`\n      this.sendOAI({\n        type: 'response.create',\n        response: {\n          instructions: greetOnly,\n          modalities: ['audio', 'text']\n        }\n      })\n    }\n  }\n\n  async disconnect(): Promise<void> {\n    try {\n      this.sendOAI({ type: 'response.cancel' })\n    } catch {}\n    this.pc?.close()\n    this.pc = null\n    this.mic?.getTracks().forEach((t) => t.stop())\n    this.mic = null\n    this.toolArgsBuffers.clear()\n    this.dataChannel = null\n    this.pendingMessages = []\n  }\n\n  private handleOAIEvent = (raw: string | RealtimeMessage) => {\n    try {\n      const msg: RealtimeMessage = typeof raw === 'string' ? JSON.parse(raw) : raw\n      // Lightweight debug logging to help diagnose tool calling\n      if (msg?.type) {\n        const k = msg.type as string\n        if (\n          k.startsWith('response.function_call') ||\n          k.startsWith('response.output_text') ||\n          k === 'transcript'\n        ) {\n          // eslint-disable-next-line no-console\n          console.debug('[oai]', k)\n          this.onToolEvent?.({ kind: 'event', type: k })\n        }\n      }\n      // Simple transcript tap if present\n      if (msg.type === 'transcript') {\n        const transcriptMsg = msg as TranscriptMessage\n        this.lastTranscript = transcriptMsg.text\n        if (this.onTranscript) this.onTranscript(transcriptMsg.text)\n        // After first user transcript, arm tool usage with explicit guidance (once)\n        if (!this.toolHintSent) {\n          const toolHint = `Use tools for scheduling. When the caller mentions a specific time, call checkAvailability with start at that exact local time and end=start+60 minutes (unless the user requested a different duration). Do not check a whole day when a specific time was requested. If checkAvailability shows conflicts, do not proceed to booking; propose the next free times. Format dates as RFC3339 with timezone (e.g., 2025-09-10T10:00:00-04:00). Default organizationId=${this.defaultOrgId || 'unknown'}, calendarId=${this.defaultCalendarId || 'primary'}.`\n          this.sendOAI({\n            type: 'response.create',\n            response: { instructions: toolHint, tool_choice: 'auto', modalities: ['audio', 'text'] }\n          })\n          this.toolHintSent = true\n        }\n        // Heuristic: day availability question -> require getAvailableSlots\n        const t = (msg as TranscriptMessage).text.toLowerCase()\n        const hasTime = /\\b(\\d{1,2})(?::(\\d{2}))?\\s?(am|pm)?\\b/.test(t) || /\\bnoon\\b|\\bmidnight\\b/.test(t)\n        const dayQuery = /\\b(today|tomorrow|monday|tuesday|wednesday|thursday|friday|saturday|sunday|this\\s+week|availability|free|open)\\b/.test(t)\n        if (dayQuery && !hasTime) this.requireTool('slots')\n        if (hasTime) this.requireTool('check')\n      }\n\n      // Handle agent (assistant) transcript events\n      if (msg.type === 'response.started') {\n        // Clear transcript when a new response starts\n        this.currentAgentTranscript = ''\n      }\n      if (msg.type === 'response.audio_transcript.delta') {\n        const deltaMsg = msg as ResponseDeltaMessage\n        const delta = deltaMsg.delta || ''\n        this.currentAgentTranscript += delta\n        if (this.onAgentTranscript) {\n          this.onAgentTranscript(this.currentAgentTranscript, false)\n        }\n      }\n      if (msg.type === 'response.audio_transcript.done') {\n        const doneMsg = msg as ResponseDoneMessage\n        const final = doneMsg.transcript || this.currentAgentTranscript\n        this.currentAgentTranscript = ''\n        if (this.onAgentTranscript) {\n          this.onAgentTranscript(final, true)\n        }\n      }\n      // Also handle text output events (when audio is disabled)\n      if (msg.type === 'response.text.delta') {\n        const deltaMsg = msg as ResponseDeltaMessage\n        const delta = deltaMsg.delta || ''\n        this.currentAgentTranscript += delta\n        if (this.onAgentTranscript) {\n          this.onAgentTranscript(this.currentAgentTranscript, false)\n        }\n      }\n      if (msg.type === 'response.text.done') {\n        const doneMsg = msg as ResponseDoneMessage\n        const final = doneMsg.text || this.currentAgentTranscript\n        this.currentAgentTranscript = ''\n        if (this.onAgentTranscript) {\n          this.onAgentTranscript(final, true)\n        }\n      }\n\n      // Tool calling (function calling) handlers  support current and legacy event names\n      if (msg.type === 'response.function_call.created') {\n        // Capture the function name early so later delta/done events can find it\n        const createdMsg = msg as FunctionCallCreatedMessage\n        const callId = createdMsg.call_id || createdMsg.id\n        const name = createdMsg.name || 'unknown'\n        if (callId) {\n          const cur = this.toolArgsBuffers.get(callId) || { name, args: '' }\n          cur.name = name\n          this.toolArgsBuffers.set(callId, cur)\n          this.onToolEvent?.({ kind: 'event', type: 'response.function_call.created' })\n        }\n      }\n      if (\n        msg.type === 'response.function_call.arguments.delta' ||\n        msg.type === 'response.function_call_arguments.delta'\n      ) {\n        this.awaitingTool = false\n        const deltaMsg = msg as FunctionCallArgumentsDeltaMessage\n        const callId = deltaMsg.call_id || deltaMsg.id\n        const name = deltaMsg.name || (this.toolArgsBuffers.get(callId || '')?.name ?? 'unknown')\n        const delta = deltaMsg.delta || ''\n        if (!callId) return\n        const cur = this.toolArgsBuffers.get(callId) || { name, args: '' }\n        cur.args += delta\n        cur.name = name\n        this.toolArgsBuffers.set(callId, cur)\n      }\n      if (\n        msg.type === 'response.function_call.arguments.done' ||\n        msg.type === 'response.function_call_arguments.done'\n      ) {\n        this.awaitingTool = false\n        const doneMsg = msg as FunctionCallArgumentsDoneMessage\n        const callId = doneMsg.call_id || doneMsg.id\n        if (!callId) return\n        const buf = this.toolArgsBuffers.get(callId)\n        if (!buf) return\n        // eslint-disable-next-line no-console\n        console.debug('[oai] function_call.complete', buf.name)\n        this.invokeTool(callId, buf.name, buf.args)\n      }\n      if (msg.type === 'response.function_call.completed') {\n        this.awaitingTool = false\n        // Some backends emit a single completed event with full arguments\n        const completedMsg = msg as FunctionCallCompletedMessage\n        const callId = completedMsg.call_id || completedMsg.id\n        const name = completedMsg.name || 'unknown'\n        const args = completedMsg.arguments || this.toolArgsBuffers.get(callId || '')?.args || ''\n        if (!callId) return\n        // eslint-disable-next-line no-console\n        console.debug('[oai] function_call.completed', name)\n        this.invokeTool(callId, name, args)\n      }\n    } catch (e) {\n      // ignore parse errors\n    }\n  }\n\n  private async invokeTool(callId: string, name: string, argsJson: string) {\n    let args: CheckAvailabilityArgs | BookAppointmentArgs | GetAvailableSlotsArgs = {} as CheckAvailabilityArgs\n    try {\n      args = argsJson ? JSON.parse(argsJson) : {}\n    } catch {\n      // If parsing fails, return an error result\n      await this.sendToolResult(callId, { error: 'Invalid tool arguments' })\n      return\n    }\n\n    try {\n      // Heuristic mapping if model omitted the function name\n      let effective = name\n      if (!effective || effective === 'unknown') {\n        if (args && typeof args === 'object') {\n          if ('start' in args && 'end' in args && !('customer' in args)) effective = 'checkAvailability'\n          else if ('start' in args && 'end' in args && 'customer' in args) effective = 'bookAppointment'\n          else if ('date' in args) effective = 'getAvailableSlots'\n        }\n      }\n\n      this.onToolEvent?.({ kind: 'call', name: effective || name, args: argsJson })\n\n      if (effective === 'checkAvailability') {\n        const checkArgs = args as CheckAvailabilityArgs\n        const organizationId = checkArgs.organizationId || this.defaultOrgId\n        const calendarId = checkArgs.calendarId || this.defaultCalendarId\n        if (!checkArgs.start || !checkArgs.end) {\n          await this.sendToolResult(callId, { error: 'Missing start/end' })\n          return\n        }\n        const res = await (async () => {\n          const agentId = this.defaultAgentId\n          const apiUrl = agentId ? `/api/agents/${agentId}/calendar/check-availability` : '/api/calendar/check-availability'\n          const r = await fetch(apiUrl, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({ organizationId, start: checkArgs.start, end: checkArgs.end, calendarId, calendarIds: this.calendarIds })\n          })\n          try {\n            const j = await r.json()\n            return r.ok ? j : { error: 'http_error', status: r.status, detail: j }\n          } catch {\n            const t = await r.text().catch(() => '')\n            return { error: 'http_error', status: r.status, detail: t }\n          }\n        })()\n        this.onToolEvent?.({ kind: 'result', name: effective, result: res })\n        \n        // Process the result and prepare our response BEFORE sending tool result\n        let spokenResponse = ''\n        try {\n          if (res && typeof res === 'object' && 'error' in res && res.error === 'broad_window') {\n            // Don't speak, just trigger slots tool\n            await this.sendToolResult(callId, res)\n            this.requireTool('slots')\n            return\n          } else if (res && typeof res === 'object' && 'available' in res && res.available === true) {\n            const tz = 'timeZone' in res ? (res as any).timeZone : undefined\n            const s = ('start' in res ? (res as any).start : checkArgs.start) as string\n            const e = ('end' in res ? (res as any).end : checkArgs.end) as string\n            spokenResponse = `Yes, ${this.fmtRange(s, e, tz)} is available. Would you like me to book it?`\n          } else if (res && typeof res === 'object' && 'available' in res && res.available === false) {\n            const tz = 'timeZone' in res ? (res as any).timeZone : undefined\n            const requestedStart = ('start' in res ? (res as any).start : checkArgs.start) as string\n            const requestedEnd = ('end' in res ? (res as any).end : checkArgs.end) as string\n            const requestedTime = this.fmtRange(requestedStart, requestedEnd, tz)\n            \n            // Get alternative slots for the same day\n            const date = (requestedStart as string).slice(0, 10)\n            const agentId = this.defaultAgentId\n            const slotsApiUrl = agentId ? `/api/agents/${agentId}/calendar/slots` : '/api/calendar/slots'\n            const r2 = await fetch(slotsApiUrl, {\n              method: 'POST',\n              headers: { 'Content-Type': 'application/json' },\n              body: JSON.stringify({ date, slotMinutes: 60, calendarIds: this.calendarIds })\n            })\n            let j: { slots?: TimeSlot[]; timeZone?: string } | null = null\n            try { j = await r2.json() } catch {}\n            if (r2.ok && j?.slots?.length) {\n              const tz2 = j.timeZone\n              try { this.onSlots?.(j.slots, tz2) } catch {}\n              const list = j.slots.slice(0, 5).map((it) => this.fmtRange(it.start, it.end, tz2)).join(', ')\n              spokenResponse = `Sorry, ${requestedTime} is not available. The available times that day are: ${list}.`\n            } else {\n              spokenResponse = `Sorry, ${requestedTime} is not available and I could not retrieve alternative slots for that day.`\n            }\n          }\n        } catch {}\n        \n        // Send tool result with suppression flag, then speak our response\n        await this.sendToolResult(callId, res, true)\n        if (spokenResponse) {\n          this.speak(spokenResponse)\n        }\n      } else if (effective === 'bookAppointment') {\n        const bookArgs = args as BookAppointmentArgs\n        const organizationId = bookArgs.organizationId || this.defaultOrgId\n        const calendarId = bookArgs.calendarId || this.defaultCalendarId\n        if (!organizationId) {\n          await this.sendToolResult(callId, { error: 'Missing organizationId' })\n          return\n        }\n        const res = await (async () => {\n          const agentId = this.defaultAgentId\n          const apiUrl = agentId ? `/api/agents/${agentId}/appointments/book` : '/api/appointments/book'\n          const r = await fetch(apiUrl, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({ organizationId, customer: bookArgs.customer, start: bookArgs.start, end: bookArgs.end, notes: bookArgs.notes, calendarId })\n          })\n          try {\n            const j = await r.json()\n            return r.ok ? j : { error: 'http_error', status: r.status, detail: j }\n          } catch {\n            const t = await r.text().catch(() => '')\n            return { error: 'http_error', status: r.status, detail: t }\n          }\n        })()\n        this.onToolEvent?.({ kind: 'result', name: effective, result: res })\n        \n        // Prepare response before sending tool result\n        let spokenResponse = ''\n        try {\n          if (res && typeof res === 'object' && 'error' in res && res.error === 'conflict') {\n            spokenResponse = 'That time is busy. Would you like me to suggest alternatives?'\n          } else if (res && typeof res === 'object' && 'appointment' in res && res.appointment) {\n            const tz = 'timeZone' in res ? (res as any).timeZone : undefined\n            const s = ('start' in res ? (res as any).start : bookArgs.start) as string\n            const e = ('end' in res ? (res as any).end : bookArgs.end) as string\n            spokenResponse = `Perfect! I've booked ${this.fmtRange(s, e, tz)} for you. It's now on your calendar.`\n          }\n        } catch {}\n        \n        await this.sendToolResult(callId, res, true)\n        if (spokenResponse) {\n          this.speak(spokenResponse)\n        }\n      } else if (effective === 'getAvailableSlots') {\n        const slotsArgs = args as GetAvailableSlotsArgs\n        const organizationId = slotsArgs.organizationId || this.defaultOrgId\n        const res = await (async () => {\n          const agentId = this.defaultAgentId\n          const apiUrl = agentId ? `/api/agents/${agentId}/calendar/slots` : '/api/calendar/slots'\n          const r = await fetch(apiUrl, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({\n              organizationId,\n              date: slotsArgs.date,\n              slotMinutes: slotsArgs.slotMinutes,\n              businessHours: slotsArgs.businessHours,\n              calendarIds: this.calendarIds\n            })\n          })\n          try {\n            const j = await r.json()\n            return r.ok ? j : { error: 'http_error', status: r.status, detail: j }\n          } catch {\n            const t = await r.text().catch(() => '')\n            return { error: 'http_error', status: r.status, detail: t }\n          }\n        })()\n        this.onToolEvent?.({ kind: 'result', name: effective, result: res })\n        \n        // Prepare response before sending tool result\n        let spokenResponse = ''\n        try {\n          if (res && typeof res === 'object' && 'slots' in res && Array.isArray(res.slots)) {\n            const slotsRes = res as { slots: TimeSlot[]; timeZone?: string }\n            const tz = slotsRes.timeZone\n            try { this.onSlots?.(slotsRes.slots, tz) } catch {}\n            if (slotsRes.slots.length === 0) {\n              spokenResponse = 'No free slots found that day.'\n            } else {\n              const list = slotsRes.slots.slice(0, 5).map((it) => this.fmtRange(it.start, it.end, tz)).join(', ')\n              spokenResponse = `Available times are: ${list}.`\n            }\n          } else if (res && typeof res === 'object' && 'error' in res) {\n            spokenResponse = 'I could not retrieve the day availability at the moment.'\n          }\n        } catch {}\n        \n        await this.sendToolResult(callId, res, true)\n        if (spokenResponse) {\n          this.speak(spokenResponse)\n        }\n      } else {\n        const err = { error: `Unknown tool ${name || 'unknown'}` }\n        this.onToolEvent?.({ kind: 'result', name, result: err })\n        await this.sendToolResult(callId, err)\n      }\n    } catch (e) {\n      const err = { error: (e as Error).message }\n      this.onToolEvent?.({ kind: 'result', name, result: err })\n      await this.sendToolResult(callId, err)\n    }\n  }\n\n  private async sendToolResult(callId: string, result: unknown, suppressResponse: boolean = false) {\n    // Provide tool output to the model\n    const createItem = {\n      type: 'conversation.item.create',\n      item: {\n        type: 'function_call_output',\n        call_id: callId,\n        output: JSON.stringify(result)\n      }\n    }\n    this.sendOAI(createItem)\n    \n    // If we're going to speak deterministically, tell the AI to be quiet\n    if (suppressResponse) {\n      // Add a system message to prevent AI from speaking\n      const suppressMsg = {\n        type: 'conversation.item.create',\n        item: {\n          type: 'message',\n          role: 'system',\n          content: [{ type: 'text', text: 'Tool result has been processed. Agent will speak the response.' }]\n        }\n      }\n      this.sendOAI(suppressMsg)\n    }\n  }\n\n  private attachDataChannel(channel: RTCDataChannel) {\n    this.dataChannel = channel\n    channel.onmessage = (ev) => this.handleOAIEvent(ev.data)\n    channel.onopen = () => {\n      // Flush any queued messages once channel is open\n      if (this.pendingMessages.length) {\n        for (const msg of this.pendingMessages) {\n          try {\n            channel.send(JSON.stringify(msg))\n          } catch {\n            // ignore send failures\n          }\n        }\n        this.pendingMessages = []\n      }\n    }\n  }\n\n  private sendOAI(msg: RealtimeMessage) {\n    const dc = this.dataChannel\n    const payload = JSON.stringify(msg)\n    if (dc && dc.readyState === 'open') {\n      try {\n        dc.send(payload)\n      } catch {\n        // If send fails unexpectedly, queue it for retry on next open\n        this.pendingMessages.push(msg)\n      }\n    } else {\n      this.pendingMessages.push(msg)\n    }\n  }\n}\n","/Users/rennychan/Personal Apps/contax/lib/security/crypto.ts",["603","604","605"],[],"/**\n * Cryptographic utilities for secure data handling\n * Uses Web Crypto API for encryption/decryption of sensitive data\n */\n\nimport { createHash, randomBytes, createCipheriv, createDecipheriv } from 'crypto'\n\n// Get encryption key from environment or generate a warning\nconst getEncryptionKey = (): Buffer => {\n  const key = process.env.WEBHOOK_ENCRYPTION_KEY\n  \n  if (!key) {\n    // In production, this should throw an error\n    if (process.env.NODE_ENV === 'production') {\n      throw new Error('WEBHOOK_ENCRYPTION_KEY is required in production')\n    }\n    \n    // For development, use a default key (NOT SECURE - only for local dev)\n    console.warn('  Using default encryption key - SET WEBHOOK_ENCRYPTION_KEY in production!')\n    return Buffer.from('dev-only-key-change-in-production-123456789012', 'utf-8').slice(0, 32)\n  }\n  \n  // Ensure key is 32 bytes for AES-256\n  const keyBuffer = Buffer.from(key, 'hex')\n  if (keyBuffer.length !== 32) {\n    throw new Error('WEBHOOK_ENCRYPTION_KEY must be 32 bytes (64 hex characters)')\n  }\n  \n  return keyBuffer\n}\n\n/**\n * Encrypt sensitive data using AES-256-GCM\n * @param plaintext - The data to encrypt\n * @returns Encrypted data with IV and auth tag\n */\nexport async function encrypt(plaintext: string): Promise<string> {\n  try {\n    const key = getEncryptionKey()\n    \n    // Generate random IV (initialization vector)\n    const iv = randomBytes(16)\n    \n    // Create cipher\n    const cipher = createCipheriv('aes-256-gcm', key, iv)\n    \n    // Encrypt the data\n    let encrypted = cipher.update(plaintext, 'utf8', 'hex')\n    encrypted += cipher.final('hex')\n    \n    // Get the auth tag for integrity verification\n    const authTag = cipher.getAuthTag()\n    \n    // Combine IV, auth tag, and encrypted data\n    // Format: iv:authTag:encryptedData\n    return `${iv.toString('hex')}:${authTag.toString('hex')}:${encrypted}`\n  } catch (error) {\n    console.error('Encryption error:', error)\n    throw new Error('Failed to encrypt data')\n  }\n}\n\n/**\n * Decrypt data encrypted with encrypt()\n * @param encryptedData - The encrypted data string\n * @returns Decrypted plaintext\n */\nexport async function decrypt(encryptedData: string): Promise<string> {\n  try {\n    const key = getEncryptionKey()\n    \n    // Parse the encrypted data\n    const parts = encryptedData.split(':')\n    if (parts.length !== 3) {\n      throw new Error('Invalid encrypted data format')\n    }\n    \n    const [ivHex, authTagHex, encrypted] = parts\n    const iv = Buffer.from(ivHex, 'hex')\n    const authTag = Buffer.from(authTagHex, 'hex')\n    \n    // Create decipher\n    const decipher = createDecipheriv('aes-256-gcm', key, iv)\n    decipher.setAuthTag(authTag)\n    \n    // Decrypt the data\n    let decrypted = decipher.update(encrypted, 'hex', 'utf8')\n    decrypted += decipher.final('utf8')\n    \n    return decrypted\n  } catch (error) {\n    console.error('Decryption error:', error)\n    throw new Error('Failed to decrypt data')\n  }\n}\n\n/**\n * Generate a cryptographically secure random token\n * @param bytes - Number of random bytes (default 32)\n * @returns URL-safe base64 encoded token\n */\nexport function generateSecureToken(bytes: number = 32): string {\n  const buffer = randomBytes(bytes)\n  // Make it URL-safe by replacing non-URL-safe characters\n  return buffer\n    .toString('base64')\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n    .replace(/=/g, '')\n}\n\n/**\n * Generate a secure webhook secret\n * @returns Hex-encoded secret (96 characters)\n */\nexport function generateWebhookSecret(): string {\n  // 48 bytes = 384 bits of entropy (very secure)\n  return randomBytes(48).toString('hex')\n}\n\n/**\n * Hash a value using SHA-256\n * @param value - Value to hash\n * @returns Hex-encoded hash\n */\nexport function hashSHA256(value: string): string {\n  return createHash('sha256').update(value).digest('hex')\n}\n\n/**\n * Constant-time string comparison to prevent timing attacks\n * @param a - First string\n * @param b - Second string\n * @returns True if strings are equal\n */\nexport function secureCompare(a: string, b: string): boolean {\n  if (a.length !== b.length) {\n    return false\n  }\n  \n  let result = 0\n  for (let i = 0; i < a.length; i++) {\n    result |= a.charCodeAt(i) ^ b.charCodeAt(i)\n  }\n  \n  return result === 0\n}\n\n/**\n * Verify a webhook signature (HMAC-SHA256)\n * @param payload - Request body as string\n * @param signature - Signature from webhook header\n * @param secret - Webhook secret\n * @returns True if signature is valid\n */\nexport function verifyWebhookSignature(\n  payload: string,\n  signature: string,\n  secret: string\n): boolean {\n  if (!signature || !secret) {\n    return false\n  }\n  \n  // Calculate expected signature\n  const hmac = createHash('sha256')\n  hmac.update(secret + payload)\n  const expectedSignature = hmac.digest('hex')\n  \n  // Use constant-time comparison\n  return secureCompare(signature, expectedSignature)\n}\n\n/**\n * Generate a secure encryption key for first-time setup\n * @returns Hex-encoded 32-byte key for AES-256\n */\nexport function generateEncryptionKey(): string {\n  return randomBytes(32).toString('hex')\n}","/Users/rennychan/Personal Apps/contax/lib/security/rate-limiter.ts",["606"],[],"/**\n * Simple in-memory rate limiter for Next.js API routes\n * Tracks requests by IP address with configurable limits and time windows\n */\n\ninterface RateLimitEntry {\n  count: number\n  resetTime: number\n}\n\ninterface RateLimitConfig {\n  /** Maximum number of requests allowed in the time window */\n  maxRequests: number\n  /** Time window in seconds */\n  windowSeconds: number\n  /** Optional custom identifier function (default: uses IP address) */\n  getIdentifier?: (request: Request) => string | null\n}\n\ninterface RateLimitResult {\n  /** Whether the request should be allowed */\n  allowed: boolean\n  /** Number of remaining requests in the current window */\n  remaining: number\n  /** Unix timestamp when the rate limit window resets */\n  resetTime: number\n  /** Total number of requests allowed per window */\n  limit: number\n  /** Error message if rate limit exceeded */\n  error?: string\n}\n\n/**\n * In-memory storage for rate limit tracking\n * In production, consider using Redis or similar for multi-instance deployments\n */\nconst rateLimitMap = new Map<string, RateLimitEntry>()\n\n/**\n * Clean up expired entries periodically\n */\nlet lastCleanup = Date.now()\nconst CLEANUP_INTERVAL = 300000 // 5 minutes\n\nfunction cleanupExpiredEntries() {\n  const now = Date.now()\n\n  // Only cleanup every 5 minutes to avoid performance impact\n  if (now - lastCleanup < CLEANUP_INTERVAL) {\n    return\n  }\n\n  const currentTime = Math.floor(now / 1000)\n\n  for (const [key, entry] of rateLimitMap.entries()) {\n    if (entry.resetTime < currentTime) {\n      rateLimitMap.delete(key)\n    }\n  }\n\n  lastCleanup = now\n}\n\n/**\n * Extract client identifier from request\n * Falls back to various headers if x-forwarded-for is not available\n */\nfunction getClientIdentifier(request: Request): string {\n  // Check for forwarded IP (common in proxied environments)\n  const forwardedFor = request.headers.get('x-forwarded-for')\n  if (forwardedFor) {\n    // Take the first IP in case of comma-separated list\n    return forwardedFor.split(',')[0].trim()\n  }\n\n  // Check for real IP header (used by some proxies)\n  const realIP = request.headers.get('x-real-ip')\n  if (realIP) {\n    return realIP\n  }\n\n  // Check for Cloudflare connecting IP\n  const cfIP = request.headers.get('cf-connecting-ip')\n  if (cfIP) {\n    return cfIP\n  }\n\n  // Fallback to user agent + limited headers fingerprint\n  const userAgent = request.headers.get('user-agent') || 'unknown'\n  const acceptLang = request.headers.get('accept-language') || 'unknown'\n\n  return `fallback:${Buffer.from(userAgent + acceptLang).toString('base64').slice(0, 16)}`\n}\n\n/**\n * Check if a request should be rate limited\n *\n * @param request - The incoming request object\n * @param config - Rate limit configuration\n * @returns RateLimitResult indicating if request is allowed\n */\nexport function checkRateLimit(request: Request, config: RateLimitConfig): RateLimitResult {\n  cleanupExpiredEntries()\n\n  const currentTime = Math.floor(Date.now() / 1000)\n  const resetTime = currentTime + config.windowSeconds\n\n  // Get client identifier\n  const identifier = config.getIdentifier\n    ? config.getIdentifier(request)\n    : getClientIdentifier(request)\n\n  if (!identifier) {\n    // If we can't identify the client, allow the request but log a warning\n    console.warn('Rate limiter: Unable to identify client, allowing request')\n    return {\n      allowed: true,\n      remaining: config.maxRequests - 1,\n      resetTime,\n      limit: config.maxRequests\n    }\n  }\n\n  const key = `ratelimit:${identifier}`\n  const existing = rateLimitMap.get(key)\n\n  // If no existing entry or window has expired, create new entry\n  if (!existing || existing.resetTime < currentTime) {\n    rateLimitMap.set(key, {\n      count: 1,\n      resetTime\n    })\n\n    return {\n      allowed: true,\n      remaining: config.maxRequests - 1,\n      resetTime,\n      limit: config.maxRequests\n    }\n  }\n\n  // Check if limit exceeded\n  if (existing.count >= config.maxRequests) {\n    return {\n      allowed: false,\n      remaining: 0,\n      resetTime: existing.resetTime,\n      limit: config.maxRequests,\n      error: `Rate limit exceeded. Maximum ${config.maxRequests} requests per ${config.windowSeconds} seconds.`\n    }\n  }\n\n  // Increment count and allow request\n  existing.count++\n  rateLimitMap.set(key, existing)\n\n  return {\n    allowed: true,\n    remaining: config.maxRequests - existing.count,\n    resetTime: existing.resetTime,\n    limit: config.maxRequests\n  }\n}\n\n/**\n * Predefined rate limit configurations for common use cases\n */\nexport const RateLimitPresets = {\n  /** Very strict limits for sensitive endpoints */\n  strict: {\n    maxRequests: 5,\n    windowSeconds: 60, // 5 requests per minute\n  },\n\n  /** Standard limits for API endpoints */\n  standard: {\n    maxRequests: 30,\n    windowSeconds: 60, // 30 requests per minute\n  },\n\n  /** Generous limits for public endpoints */\n  generous: {\n    maxRequests: 100,\n    windowSeconds: 60, // 100 requests per minute\n  },\n\n  /** Webhook specific limits (fewer requests, longer window) */\n  webhook: {\n    maxRequests: 10,\n    windowSeconds: 300, // 10 requests per 5 minutes\n  },\n\n  /** OAuth callback limits */\n  oauth: {\n    maxRequests: 5,\n    windowSeconds: 300, // 5 requests per 5 minutes\n  }\n} as const\n\n/**\n * Helper function to apply rate limiting to a Next.js API route\n *\n * @param request - The Next.js request object\n * @param config - Rate limit configuration\n * @returns Response object if rate limited, null if request should proceed\n */\nexport function rateLimitMiddleware(\n  request: Request,\n  config: RateLimitConfig\n): Response | null {\n  const result = checkRateLimit(request, config)\n\n  if (!result.allowed) {\n    return new Response(JSON.stringify({\n      error: 'Rate Limit Exceeded',\n      message: result.error,\n      retryAfter: result.resetTime - Math.floor(Date.now() / 1000)\n    }), {\n      status: 429,\n      headers: {\n        'Content-Type': 'application/json',\n        'X-RateLimit-Limit': result.limit.toString(),\n        'X-RateLimit-Remaining': result.remaining.toString(),\n        'X-RateLimit-Reset': result.resetTime.toString(),\n        'Retry-After': (result.resetTime - Math.floor(Date.now() / 1000)).toString()\n      }\n    })\n  }\n\n  // Add rate limit headers to successful responses\n  return null // Allow request to proceed\n}\n\n/**\n * Add rate limit headers to a response\n *\n * @param response - The response to add headers to\n * @param result - Rate limit result\n */\nexport function addRateLimitHeaders(response: Response, result: RateLimitResult): Response {\n  const headers = new Headers(response.headers)\n  headers.set('X-RateLimit-Limit', result.limit.toString())\n  headers.set('X-RateLimit-Remaining', result.remaining.toString())\n  headers.set('X-RateLimit-Reset', result.resetTime.toString())\n\n  return new Response(response.body, {\n    status: response.status,\n    statusText: response.statusText,\n    headers\n  })\n}\n\n/**\n * Clear rate limit data for a specific identifier\n * Useful for testing or manual overrides\n */\nexport function clearRateLimit(identifier: string): boolean {\n  const key = `ratelimit:${identifier}`\n  return rateLimitMap.delete(key)\n}\n\n/**\n * Get current rate limit status for an identifier\n * Useful for debugging or monitoring\n */\nexport function getRateLimitStatus(identifier: string): RateLimitEntry | null {\n  const key = `ratelimit:${identifier}`\n  return rateLimitMap.get(key) || null\n}","/Users/rennychan/Personal Apps/contax/lib/security/webhook-auth.ts",[],[],"/Users/rennychan/Personal Apps/contax/lib/security/webhook-test-helper.ts",["607","608","609","610","611","612","613","614","615","616"],[],"#!/usr/bin/env node\n\n/**\n * Webhook signature test helper\n *\n * This utility helps generate valid webhook signatures for testing the webhook endpoint.\n * It can be used during development to verify that the HMAC validation is working correctly.\n */\n\nimport { generateWebhookSignature } from './webhook-auth';\n\n/**\n * Interface for webhook test configuration\n */\nexport interface WebhookTestConfig {\n  /** The webhook secret key */\n  secret: string;\n  /** The JSON payload to send */\n  payload: Record<string, any>;\n  /** Optional custom timestamp (default: current time) */\n  timestamp?: string;\n  /** The webhook endpoint URL */\n  url?: string;\n}\n\n/**\n * Generate headers and payload for testing webhook signature validation\n *\n * @param config - Test configuration\n * @returns Object containing headers, body, and curl command for testing\n */\nexport function generateWebhookTest(config: WebhookTestConfig) {\n  // Use current timestamp if not provided\n  const timestamp = config.timestamp || Date.now().toString();\n\n  // Convert payload to JSON string\n  const rawBody = JSON.stringify(config.payload);\n\n  // Generate signature\n  const signature = generateWebhookSignature(rawBody, timestamp, config.secret);\n\n  // Prepare headers\n  const headers = {\n    'Content-Type': 'application/json',\n    'x-signature': signature,\n    'x-timestamp': timestamp\n  };\n\n  // Generate curl command for testing\n  const url = config.url || 'http://localhost:3000/api/webhook/trigger-call';\n  const curlCommand = `curl -X POST \"${url}\" \\\\\n  -H \"Content-Type: application/json\" \\\\\n  -H \"x-signature: ${signature}\" \\\\\n  -H \"x-timestamp: ${timestamp}\" \\\\\n  -d '${rawBody}'`;\n\n  return {\n    headers,\n    body: rawBody,\n    curlCommand,\n    timestamp,\n    signature\n  };\n}\n\n/**\n * Example test payloads for different webhook sources\n */\nexport const testPayloads = {\n  simple: {\n    phoneNumber: '+1234567890',\n    organizationId: 'org-123'\n  },\n\n  hubspot: {\n    hs_phone: '+1234567890',\n    hs_company_id: 'org-456',\n    firstname: 'John',\n    lastname: 'Doe'\n  },\n\n  zapier: {\n    phone: '+1234567890',\n    orgId: 'org-789',\n    customerName: 'Jane Smith'\n  },\n\n  nested: {\n    data: {\n      phone: '+1234567890',\n      organizationId: 'org-101112'\n    },\n    meta: {\n      source: 'custom-webhook',\n      version: '1.0'\n    }\n  }\n};\n\n/**\n * Run webhook signature test - for command line usage\n */\nexport function runWebhookTest() {\n  const secret = process.env.WEBHOOK_SECRET;\n  if (!secret) {\n    console.error(' WEBHOOK_SECRET environment variable is not set');\n    process.exit(1);\n  }\n\n  console.log(' Webhook Signature Test Helper\\n');\n\n  // Test with different payloads\n  Object.entries(testPayloads).forEach(([name, payload]) => {\n    console.log(` Test: ${name.toUpperCase()}`);\n    console.log('Payload:', JSON.stringify(payload, null, 2));\n\n    const test = generateWebhookTest({\n      secret,\n      payload,\n      url: process.env.WEBHOOK_URL || 'http://localhost:3000/api/webhook/trigger-call'\n    });\n\n    console.log('Headers:');\n    Object.entries(test.headers).forEach(([key, value]) => {\n      console.log(`  ${key}: ${value}`);\n    });\n\n    console.log('\\nCurl command:');\n    console.log(test.curlCommand);\n    console.log('\\n' + '='.repeat(80) + '\\n');\n  });\n}\n\n// Run if called directly (not imported)\nif (require.main === module) {\n  runWebhookTest();\n}","/Users/rennychan/Personal Apps/contax/lib/security/webhook.ts",["617","618","619","620","621","622","623","624","625"],[],"/**\n * Webhook security utilities for request validation and rate limiting\n */\n\nimport { createClient } from '@supabase/supabase-js'\nimport { NextRequest } from 'next/server'\nimport { decrypt, secureCompare, verifyWebhookSignature } from './crypto'\n\n// Types for webhook validation\nexport interface WebhookValidationResult {\n  valid: boolean\n  organizationId?: string\n  error?: string\n  shouldLogFailure?: boolean\n}\n\nexport interface WebhookOrganization {\n  id: string\n  name: string\n  webhook_token: string\n  webhook_secret_encrypted: string\n  webhook_enabled: boolean\n  webhook_failures: number\n  webhook_rate_limit_per_minute: number\n  webhook_rate_limit_per_hour: number\n}\n\nexport interface WebhookLogEntry {\n  organization_id: string\n  webhook_token: string\n  ip_address: string\n  user_agent: string | null\n  request_headers: Record<string, any>\n  request_body: any\n  response_status: number\n  error_message?: string\n  processing_time_ms: number\n  success: boolean\n}\n\n/**\n * Extract client IP address from request\n * Handles various proxy headers\n */\nfunction getClientIp(req: NextRequest): string {\n  // Check various headers that might contain the real IP\n  const forwardedFor = req.headers.get('x-forwarded-for')\n  if (forwardedFor) {\n    // x-forwarded-for may contain multiple IPs, take the first one\n    return forwardedFor.split(',')[0].trim()\n  }\n  \n  // Other common headers\n  const realIp = req.headers.get('x-real-ip')\n  if (realIp) return realIp\n  \n  const clientIp = req.headers.get('x-client-ip')\n  if (clientIp) return clientIp\n  \n  // Fallback to remote address (may not be available in some environments)\n  return '0.0.0.0'\n}\n\n/**\n * Validate webhook request from an organization\n * @param token - Webhook token from URL\n * @param request - Next.js request object\n * @param requestBody - Parsed request body\n * @returns Validation result with organization details\n */\nexport async function validateWebhookRequest(\n  token: string,\n  request: NextRequest,\n  requestBody: any\n): Promise<WebhookValidationResult> {\n  const startTime = Date.now()\n  \n  // Initialize Supabase client with service role for admin access\n  const supabase = createClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.SUPABASE_SERVICE_ROLE_KEY!,\n    { auth: { persistSession: false } }\n  )\n  \n  try {\n    // Validate token format (should be URL-safe base64)\n    if (!token || !/^[A-Za-z0-9_-]+$/.test(token)) {\n      return {\n        valid: false,\n        error: 'Invalid webhook token format',\n        shouldLogFailure: false\n      }\n    }\n    \n    // Look up organization by webhook token\n    const { data: org, error: orgError } = await supabase\n      .from('organizations')\n      .select('*')\n      .eq('webhook_token', token)\n      .single()\n    \n    if (orgError || !org) {\n      return {\n        valid: false,\n        error: 'Invalid webhook token',\n        shouldLogFailure: true\n      }\n    }\n    \n    const organization = org as WebhookOrganization\n    \n    // Check if webhook is enabled\n    if (!organization.webhook_enabled) {\n      await logWebhookAttempt(supabase, {\n        organization_id: organization.id,\n        webhook_token: token,\n        ip_address: getClientIp(request),\n        user_agent: request.headers.get('user-agent'),\n        request_headers: Object.fromEntries(request.headers.entries()),\n        request_body: requestBody,\n        response_status: 403,\n        error_message: 'Webhook disabled',\n        processing_time_ms: Date.now() - startTime,\n        success: false\n      })\n      \n      return {\n        valid: false,\n        organizationId: organization.id,\n        error: 'Webhook is disabled for this organization',\n        shouldLogFailure: false\n      }\n    }\n    \n    // Check if webhook has been auto-disabled due to failures\n    if (organization.webhook_failures >= (parseInt(process.env.WEBHOOK_MAX_FAILURES || '5'))) {\n      await logWebhookAttempt(supabase, {\n        organization_id: organization.id,\n        webhook_token: token,\n        ip_address: getClientIp(request),\n        user_agent: request.headers.get('user-agent'),\n        request_headers: Object.fromEntries(request.headers.entries()),\n        request_body: requestBody,\n        response_status: 403,\n        error_message: 'Webhook auto-disabled due to failures',\n        processing_time_ms: Date.now() - startTime,\n        success: false\n      })\n      \n      return {\n        valid: false,\n        organizationId: organization.id,\n        error: 'Webhook has been auto-disabled due to multiple failures',\n        shouldLogFailure: false\n      }\n    }\n    \n    // Verify webhook secret\n    const providedSecret = request.headers.get('x-webhook-secret') || \n                          request.headers.get('authorization')?.replace('Bearer ', '') ||\n                          requestBody.webhook_secret\n    \n    if (!providedSecret) {\n      await incrementWebhookFailures(supabase, organization.id)\n      await logWebhookAttempt(supabase, {\n        organization_id: organization.id,\n        webhook_token: token,\n        ip_address: getClientIp(request),\n        user_agent: request.headers.get('user-agent'),\n        request_headers: Object.fromEntries(request.headers.entries()),\n        request_body: requestBody,\n        response_status: 401,\n        error_message: 'Missing webhook secret',\n        processing_time_ms: Date.now() - startTime,\n        success: false\n      })\n      \n      return {\n        valid: false,\n        organizationId: organization.id,\n        error: 'Missing webhook secret',\n        shouldLogFailure: true\n      }\n    }\n    \n    // Decrypt stored secret and compare\n    let decryptedSecret: string\n    try {\n      decryptedSecret = await decrypt(organization.webhook_secret_encrypted)\n    } catch (decryptError) {\n      console.error('Failed to decrypt webhook secret:', decryptError)\n      return {\n        valid: false,\n        organizationId: organization.id,\n        error: 'Internal security error',\n        shouldLogFailure: false\n      }\n    }\n    \n    // Use constant-time comparison to prevent timing attacks\n    if (!secureCompare(providedSecret, decryptedSecret)) {\n      await incrementWebhookFailures(supabase, organization.id)\n      await logWebhookAttempt(supabase, {\n        organization_id: organization.id,\n        webhook_token: token,\n        ip_address: getClientIp(request),\n        user_agent: request.headers.get('user-agent'),\n        request_headers: Object.fromEntries(request.headers.entries()),\n        request_body: requestBody,\n        response_status: 401,\n        error_message: 'Invalid webhook secret',\n        processing_time_ms: Date.now() - startTime,\n        success: false\n      })\n      \n      return {\n        valid: false,\n        organizationId: organization.id,\n        error: 'Invalid webhook secret',\n        shouldLogFailure: true\n      }\n    }\n    \n    // Check rate limits\n    const { data: rateLimitOk, error: rateLimitError } = await supabase\n      .rpc('check_webhook_rate_limit', {\n        p_organization_id: organization.id,\n        p_minute_limit: organization.webhook_rate_limit_per_minute,\n        p_hour_limit: organization.webhook_rate_limit_per_hour\n      })\n    \n    if (rateLimitError || !rateLimitOk) {\n      await logWebhookAttempt(supabase, {\n        organization_id: organization.id,\n        webhook_token: token,\n        ip_address: getClientIp(request),\n        user_agent: request.headers.get('user-agent'),\n        request_headers: Object.fromEntries(request.headers.entries()),\n        request_body: requestBody,\n        response_status: 429,\n        error_message: 'Rate limit exceeded',\n        processing_time_ms: Date.now() - startTime,\n        success: false\n      })\n      \n      return {\n        valid: false,\n        organizationId: organization.id,\n        error: 'Rate limit exceeded',\n        shouldLogFailure: false\n      }\n    }\n    \n    // Reset failure count on successful validation\n    if (organization.webhook_failures > 0) {\n      await supabase\n        .from('organizations')\n        .update({ \n          webhook_failures: 0,\n          webhook_last_failure_at: null\n        })\n        .eq('id', organization.id)\n    }\n    \n    // Log successful validation\n    await logWebhookAttempt(supabase, {\n      organization_id: organization.id,\n      webhook_token: token,\n      ip_address: getClientIp(request),\n      user_agent: request.headers.get('user-agent'),\n      request_headers: Object.fromEntries(request.headers.entries()),\n      request_body: requestBody,\n      response_status: 200,\n      processing_time_ms: Date.now() - startTime,\n      success: true\n    })\n    \n    return {\n      valid: true,\n      organizationId: organization.id\n    }\n    \n  } catch (error) {\n    console.error('Webhook validation error:', error)\n    return {\n      valid: false,\n      error: 'Internal validation error',\n      shouldLogFailure: false\n    }\n  }\n}\n\n/**\n * Log webhook attempt for audit trail\n */\nasync function logWebhookAttempt(\n  supabase: any,\n  logEntry: WebhookLogEntry\n): Promise<void> {\n  try {\n    // Don't log sensitive data in production\n    if (process.env.NODE_ENV === 'production') {\n      // Redact sensitive headers\n      const sanitizedHeaders = { ...logEntry.request_headers }\n      delete sanitizedHeaders['authorization']\n      delete sanitizedHeaders['x-webhook-secret']\n      delete sanitizedHeaders['cookie']\n      \n      // Redact sensitive body fields\n      const sanitizedBody = logEntry.request_body ? { ...logEntry.request_body } : {}\n      delete sanitizedBody['webhook_secret']\n      delete sanitizedBody['password']\n      delete sanitizedBody['token']\n      \n      logEntry.request_headers = sanitizedHeaders\n      logEntry.request_body = sanitizedBody\n    }\n    \n    await supabase\n      .from('webhook_logs')\n      .insert(logEntry)\n  } catch (error) {\n    console.error('Failed to log webhook attempt:', error)\n    // Don't throw - logging failure shouldn't break the webhook\n  }\n}\n\n/**\n * Increment webhook failure count\n */\nasync function incrementWebhookFailures(\n  supabase: any,\n  organizationId: string\n): Promise<void> {\n  try {\n    await supabase.rpc('increment', {\n      table_name: 'organizations',\n      column_name: 'webhook_failures',\n      row_id: organizationId\n    })\n    \n    await supabase\n      .from('organizations')\n      .update({ webhook_last_failure_at: new Date().toISOString() })\n      .eq('id', organizationId)\n    \n    // Check if we should auto-disable\n    const { data: org } = await supabase\n      .from('organizations')\n      .select('webhook_failures')\n      .eq('id', organizationId)\n      .single()\n    \n    const maxFailures = parseInt(process.env.WEBHOOK_MAX_FAILURES || '5')\n    if (org && org.webhook_failures >= maxFailures) {\n      await supabase\n        .from('organizations')\n        .update({ \n          webhook_enabled: false,\n          webhook_auto_disabled_at: new Date().toISOString()\n        })\n        .eq('id', organizationId)\n    }\n  } catch (error) {\n    console.error('Failed to increment webhook failures:', error)\n  }\n}\n\n/**\n * Validate webhook signature for services that support it (GitHub, Stripe style)\n */\nexport function validateWebhookHMAC(\n  payload: string,\n  signature: string,\n  secret: string\n): boolean {\n  return verifyWebhookSignature(payload, signature, secret)\n}","/Users/rennychan/Personal Apps/contax/lib/services/agent-calendar.ts",["626","627","628","629","630","631","632","633","634","635","636","637","638"],[],"import { cookies } from 'next/headers';\nimport { createServerClient } from '@supabase/ssr';\nimport { refreshGoogleAccessToken } from './google';\n\nasync function createClient() {\n  const cookieStore = await cookies();\n  return createServerClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n    {\n      cookies: {\n        getAll() {\n          return cookieStore.getAll();\n        },\n        setAll(cookiesToSet) {\n          try {\n            cookiesToSet.forEach(({ name, value, options }) => {\n              cookieStore.set(name, value, options);\n            });\n          } catch (error) {\n            console.error('Error setting cookies:', error);\n          }\n        },\n      },\n    }\n  );\n}\n\nexport interface AgentCalendarIntegration {\n  access_token: string | null;\n  refresh_token: string | null;\n  token_expiry: bigint | null;\n  is_expired: boolean | null;\n  calendar_email: string | null;\n  calendar_id: string | null;\n  connected: boolean | null;\n}\n\n/**\n * Get calendar tokens for a specific agent\n */\nexport async function getAgentCalendarTokens(agentId: string): Promise<AgentCalendarIntegration | null> {\n  const supabase = await createClient();\n  \n  const { data, error } = await supabase\n    .rpc('get_agent_google_tokens', { p_agent_id: agentId })\n    .single();\n    \n  if (error || !data) {\n    console.error('Error getting agent calendar tokens:', error);\n    return null;\n  }\n  \n  // Check if token needs refresh\n  const tokenData = data as AgentCalendarIntegration;\n  if (tokenData.is_expired && tokenData.refresh_token) {\n    return await refreshAgentToken(agentId, tokenData);\n  }\n  \n  return tokenData;\n}\n\n/**\n * Refresh expired agent calendar token\n */\nexport async function refreshAgentToken(\n  agentId: string, \n  integration: AgentCalendarIntegration\n): Promise<AgentCalendarIntegration | null> {\n  if (!integration.refresh_token) {\n    console.error('No refresh token available for agent:', agentId);\n    return null;\n  }\n  \n  const newTokenData = await refreshGoogleAccessToken(\n    integration.refresh_token,\n    process.env.GOOGLE_CLIENT_ID!,\n    process.env.GOOGLE_CLIENT_SECRET!\n  );\n  \n  if (!newTokenData) {\n    console.error('Failed to refresh token for agent:', agentId);\n    return null;\n  }\n  \n  // Store updated tokens in database\n  const supabase = await createClient();\n  const { data, error } = await supabase.rpc('store_agent_google_tokens', {\n    p_agent_id: agentId,\n    p_access_token: newTokenData.access_token,\n    p_refresh_token: (newTokenData as any).refresh_token || integration.refresh_token,\n    p_expires_in: newTokenData.expires_in,\n    p_email: integration.calendar_email,\n    p_calendar_id: integration.calendar_id\n  });\n  \n  if (error) {\n    console.error('Error storing refreshed tokens:', error);\n    return null;\n  }\n  \n  // Return updated tokens\n  return await getAgentCalendarTokens(agentId);\n}\n\n/**\n * Store new calendar tokens for an agent\n */\nexport async function storeAgentCalendarTokens(\n  agentId: string,\n  accessToken: string,\n  refreshToken: string,\n  expiresIn: number,\n  email?: string,\n  calendarId?: string\n): Promise<boolean> {\n  const supabase = await createClient();\n  \n  const { data, error } = await supabase.rpc('store_agent_google_tokens', {\n    p_agent_id: agentId,\n    p_access_token: accessToken,\n    p_refresh_token: refreshToken,\n    p_expires_in: expiresIn,\n    p_email: email || null,\n    p_calendar_id: calendarId || null\n  });\n  \n  if (error) {\n    console.error('Error storing agent calendar tokens:', error);\n    return false;\n  }\n  \n  return !!data;\n}\n\n/**\n * Disconnect calendar integration for an agent\n */\nexport async function disconnectAgentCalendar(agentId: string): Promise<boolean> {\n  const supabase = await createClient();\n  \n  const { data, error } = await supabase.rpc('disconnect_agent_google_calendar', {\n    p_agent_id: agentId\n  });\n  \n  if (error) {\n    console.error('Error disconnecting agent calendar:', error);\n    return false;\n  }\n  \n  return !!data;\n}\n\n/**\n * Validate agent access for a user\n */\nexport async function validateAgentAccess(\n  agentId: string,\n  userId: string\n): Promise<{ agent: any; organization: any } | null> {\n  const supabase = await createClient();\n  \n  const { data: agent, error } = await supabase\n    .from('agent_configurations')\n    .select(`\n      *,\n      organizations!inner (\n        id,\n        name,\n        organization_members!inner (\n          user_id,\n          role\n        )\n      )\n    `)\n    .eq('id', agentId)\n    .eq('organizations.organization_members.user_id', userId)\n    .single();\n    \n  if (error || !agent) {\n    return null;\n  }\n  \n  return {\n    agent,\n    organization: agent.organizations\n  };\n}\n\n/**\n * Get agent configuration with calendar status\n */\nexport async function getAgentWithCalendarStatus(agentId: string) {\n  const supabase = await createClient();\n  \n  const { data: agent, error } = await supabase\n    .from('agent_configurations')\n    .select(`\n      id,\n      name,\n      google_calendar_connected,\n      google_calendar_email,\n      google_calendar_id,\n      google_calendar_connected_at,\n      google_calendar_last_sync\n    `)\n    .eq('id', agentId)\n    .single();\n    \n  if (error || !agent) {\n    return null;\n  }\n  \n  return agent;\n}\n\n/**\n * List calendars for an agent\n */\nexport async function getAgentCalendars(agentId: string) {\n  const supabase = await createClient();\n  \n  const { data: calendars, error } = await supabase\n    .from('agent_calendars')\n    .select('*')\n    .eq('agent_id', agentId)\n    .order('is_primary', { ascending: false })\n    .order('calendar_name');\n    \n  if (error) {\n    console.error('Error getting agent calendars:', error);\n    return [];\n  }\n  \n  return calendars || [];\n}\n\n/**\n * Store calendar list for an agent\n */\nexport async function storeAgentCalendars(\n  agentId: string,\n  calendars: Array<{\n    id: string;\n    summary: string;\n    primary?: boolean;\n    accessRole?: string;\n    backgroundColor?: string;\n    foregroundColor?: string;\n  }>\n) {\n  const supabase = await createClient();\n  \n  // First, delete existing calendars for this agent\n  await supabase\n    .from('agent_calendars')\n    .delete()\n    .eq('agent_id', agentId);\n  \n  // Insert new calendars\n  const calendarRecords = calendars.map(cal => ({\n    agent_id: agentId,\n    calendar_id: cal.id,\n    calendar_name: cal.summary,\n    calendar_email: cal.id,\n    is_primary: cal.primary || false,\n    access_role: cal.accessRole || 'owner',\n    background_color: cal.backgroundColor,\n    foreground_color: cal.foregroundColor\n  }));\n  \n  const { error } = await supabase\n    .from('agent_calendars')\n    .insert(calendarRecords);\n    \n  if (error) {\n    console.error('Error storing agent calendars:', error);\n    return false;\n  }\n  \n  return true;\n}","/Users/rennychan/Personal Apps/contax/lib/services/calendar-service.ts",["639","640","641","642","643","644"],[],"import { NextResponse } from 'next/server';\nimport { cookies } from 'next/headers';\nimport {\n  refreshGoogleAccessToken,\n  getAccountTimezone,\n  listCalendars,\n  checkCalendarAvailability as googleCheckAvailability,\n  createCalendarEvent\n} from './google';\nimport {\n  getAgentCalendarTokens,\n  validateAgentAccess,\n  refreshAgentToken,\n  AgentCalendarIntegration\n} from './agent-calendar';\n\n// Types for the service\nexport interface CalendarToken {\n  access_token: string;\n  refresh_token?: string;\n  expiry?: number;\n}\n\nexport interface CalendarServiceResult<T = any> {\n  success: boolean;\n  data?: T;\n  error?: string;\n  cookies?: Array<{ name: string; value: string }>;\n}\n\nexport interface AvailabilityRequest {\n  start: string;\n  end: string;\n  calendarId?: string;\n  calendarIds?: string[];\n  organizationId?: string;\n}\n\nexport interface SlotsRequest {\n  date: string;\n  slotMinutes?: number;\n  businessHours?: { start?: string; end?: string };\n  calendarIds?: string[];\n  organizationId?: string;\n}\n\nexport interface CalendarStatus {\n  connected: boolean;\n  hasToken: boolean;\n  scopes?: string[];\n  calendars?: Array<{\n    id: string;\n    summary: string;\n    primary?: boolean;\n    accessRole?: string;\n    selected?: boolean;\n  }>;\n  primaryReachable?: boolean;\n  primaryTimeZone?: string;\n  accountTimeZone?: string;\n  errors?: Array<{ step: string; message: string }>;\n  email?: string;\n  calendarId?: string;\n  lastSync?: string;\n  connectedAt?: string;\n}\n\nexport interface BookingRequest {\n  summary: string;\n  description?: string;\n  start: string;\n  end: string;\n  attendees?: Array<{ email: string }>;\n  location?: string;\n  createMeetLink?: boolean;\n  calendarId?: string;\n  timeZone?: string;\n}\n\n/**\n * Unified Calendar Service for handling both user and agent calendar operations\n */\nexport class CalendarService {\n\n  /**\n   * Get calendar tokens from cookies with automatic refresh\n   */\n  static async getUserTokens(): Promise<CalendarServiceResult<CalendarToken>> {\n    const c = await cookies();\n    let accessToken = c.get('gcal_access')?.value ||\n                     c.get('gcal_token')?.value ||\n                     process.env.GOOGLE_CALENDAR_ACCESS_TOKEN;\n\n    const refreshToken = c.get('gcal_refresh')?.value;\n    const expiry = Number(c.get('gcal_expiry')?.value || 0);\n    const nowSec = Math.floor(Date.now() / 1000);\n    const setCookies: Array<{ name: string; value: string }> = [];\n\n    // Check if token needs refresh\n    if ((!accessToken || (expiry && nowSec >= expiry)) &&\n        refreshToken &&\n        process.env.GOOGLE_CLIENT_ID &&\n        process.env.GOOGLE_CLIENT_SECRET) {\n\n      const refreshResult = await refreshGoogleAccessToken(\n        refreshToken,\n        process.env.GOOGLE_CLIENT_ID!,\n        process.env.GOOGLE_CLIENT_SECRET!\n      );\n\n      if (refreshResult?.access_token) {\n        accessToken = refreshResult.access_token;\n        const newExpiry = nowSec + (refreshResult.expires_in || 3600) - 60;\n        setCookies.push(\n          { name: 'gcal_access', value: accessToken },\n          { name: 'gcal_expiry', value: String(newExpiry) },\n          { name: 'gcal_token', value: accessToken }\n        );\n      }\n    }\n\n    if (!accessToken) {\n      return { success: false, error: 'No valid access token available' };\n    }\n\n    return {\n      success: true,\n      data: {\n        access_token: accessToken,\n        refresh_token: refreshToken,\n        expiry\n      },\n      cookies: setCookies\n    };\n  }\n\n  /**\n   * Get agent tokens with validation and automatic refresh\n   */\n  static async getAgentTokens(agentId: string, userId?: string): Promise<CalendarServiceResult<AgentCalendarIntegration>> {\n    try {\n      // Validate agent access if userId provided\n      if (userId) {\n        const agentAccess = await validateAgentAccess(agentId, userId);\n        if (!agentAccess) {\n          return { success: false, error: 'Agent not found or access denied' };\n        }\n      }\n\n      const tokens = await getAgentCalendarTokens(agentId);\n      if (!tokens || !tokens.access_token) {\n        return { success: false, error: 'Agent calendar not connected' };\n      }\n\n      return { success: true, data: tokens };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Failed to get agent tokens'\n      };\n    }\n  }\n\n  /**\n   * Check calendar availability with unified logic\n   */\n  static async checkAvailability(\n    request: AvailabilityRequest,\n    agentId?: string,\n    userId?: string\n  ): Promise<CalendarServiceResult> {\n    try {\n      const { start, end, calendarId = 'primary', calendarIds } = request;\n\n      if (!start || !end) {\n        return { success: false, error: 'Start and end times are required' };\n      }\n\n      // Get appropriate tokens\n      let tokenResult: CalendarServiceResult<CalendarToken | AgentCalendarIntegration>;\n      if (agentId) {\n        tokenResult = await this.getAgentTokens(agentId, userId);\n      } else {\n        tokenResult = await this.getUserTokens();\n      }\n\n      if (!tokenResult.success || !tokenResult.data) {\n        return tokenResult;\n      }\n\n      const accessToken = tokenResult.data.access_token;\n\n      // Get account timezone\n      const accountTz = await getAccountTimezone(accessToken);\n      const baseTz = accountTz || undefined;\n\n      // Normalize datetimes\n      const normStart = this.normalizeRfc3339(start, baseTz);\n      const normEnd = this.normalizeRfc3339(end, baseTz);\n\n      // Guardrail: reject overly broad windows\n      const ms = Date.parse(normEnd) - Date.parse(normStart);\n      const fourHours = 4 * 60 * 60 * 1000;\n      if (ms > fourHours) {\n        return {\n          success: false,\n          error: 'Window too large for availability check; use getAvailableSlots instead',\n          data: {\n            error: 'broad_window',\n            message: 'Window too large for slot check; use getAvailableSlots instead',\n            start: normStart,\n            end: normEnd,\n            timeZone: baseTz || null\n          }\n        };\n      }\n\n      // Use existing checkCalendarAvailability function\n      const availability = await googleCheckAvailability(\n        accessToken,\n        normStart,\n        normEnd,\n        calendarId,\n        calendarIds\n      );\n\n      // Determine which calendars were used\n      let usedGoogleCalendars: string[] = [];\n      if (calendarIds && calendarIds.length > 0) {\n        usedGoogleCalendars = calendarIds;\n      } else {\n        const calendars = await listCalendars(accessToken);\n        if (calendars && calendars.length > 0) {\n          usedGoogleCalendars = calendars\n            .filter(c => (c.selected === true || c.primary === true) &&\n                        (c.accessRole === 'owner' || c.accessRole === 'writer'))\n            .map(c => c.id);\n        }\n        if (usedGoogleCalendars.length === 0) {\n          usedGoogleCalendars = [calendarId];\n        }\n      }\n\n      const result = {\n        available: availability.available,\n        conflicts: { google: availability.conflicts },\n        usedGoogle: true,\n        googleError: null,\n        usedGoogleCalendars,\n        start: normStart,\n        end: normEnd,\n        timeZone: baseTz || null\n      };\n\n      return {\n        success: true,\n        data: result,\n        cookies: tokenResult.cookies\n      };\n\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Failed to check availability'\n      };\n    }\n  }\n\n  /**\n   * Get available slots with unified logic\n   */\n  static async getAvailableSlots(\n    request: SlotsRequest,\n    agentId?: string,\n    userId?: string\n  ): Promise<CalendarServiceResult> {\n    try {\n      const { date, calendarIds } = request;\n      const slotMinutes = Math.max(5, Math.min(240, request.slotMinutes || 60));\n      const bhStart = request.businessHours?.start || '09:00';\n      const bhEnd = request.businessHours?.end || '17:00';\n\n      if (!date || !/^\\d{4}-\\d{2}-\\d{2}$/.test(date)) {\n        return {\n          success: false,\n          error: 'Invalid date format. Expected YYYY-MM-DD'\n        };\n      }\n\n      // Get appropriate tokens\n      let tokenResult: CalendarServiceResult<CalendarToken | AgentCalendarIntegration>;\n      if (agentId) {\n        tokenResult = await this.getAgentTokens(agentId, userId);\n      } else {\n        tokenResult = await this.getUserTokens();\n      }\n\n      if (!tokenResult.success || !tokenResult.data) {\n        return tokenResult;\n      }\n\n      const accessToken = tokenResult.data.access_token;\n      const accountTz = (await getAccountTimezone(accessToken)) || 'UTC';\n\n      // Determine day window in timezone\n      const [y, m, d] = date.split('-').map(Number);\n      const dayStartIso = this.withTzIso(y, m, d, 0, 0, 0, accountTz);\n      const dayEndIso = this.withTzIso(y, m, d, 23, 59, 59, accountTz);\n      const bhStartIso = this.withTzIso(y, m, d, ...this.parseTime(bhStart), accountTz);\n      const bhEndIso = this.withTzIso(y, m, d, ...this.parseTime(bhEnd), accountTz);\n\n      // Determine calendars to consider\n      let ids = calendarIds && calendarIds.length ? calendarIds : [];\n      if (!ids.length) {\n        const calendars = await listCalendars(accessToken);\n        if (calendars && calendars.length > 0) {\n          ids = calendars\n            .filter(c => c.selected === true || c.primary === true)\n            .map(c => c.id);\n        }\n      }\n      if (!ids.length) {\n        return { success: false, error: 'No calendars available' };\n      }\n\n      // Get busy periods using FreeBusy API\n      const fbResp = await fetch('https://www.googleapis.com/calendar/v3/freeBusy', {\n        method: 'POST',\n        headers: {\n          Authorization: `Bearer ${accessToken}`,\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          timeMin: dayStartIso,\n          timeMax: dayEndIso,\n          timeZone: accountTz,\n          items: ids.map(id => ({ id }))\n        })\n      });\n\n      if (!fbResp.ok) {\n        return {\n          success: false,\n          error: `Google Calendar API error: ${await fbResp.text()}`\n        };\n      }\n\n      const fb = await fbResp.json();\n      const busy: Array<{ start: number; end: number }> = [];\n\n      for (const id of ids) {\n        const arr = fb?.calendars?.[id]?.busy || [];\n        for (const b of arr) {\n          busy.push({ start: Date.parse(b.start), end: Date.parse(b.end) });\n        }\n      }\n\n      // Merge overlapping busy intervals\n      busy.sort((a, b) => a.start - b.start);\n      const merged: Array<{ start: number; end: number }> = [];\n      for (const b of busy) {\n        if (!merged.length || b.start > merged[merged.length - 1].end) {\n          merged.push({ ...b });\n        } else {\n          merged[merged.length - 1].end = Math.max(merged[merged.length - 1].end, b.end);\n        }\n      }\n\n      // Compute free windows within business hours\n      const bhStartTs = Date.parse(bhStartIso);\n      const bhEndTs = Date.parse(bhEndIso);\n      const free: Array<{ start: number; end: number }> = [];\n      let cursor = bhStartTs;\n\n      for (const b of merged) {\n        if (b.end <= bhStartTs || b.start >= bhEndTs) continue;\n        if (b.start > cursor) {\n          free.push({ start: cursor, end: Math.min(b.start, bhEndTs) });\n        }\n        cursor = Math.max(cursor, b.end);\n        if (cursor >= bhEndTs) break;\n      }\n      if (cursor < bhEndTs) {\n        free.push({ start: cursor, end: bhEndTs });\n      }\n\n      // Generate slots from free windows\n      const slots: Array<{ start: string; end: string }> = [];\n      for (const w of free) {\n        let s = w.start;\n        while (s + slotMinutes * 60000 <= w.end) {\n          const e = s + slotMinutes * 60000;\n          slots.push({\n            start: new Date(s).toISOString(),\n            end: new Date(e).toISOString()\n          });\n          s += slotMinutes * 60000;\n        }\n      }\n\n      const result = {\n        slots,\n        timeZone: accountTz,\n        usedGoogleCalendars: ids,\n        dayStart: dayStartIso,\n        dayEnd: dayEndIso,\n        businessHours: { start: bhStart, end: bhEnd },\n        slotMinutes\n      };\n\n      return {\n        success: true,\n        data: result,\n        cookies: tokenResult.cookies\n      };\n\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Failed to get available slots'\n      };\n    }\n  }\n\n  /**\n   * Get calendar status with unified logic\n   */\n  static async getCalendarStatus(\n    agentId?: string,\n    userId?: string\n  ): Promise<CalendarServiceResult<CalendarStatus>> {\n    try {\n      // Get appropriate tokens\n      let tokenResult: CalendarServiceResult<CalendarToken | AgentCalendarIntegration>;\n      if (agentId) {\n        tokenResult = await this.getAgentTokens(agentId, userId);\n\n        if (!tokenResult.success) {\n          // For agents, check if it's just not connected\n          const agentAccess = userId ? await validateAgentAccess(agentId, userId) : null;\n          if (agentAccess) {\n            return {\n              success: true,\n              data: {\n                connected: false,\n                hasToken: false,\n                calendars: [],\n                email: null,\n                calendarId: null,\n                errors: [{ step: 'authentication', message: tokenResult.error || 'Not connected' }]\n              }\n            };\n          }\n          return tokenResult;\n        }\n      } else {\n        tokenResult = await this.getUserTokens();\n        if (!tokenResult.success) {\n          return {\n            success: true,\n            data: {\n              connected: false,\n              hasToken: false,\n              errors: [{ step: 'authentication', message: tokenResult.error || 'No token' }]\n            }\n          };\n        }\n      }\n\n      const accessToken = tokenResult.data!.access_token;\n      const status: CalendarStatus = {\n        connected: false,\n        hasToken: !!accessToken,\n        errors: []\n      };\n\n      if (!accessToken) {\n        return { success: true, data: status, cookies: tokenResult.cookies };\n      }\n\n      // Check token scopes\n      try {\n        const info = await fetch(`https://www.googleapis.com/oauth2/v1/tokeninfo?access_token=${encodeURIComponent(accessToken)}`);\n        if (info.ok) {\n          const j = await info.json();\n          const scopes = typeof j.scope === 'string' ? j.scope.split(' ') : [];\n          status.scopes = scopes;\n        } else {\n          status.errors!.push({\n            step: 'tokeninfo',\n            message: `${info.status} ${await info.text()}`\n          });\n        }\n      } catch (e: any) {\n        status.errors!.push({\n          step: 'tokeninfo',\n          message: e?.message || 'tokeninfo failed'\n        });\n      }\n\n      // List calendars\n      try {\n        const calendars = await listCalendars(accessToken);\n        if (calendars) {\n          status.calendars = calendars;\n          const primary = calendars.find(c => c.primary) || calendars.find(c => c.selected);\n          if (primary?.timeZone) {\n            status.primaryTimeZone = primary.timeZone;\n          }\n        }\n      } catch (e: any) {\n        status.errors!.push({\n          step: 'calendarList',\n          message: e?.message || 'calendarList failed'\n        });\n      }\n\n      // Test primary calendar access with FreeBusy probe\n      try {\n        const now = new Date();\n        const end = new Date(now.getTime() + 60 * 60 * 1000);\n        const fb = await fetch('https://www.googleapis.com/calendar/v3/freeBusy', {\n          method: 'POST',\n          headers: {\n            Authorization: `Bearer ${accessToken}`,\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            timeMin: now.toISOString(),\n            timeMax: end.toISOString(),\n            items: [{ id: 'primary' }]\n          })\n        });\n\n        status.primaryReachable = fb.ok;\n        if (!fb.ok) {\n          status.errors!.push({\n            step: 'freeBusy',\n            message: `${fb.status} ${await fb.text()}`\n          });\n        }\n      } catch (e: any) {\n        status.primaryReachable = false;\n        status.errors!.push({\n          step: 'freeBusy',\n          message: e?.message || 'freeBusy failed'\n        });\n      }\n\n      // Get account timezone\n      try {\n        const tz = await getAccountTimezone(accessToken);\n        if (tz) status.accountTimeZone = tz;\n      } catch {}\n\n      // For agent calendars, add additional info\n      if (agentId) {\n        const agentData = tokenResult.data as AgentCalendarIntegration;\n        status.email = agentData.calendar_email;\n        status.calendarId = agentData.calendar_id;\n      }\n\n      status.connected = !!status.scopes &&\n                        Array.isArray(status.calendars) &&\n                        status.primaryReachable === true;\n\n      return {\n        success: true,\n        data: status,\n        cookies: tokenResult.cookies\n      };\n\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Failed to get calendar status'\n      };\n    }\n  }\n\n  /**\n   * List calendars with unified logic\n   */\n  static async listCalendars(\n    agentId?: string,\n    userId?: string\n  ): Promise<CalendarServiceResult> {\n    try {\n      // Get appropriate tokens\n      let tokenResult: CalendarServiceResult<CalendarToken | AgentCalendarIntegration>;\n      if (agentId) {\n        tokenResult = await this.getAgentTokens(agentId, userId);\n      } else {\n        tokenResult = await this.getUserTokens();\n      }\n\n      if (!tokenResult.success || !tokenResult.data) {\n        return tokenResult;\n      }\n\n      const accessToken = tokenResult.data.access_token;\n\n      // Use existing listCalendars function\n      const calendars = await listCalendars(accessToken);\n\n      if (calendars === null) {\n        return {\n          success: false,\n          error: 'Failed to fetch calendars from Google'\n        };\n      }\n\n      return {\n        success: true,\n        data: { calendars },\n        cookies: tokenResult.cookies\n      };\n\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Failed to list calendars'\n      };\n    }\n  }\n\n  /**\n   * Book a calendar appointment\n   */\n  static async bookAppointment(\n    request: BookingRequest,\n    agentId?: string,\n    userId?: string\n  ): Promise<CalendarServiceResult> {\n    try {\n      const { summary, description, start, end, attendees, location, createMeetLink, calendarId = 'primary', timeZone } = request;\n\n      if (!summary || !start || !end) {\n        return {\n          success: false,\n          error: 'Summary, start, and end times are required'\n        };\n      }\n\n      // Get appropriate tokens\n      let tokenResult: CalendarServiceResult<CalendarToken | AgentCalendarIntegration>;\n      if (agentId) {\n        tokenResult = await this.getAgentTokens(agentId, userId);\n      } else {\n        tokenResult = await this.getUserTokens();\n      }\n\n      if (!tokenResult.success || !tokenResult.data) {\n        return tokenResult;\n      }\n\n      const accessToken = tokenResult.data.access_token;\n\n      // Get account timezone if not provided\n      let tz = timeZone;\n      if (!tz) {\n        tz = await getAccountTimezone(accessToken) || 'UTC';\n      }\n\n      // Create event object\n      const event = {\n        summary,\n        description,\n        start: { dateTime: start, timeZone: tz },\n        end: { dateTime: end, timeZone: tz },\n        attendees,\n        location,\n        conferenceData: createMeetLink ? {\n          createRequest: {\n            requestId: `meet-${Date.now()}`,\n            conferenceSolutionKey: { type: 'hangoutsMeet' }\n          }\n        } : undefined\n      };\n\n      // Use the calendar ID from agent data if available\n      let targetCalendarId = calendarId;\n      if (agentId) {\n        const agentData = tokenResult.data as AgentCalendarIntegration;\n        if (agentData.calendar_id) {\n          targetCalendarId = agentData.calendar_id;\n        }\n      }\n\n      const result = await createCalendarEvent(accessToken, event, targetCalendarId);\n\n      if (result?.error) {\n        return { success: false, error: result.error };\n      }\n\n      return {\n        success: true,\n        data: result,\n        cookies: tokenResult.cookies\n      };\n\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Failed to book appointment'\n      };\n    }\n  }\n\n  /**\n   * Create a standardized NextResponse with cookies\n   */\n  static createResponse<T>(\n    result: CalendarServiceResult<T>,\n    statusCode?: number\n  ): NextResponse {\n    const status = result.success ? (statusCode || 200) : (statusCode || 500);\n    const responseData = result.success ? result.data : { error: result.error };\n\n    const response = NextResponse.json(responseData, { status });\n\n    // Set cookies if provided\n    if (result.cookies) {\n      result.cookies.forEach(cookie => {\n        response.cookies.set(cookie.name, cookie.value, {\n          httpOnly: true,\n          sameSite: 'lax',\n          secure: false,\n          path: '/'\n        });\n      });\n    }\n\n    return response;\n  }\n\n  // Helper methods\n\n  /**\n   * Normalize RFC3339 datetime with timezone\n   */\n  private static normalizeRfc3339(input: string, timeZone?: string): string {\n    if (!input) return input;\n\n    let s = input.trim();\n    s = s.replace(/[zZ]$/, '').replace(/[+-]\\d{2}:\\d{2}$/, '');\n    if (/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}$/.test(s)) s += ':00';\n    if (!timeZone) return s + 'Z';\n\n    const m = s.match(/^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})$/);\n    if (!m) return s + 'Z';\n\n    const y = Number(m[1]), mo = Number(m[2]), d = Number(m[3]);\n    const h = Number(m[4]), mi = Number(m[5]), se = Number(m[6]);\n    const utcProbe = new Date(Date.UTC(y, mo - 1, d, h, mi, se));\n    const offset = this.tzOffsetString(timeZone, utcProbe);\n\n    return `${m[1]}-${m[2]}-${m[3]}T${m[4]}:${m[5]}:${m[6]}${offset}`;\n  }\n\n  /**\n   * Get timezone offset string\n   */\n  private static tzOffsetString(timeZone: string, utcDate: Date): string {\n    const fmt = new Intl.DateTimeFormat('en-US', {\n      timeZone,\n      timeZoneName: 'short',\n      year: 'numeric', month: '2-digit', day: '2-digit',\n      hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false\n    });\n    const parts = fmt.formatToParts(utcDate);\n    const tzName = parts.find(p => p.type === 'timeZoneName')?.value || 'GMT+0';\n    const m = tzName.match(/GMT([+-])(\\d{1,2})/);\n    if (!m) return 'Z';\n    const sign = m[1] === '-' ? '-' : '+';\n    const hh = String(Number(m[2])).padStart(2, '0');\n    return `${sign}${hh}:00`;\n  }\n\n  /**\n   * Parse time string to hour/minute/second\n   */\n  private static parseTime(s: string): [number, number, number] {\n    const m = s.match(/^(\\d{2}):(\\d{2})$/);\n    if (!m) return [0, 0, 0];\n    return [Number(m[1]), Number(m[2]), 0];\n  }\n\n  /**\n   * Create ISO string with timezone\n   */\n  private static withTzIso(y: number, m: number, d: number, hh: number, mm: number, ss: number, timeZone: string): string {\n    const utc = new Date(Date.UTC(y, m - 1, d, hh, mm, ss));\n    const fmt = new Intl.DateTimeFormat('en-US', {\n      timeZone,\n      timeZoneName: 'short',\n      year: 'numeric', month: '2-digit', day: '2-digit',\n      hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false\n    });\n    const parts = fmt.formatToParts(utc);\n    const tzName = parts.find(p => p.type === 'timeZoneName')?.value || 'GMT+0';\n    const m2 = tzName.match(/GMT([+-])(\\d{1,2})/);\n    const sign = m2?.[1] === '-' ? '-' : '+';\n    const off = String(Number(m2?.[2] || '0')).padStart(2, '0');\n\n    return `${y}-${String(m).padStart(2, '0')}-${String(d).padStart(2, '0')}T${String(hh).padStart(2, '0')}:${String(mm).padStart(2, '0')}:${String(ss).padStart(2, '0')}${sign}${off}:00`;\n  }\n}","/Users/rennychan/Personal Apps/contax/lib/services/google.ts",["645","646","647","648"],[],"import type {\n  GoogleTokenResponse,\n  GoogleCalendar,\n  GoogleCalendarListResponse,\n  GoogleCalendarEvent,\n  GoogleFreeBusyRequest,\n  GoogleFreeBusyResponse,\n  GoogleTimezoneSetting,\n  CreateCalendarEventRequest,\n  CalendarAvailabilityResult\n} from '../../types/google'\n\nexport async function refreshGoogleAccessToken(\n  refreshToken: string,\n  clientId: string,\n  clientSecret: string\n): Promise<GoogleTokenResponse | null> {\n  const r = await fetch('https://oauth2.googleapis.com/token', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n    body: new URLSearchParams({\n      client_id: clientId,\n      client_secret: clientSecret,\n      refresh_token: refreshToken,\n      grant_type: 'refresh_token'\n    })\n  })\n  if (!r.ok) return null\n  return (await r.json()) as GoogleTokenResponse\n}\n\nexport async function getAccountTimezone(accessToken: string): Promise<string | null> {\n  try {\n    const r = await fetch('https://www.googleapis.com/calendar/v3/users/me/settings/timezone', {\n      headers: { Authorization: `Bearer ${accessToken}` }\n    })\n    if (!r.ok) return null\n    const j = await r.json() as GoogleTimezoneSetting\n    // Response shape: { kind, etag, value: 'Europe/Amsterdam' }\n    return j?.value || null\n  } catch {\n    return null\n  }\n}\n\n/**\n * List all calendars for the authenticated user\n */\nexport async function listCalendars(accessToken: string): Promise<GoogleCalendar[] | null> {\n  try {\n    const r = await fetch('https://www.googleapis.com/calendar/v3/users/me/calendarList', {\n      headers: { Authorization: `Bearer ${accessToken}` }\n    })\n    if (!r.ok) return null\n    const j = await r.json() as GoogleCalendarListResponse\n    const items: GoogleCalendar[] = (j.items || []).map((c) => ({\n      id: c.id,\n      summary: c.summary,\n      primary: !!c.primary,\n      accessRole: c.accessRole,\n      selected: !!c.selected,\n      timeZone: c.timeZone || undefined,\n      backgroundColor: c.backgroundColor,\n      foregroundColor: c.foregroundColor\n    }))\n    return items\n  } catch {\n    return null\n  }\n}\n\n/**\n * Check calendar availability for a given time range\n */\nexport async function checkCalendarAvailability(\n  accessToken: string,\n  start: string,\n  end: string,\n  calendarId: string = 'primary',\n  calendarIds?: string[]\n): Promise<CalendarAvailabilityResult> {\n  try {\n    // Get account timezone\n    const accountTz = await getAccountTimezone(accessToken)\n    const baseTz = accountTz || undefined\n    \n    // Normalize datetimes\n    const normStart = normalizeRfc3339(start, baseTz)\n    const normEnd = normalizeRfc3339(end, baseTz)\n    \n    // Determine which calendars to check\n    let ids = calendarIds && calendarIds.length ? calendarIds : []\n    if (!ids.length) {\n      // Fetch calendar list to get selected calendars\n      const calendars = await listCalendars(accessToken)\n      if (calendars && calendars.length > 0) {\n        ids = calendars\n          .filter((c) => (c.selected === true || c.primary === true) && \n                        (c.accessRole === 'owner' || c.accessRole === 'writer'))\n          .map((c) => c.id)\n      }\n    }\n    if (!ids.length) ids = [calendarId]\n    \n    // Check free/busy\n    const r = await fetch('https://www.googleapis.com/calendar/v3/freeBusy', {\n      method: 'POST',\n      headers: { \n        Authorization: `Bearer ${accessToken}`, \n        'Content-Type': 'application/json' \n      },\n      body: JSON.stringify({\n        timeMin: normStart,\n        timeMax: normEnd,\n        timeZone: baseTz || 'UTC',\n        items: ids.map((id) => ({ id }))\n      })\n    })\n    \n    if (!r.ok) {\n      return {\n        available: true, // Assume available if API fails\n        conflicts: [],\n        timeZone: baseTz\n      }\n    }\n    \n    const freebusy = await r.json() as GoogleFreeBusyResponse\n    let busy: Array<{ start: string; end: string }> = []\n    \n    if (freebusy?.calendars) {\n      for (const id of ids) {\n        const slots = freebusy.calendars[id]?.busy || []\n        busy = busy.concat(slots)\n      }\n    }\n    \n    return {\n      available: busy.length === 0,\n      conflicts: busy,\n      timeZone: baseTz\n    }\n  } catch (error) {\n    console.error('Error checking calendar availability:', error)\n    return {\n      available: true, // Assume available if error\n      conflicts: [],\n      timeZone: undefined\n    }\n  }\n}\n\n/**\n * Create a calendar event\n */\nexport async function createCalendarEvent(\n  accessToken: string,\n  event: CreateCalendarEventRequest,\n  calendarId: string = 'primary'\n): Promise<Partial<GoogleCalendarEvent> & { error?: string } | null> {\n  try {\n    const resp = await fetch(\n      `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}/events?conferenceDataVersion=1`,\n      {\n        method: 'POST',\n        headers: { \n          Authorization: `Bearer ${accessToken}`, \n          'Content-Type': 'application/json' \n        },\n        body: JSON.stringify(event)\n      }\n    )\n    \n    if (!resp.ok) {\n      const errorText = await resp.text()\n      console.error('Failed to create calendar event:', errorText)\n      return { error: `${resp.status} ${errorText}` }\n    }\n    \n    const data = await resp.json() as GoogleCalendarEvent\n    return {\n      id: data.id,\n      htmlLink: data.htmlLink,\n      hangoutLink: data.hangoutLink,\n      start: data.start,\n      end: data.end,\n      summary: data.summary\n    }\n  } catch (error) {\n    console.error('Error creating calendar event:', error)\n    return { error: error instanceof Error ? error.message : 'Failed to create event' }\n  }\n}\n\n// Helper function to normalize RFC3339 datetime with timezone\nfunction normalizeRfc3339(input: string, timeZone?: string): string {\n  if (!input) return input\n  // Always interpret the wall-clock portion in the provided timezone (if given),\n  // ignoring any incoming offset to avoid ET/UTC mismatches.\n  let s = input.trim()\n  s = s.replace(/[zZ]$/,'').replace(/[+-]\\d{2}:\\d{2}$/,'')\n  if (/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}$/.test(s)) s += ':00'\n  if (!timeZone) return s + 'Z'\n  const m = s.match(/^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})$/)\n  if (!m) return s + 'Z'\n  const y = Number(m[1]); const mo = Number(m[2]); const d = Number(m[3]); \n  const h = Number(m[4]); const mi = Number(m[5]); const se = Number(m[6])\n  const utcProbe = new Date(Date.UTC(y, mo - 1, d, h, mi, se))\n  const offset = tzOffsetString(timeZone, utcProbe)\n  return `${m[1]}-${m[2]}-${m[3]}T${m[4]}:${m[5]}:${m[6]}${offset}`\n}\n\n// Helper function to get timezone offset string\nfunction tzOffsetString(timeZone: string, utcDate: Date): string {\n  const fmt = new Intl.DateTimeFormat('en-US', {\n    timeZone,\n    timeZoneName: 'short',\n    year: 'numeric', month: '2-digit', day: '2-digit',\n    hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false\n  })\n  const parts = fmt.formatToParts(utcDate)\n  const tzName = parts.find((p) => p.type === 'timeZoneName')?.value || 'GMT+0'\n  const m = tzName.match(/GMT([+-])(\\d{1,2})/)\n  if (!m) return 'Z'\n  const sign = m[1] === '-' ? '-' : '+'\n  const hh = String(Number(m[2])).padStart(2, '0')\n  return `${sign}${hh}:00`\n}\n","/Users/rennychan/Personal Apps/contax/lib/services/token-service.ts",["649"],[],"import { cookies } from 'next/headers';\nimport { NextResponse } from 'next/server';\nimport { refreshGoogleAccessToken } from '../google';\nimport {\n  getAgentCalendarTokens,\n  refreshAgentToken,\n  AgentCalendarIntegration\n} from '../agent-calendar';\n\nexport interface TokenInfo {\n  access_token: string;\n  refresh_token?: string;\n  expiry?: number;\n  source: 'user' | 'agent';\n  agent_id?: string;\n}\n\nexport interface TokenResult {\n  success: boolean;\n  tokens?: TokenInfo;\n  cookies?: Array<{ name: string; value: string }>;\n  error?: string;\n}\n\n/**\n * Unified Token Management Service\n * Handles both user cookie-based tokens and agent database-stored tokens\n */\nexport class TokenService {\n\n  /**\n   * Get user tokens from cookies with automatic refresh\n   */\n  static async getUserTokens(): Promise<TokenResult> {\n    try {\n      const c = await cookies();\n      let accessToken = c.get('gcal_access')?.value ||\n                       c.get('gcal_token')?.value ||\n                       process.env.GOOGLE_CALENDAR_ACCESS_TOKEN;\n\n      const refreshToken = c.get('gcal_refresh')?.value;\n      const expiry = Number(c.get('gcal_expiry')?.value || 0);\n      const nowSec = Math.floor(Date.now() / 1000);\n      const setCookies: Array<{ name: string; value: string }> = [];\n\n      // Check if token needs refresh\n      if ((!accessToken || (expiry && nowSec >= expiry)) &&\n          refreshToken &&\n          process.env.GOOGLE_CLIENT_ID &&\n          process.env.GOOGLE_CLIENT_SECRET) {\n\n        const refreshResult = await refreshGoogleAccessToken(\n          refreshToken,\n          process.env.GOOGLE_CLIENT_ID!,\n          process.env.GOOGLE_CLIENT_SECRET!\n        );\n\n        if (refreshResult?.access_token) {\n          accessToken = refreshResult.access_token;\n          const newExpiry = nowSec + (refreshResult.expires_in || 3600) - 60;\n\n          setCookies.push(\n            { name: 'gcal_access', value: accessToken },\n            { name: 'gcal_expiry', value: String(newExpiry) },\n            { name: 'gcal_token', value: accessToken }\n          );\n        }\n      }\n\n      if (!accessToken) {\n        return {\n          success: false,\n          error: 'No valid access token available'\n        };\n      }\n\n      return {\n        success: true,\n        tokens: {\n          access_token: accessToken,\n          refresh_token: refreshToken,\n          expiry,\n          source: 'user'\n        },\n        cookies: setCookies\n      };\n\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Failed to get user tokens'\n      };\n    }\n  }\n\n  /**\n   * Get agent tokens from database with automatic refresh\n   */\n  static async getAgentTokens(agentId: string): Promise<TokenResult> {\n    try {\n      const tokens = await getAgentCalendarTokens(agentId);\n\n      if (!tokens) {\n        return {\n          success: false,\n          error: 'Agent calendar not connected'\n        };\n      }\n\n      if (!tokens.access_token) {\n        return {\n          success: false,\n          error: 'No valid access token for agent'\n        };\n      }\n\n      return {\n        success: true,\n        tokens: {\n          access_token: tokens.access_token,\n          refresh_token: tokens.refresh_token || undefined,\n          expiry: tokens.token_expiry ? Number(tokens.token_expiry) : undefined,\n          source: 'agent',\n          agent_id: agentId\n        }\n      };\n\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Failed to get agent tokens'\n      };\n    }\n  }\n\n  /**\n   * Get tokens for either user or agent\n   */\n  static async getTokens(agentId?: string): Promise<TokenResult> {\n    if (agentId) {\n      return this.getAgentTokens(agentId);\n    } else {\n      return this.getUserTokens();\n    }\n  }\n\n  /**\n   * Refresh tokens based on source\n   */\n  static async refreshTokens(tokens: TokenInfo): Promise<TokenResult> {\n    if (!tokens.refresh_token) {\n      return {\n        success: false,\n        error: 'No refresh token available'\n      };\n    }\n\n    try {\n      const refreshResult = await refreshGoogleAccessToken(\n        tokens.refresh_token,\n        process.env.GOOGLE_CLIENT_ID!,\n        process.env.GOOGLE_CLIENT_SECRET!\n      );\n\n      if (!refreshResult?.access_token) {\n        return {\n          success: false,\n          error: 'Failed to refresh token'\n        };\n      }\n\n      if (tokens.source === 'agent' && tokens.agent_id) {\n        // For agent tokens, update in database\n        const agentTokens = await getAgentCalendarTokens(tokens.agent_id);\n        if (agentTokens) {\n          await refreshAgentToken(tokens.agent_id, agentTokens);\n        }\n\n        return this.getAgentTokens(tokens.agent_id);\n      } else {\n        // For user tokens, return cookie updates\n        const nowSec = Math.floor(Date.now() / 1000);\n        const newExpiry = nowSec + (refreshResult.expires_in || 3600) - 60;\n\n        return {\n          success: true,\n          tokens: {\n            access_token: refreshResult.access_token,\n            refresh_token: tokens.refresh_token,\n            expiry: newExpiry,\n            source: 'user'\n          },\n          cookies: [\n            { name: 'gcal_access', value: refreshResult.access_token },\n            { name: 'gcal_expiry', value: String(newExpiry) },\n            { name: 'gcal_token', value: refreshResult.access_token }\n          ]\n        };\n      }\n\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Failed to refresh tokens'\n      };\n    }\n  }\n\n  /**\n   * Check if tokens are expired\n   */\n  static isTokenExpired(tokens: TokenInfo): boolean {\n    if (!tokens.expiry) return false;\n    const nowSec = Math.floor(Date.now() / 1000);\n    return nowSec >= tokens.expiry;\n  }\n\n  /**\n   * Get valid tokens with automatic refresh if needed\n   */\n  static async getValidTokens(agentId?: string): Promise<TokenResult> {\n    const tokenResult = await this.getTokens(agentId);\n\n    if (!tokenResult.success || !tokenResult.tokens) {\n      return tokenResult;\n    }\n\n    // Check if token needs refresh\n    if (this.isTokenExpired(tokenResult.tokens) && tokenResult.tokens.refresh_token) {\n      return this.refreshTokens(tokenResult.tokens);\n    }\n\n    return tokenResult;\n  }\n\n  /**\n   * Apply token cookies to a NextResponse\n   */\n  static applyCookiesToResponse(response: NextResponse, cookies: Array<{ name: string; value: string }>): void {\n    cookies.forEach(cookie => {\n      response.cookies.set(cookie.name, cookie.value, {\n        httpOnly: true,\n        sameSite: 'lax',\n        secure: false,\n        path: '/'\n      });\n    });\n  }\n\n  /**\n   * Create a response with token cookies applied\n   */\n  static createResponseWithTokens<T>(\n    data: T,\n    cookies?: Array<{ name: string; value: string }>,\n    status: number = 200\n  ): NextResponse {\n    const response = NextResponse.json(data, { status });\n\n    if (cookies && cookies.length > 0) {\n      this.applyCookiesToResponse(response, cookies);\n    }\n\n    return response;\n  }\n\n  /**\n   * Validate token has required scopes\n   */\n  static async validateTokenScopes(accessToken: string, requiredScopes: string[] = []): Promise<{\n    valid: boolean;\n    scopes: string[];\n    error?: string;\n  }> {\n    try {\n      const response = await fetch(`https://www.googleapis.com/oauth2/v1/tokeninfo?access_token=${encodeURIComponent(accessToken)}`);\n\n      if (!response.ok) {\n        return {\n          valid: false,\n          scopes: [],\n          error: `Token validation failed: ${response.status}`\n        };\n      }\n\n      const tokenInfo = await response.json();\n      const scopes = typeof tokenInfo.scope === 'string' ? tokenInfo.scope.split(' ') : [];\n\n      // Check if all required scopes are present\n      const hasRequiredScopes = requiredScopes.every(scope => scopes.includes(scope));\n\n      return {\n        valid: hasRequiredScopes,\n        scopes,\n        error: hasRequiredScopes ? undefined : `Missing required scopes: ${requiredScopes.filter(s => !scopes.includes(s)).join(', ')}`\n      };\n\n    } catch (error) {\n      return {\n        valid: false,\n        scopes: [],\n        error: error instanceof Error ? error.message : 'Token validation failed'\n      };\n    }\n  }\n\n  /**\n   * Revoke token (logout)\n   */\n  static async revokeToken(accessToken: string): Promise<{ success: boolean; error?: string }> {\n    try {\n      const response = await fetch(`https://oauth2.googleapis.com/revoke?token=${encodeURIComponent(accessToken)}`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded'\n        }\n      });\n\n      if (!response.ok) {\n        return {\n          success: false,\n          error: `Failed to revoke token: ${response.status}`\n        };\n      }\n\n      return { success: true };\n\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Failed to revoke token'\n      };\n    }\n  }\n\n  /**\n   * Clear user token cookies\n   */\n  static clearUserTokenCookies(): Array<{ name: string; value: string }> {\n    return [\n      { name: 'gcal_access', value: '' },\n      { name: 'gcal_token', value: '' },\n      { name: 'gcal_refresh', value: '' },\n      { name: 'gcal_expiry', value: '' }\n    ];\n  }\n\n  /**\n   * Create error response for token issues\n   */\n  static createTokenErrorResponse(error: string, status: number = 401): NextResponse {\n    return NextResponse.json({ error }, { status });\n  }\n}","/Users/rennychan/Personal Apps/contax/lib/telephony/twilio.ts",["650","651","652","653"],[],"import type { TelephonyAdapter } from '../adapters/types'\nimport twilio from 'twilio'\n\nexport interface TwilioConfig {\n  accountSid: string\n  authToken: string\n  phoneNumber: string\n}\n\nexport class TwilioTelephonyAdapter implements TelephonyAdapter {\n  private client: twilio.Twilio | null = null\n  private config: TwilioConfig | null = null\n  private currentCallSid: string | null = null\n\n  constructor(config?: TwilioConfig) {\n    if (config) {\n      this.config = config\n      this.client = twilio(config.accountSid, config.authToken)\n    }\n  }\n\n  setConfig(config: TwilioConfig) {\n    this.config = config\n    this.client = twilio(config.accountSid, config.authToken)\n  }\n\n  async startInboundSession() {\n    // Inbound calls are handled via Twilio webhooks\n    // The media stream is established through the TwiML response\n    throw new Error('Inbound sessions are initiated via Twilio webhooks')\n  }\n\n  async startOutboundCall(to: string, options?: {\n    baseUrl?: string\n    organizationId?: string\n    agentId?: string\n  }): Promise<void> {\n    if (!this.client || !this.config) {\n      throw new Error('Twilio client not configured')\n    }\n\n    const baseUrl = options?.baseUrl || process.env.NEXT_PUBLIC_APP_URL\n    if (!baseUrl) {\n      throw new Error('Base URL is required for outbound calls')\n    }\n\n    // Create TwiML for the call\n    const twiml = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Response>\n    <Say>Connecting you to the assistant. Please wait.</Say>\n    <Connect>\n        <Stream url=\"wss://${new URL(baseUrl).host}/api/twilio/media-stream\">\n            <Parameter name=\"organizationId\" value=\"${options?.organizationId || ''}\" />\n            <Parameter name=\"agentId\" value=\"${options?.agentId || 'default'}\" />\n            <Parameter name=\"direction\" value=\"outbound\" />\n        </Stream>\n    </Connect>\n</Response>`\n\n    try {\n      const call = await this.client.calls.create({\n        to,\n        from: this.config.phoneNumber,\n        twiml,\n        statusCallback: `${baseUrl}/api/webhook/call-status`,\n        statusCallbackEvent: ['initiated', 'ringing', 'answered', 'completed'],\n        statusCallbackMethod: 'POST',\n        record: false,\n      })\n\n      this.currentCallSid = call.sid\n      // Return void to match interface\n    } catch (error: any) {\n      console.error('Error creating outbound call:', error)\n      throw new Error(`Failed to create outbound call: ${error.message}`)\n    }\n  }\n  \n  // Add method to get current call SID\n  getCurrentCallSid(): string | null {\n    return this.currentCallSid\n  }\n\n  async hangup(callSid?: string) {\n    if (!this.client) {\n      throw new Error('Twilio client not configured')\n    }\n\n    const sid = callSid || this.currentCallSid\n    if (!sid) {\n      throw new Error('No call SID provided or found')\n    }\n\n    try {\n      await this.client.calls(sid).update({ status: 'completed' })\n      if (sid === this.currentCallSid) {\n        this.currentCallSid = null\n      }\n    } catch (error: any) {\n      console.error('Error hanging up call:', error)\n      throw new Error(`Failed to hang up call: ${error.message}`)\n    }\n  }\n}\n\n// Export a singleton instance for backward compatibility\nexport const TwilioTelephonyAdapterInstance = new TwilioTelephonyAdapter()\n\n","/Users/rennychan/Personal Apps/contax/lib/utils/api-errors.ts",["654","655","656","657","658","659","660","661","662","663","664","665","666","667","668","669","670","671","672","673","674"],[],"import { NextResponse } from 'next/server';\n\n/**\n * Standard error codes for API responses\n */\nexport const ERROR_CODES = {\n  // Client errors (4xx)\n  BAD_REQUEST: 'BAD_REQUEST',\n  UNAUTHORIZED: 'UNAUTHORIZED',\n  FORBIDDEN: 'FORBIDDEN',\n  NOT_FOUND: 'NOT_FOUND',\n  METHOD_NOT_ALLOWED: 'METHOD_NOT_ALLOWED',\n  RATE_LIMITED: 'RATE_LIMITED',\n  VALIDATION_ERROR: 'VALIDATION_ERROR',\n\n  // Server errors (5xx)\n  INTERNAL_SERVER_ERROR: 'INTERNAL_SERVER_ERROR',\n  SERVICE_UNAVAILABLE: 'SERVICE_UNAVAILABLE',\n  DATABASE_ERROR: 'DATABASE_ERROR',\n  EXTERNAL_SERVICE_ERROR: 'EXTERNAL_SERVICE_ERROR',\n} as const;\n\n/**\n * HTTP status codes mapped to error types\n */\nexport const HTTP_STATUS = {\n  BAD_REQUEST: 400,\n  UNAUTHORIZED: 401,\n  FORBIDDEN: 403,\n  NOT_FOUND: 404,\n  METHOD_NOT_ALLOWED: 405,\n  RATE_LIMITED: 429,\n  INTERNAL_SERVER_ERROR: 500,\n  SERVICE_UNAVAILABLE: 503,\n} as const;\n\n/**\n * Base API error interface\n */\nexport interface ApiErrorResponse {\n  error: string;\n  code: string;\n  message: string;\n  details?: Record<string, any>;\n  timestamp: string;\n  path?: string;\n}\n\n/**\n * Validation error details\n */\nexport interface ValidationError {\n  field: string;\n  message: string;\n  code?: string;\n}\n\n/**\n * API Error class for structured error handling\n */\nexport class ApiError extends Error {\n  public readonly code: string;\n  public readonly statusCode: number;\n  public readonly details?: Record<string, any>;\n\n  constructor(\n    message: string,\n    code: string,\n    statusCode: number,\n    details?: Record<string, any>\n  ) {\n    super(message);\n    this.name = 'ApiError';\n    this.code = code;\n    this.statusCode = statusCode;\n    this.details = details;\n\n    // Maintains proper stack trace for where our error was thrown\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ApiError);\n    }\n  }\n}\n\n/**\n * Create a standardized error response\n */\nexport function createErrorResponse(\n  error: string | ApiError,\n  statusCode?: number,\n  details?: Record<string, any>,\n  path?: string\n): NextResponse<ApiErrorResponse> {\n  let errorData: ApiErrorResponse;\n\n  if (error instanceof ApiError) {\n    errorData = {\n      error: error.message,\n      code: error.code,\n      message: error.message,\n      details: error.details,\n      timestamp: new Date().toISOString(),\n      path,\n    };\n    statusCode = error.statusCode;\n  } else {\n    errorData = {\n      error: error,\n      code: ERROR_CODES.INTERNAL_SERVER_ERROR,\n      message: error,\n      details,\n      timestamp: new Date().toISOString(),\n      path,\n    };\n    statusCode = statusCode || HTTP_STATUS.INTERNAL_SERVER_ERROR;\n  }\n\n  return NextResponse.json(errorData, { status: statusCode });\n}\n\n/**\n * Predefined error response creators\n */\nexport const ErrorResponses = {\n  /**\n   * Bad Request (400) - Invalid request data\n   */\n  badRequest: (message: string = 'Bad request', details?: Record<string, any>, path?: string) =>\n    createErrorResponse(\n      new ApiError(message, ERROR_CODES.BAD_REQUEST, HTTP_STATUS.BAD_REQUEST, details),\n      undefined,\n      undefined,\n      path\n    ),\n\n  /**\n   * Unauthorized (401) - Authentication required\n   */\n  unauthorized: (message: string = 'Authentication required', details?: Record<string, any>, path?: string) =>\n    createErrorResponse(\n      new ApiError(message, ERROR_CODES.UNAUTHORIZED, HTTP_STATUS.UNAUTHORIZED, details),\n      undefined,\n      undefined,\n      path\n    ),\n\n  /**\n   * Forbidden (403) - Access denied\n   */\n  forbidden: (message: string = 'Access denied', details?: Record<string, any>, path?: string) =>\n    createErrorResponse(\n      new ApiError(message, ERROR_CODES.FORBIDDEN, HTTP_STATUS.FORBIDDEN, details),\n      undefined,\n      undefined,\n      path\n    ),\n\n  /**\n   * Not Found (404) - Resource not found\n   */\n  notFound: (message: string = 'Resource not found', details?: Record<string, any>, path?: string) =>\n    createErrorResponse(\n      new ApiError(message, ERROR_CODES.NOT_FOUND, HTTP_STATUS.NOT_FOUND, details),\n      undefined,\n      undefined,\n      path\n    ),\n\n  /**\n   * Method Not Allowed (405) - HTTP method not supported\n   */\n  methodNotAllowed: (message: string = 'Method not allowed', details?: Record<string, any>, path?: string) =>\n    createErrorResponse(\n      new ApiError(message, ERROR_CODES.METHOD_NOT_ALLOWED, HTTP_STATUS.METHOD_NOT_ALLOWED, details),\n      undefined,\n      undefined,\n      path\n    ),\n\n  /**\n   * Rate Limited (429) - Too many requests\n   */\n  rateLimited: (message: string = 'Too many requests', details?: Record<string, any>, path?: string) =>\n    createErrorResponse(\n      new ApiError(message, ERROR_CODES.RATE_LIMITED, HTTP_STATUS.RATE_LIMITED, details),\n      undefined,\n      undefined,\n      path\n    ),\n\n  /**\n   * Validation Error (400) - Request validation failed\n   */\n  validation: (errors: ValidationError[], message: string = 'Validation failed', path?: string) =>\n    createErrorResponse(\n      new ApiError(message, ERROR_CODES.VALIDATION_ERROR, HTTP_STATUS.BAD_REQUEST, { errors }),\n      undefined,\n      undefined,\n      path\n    ),\n\n  /**\n   * Internal Server Error (500) - Unexpected server error\n   */\n  serverError: (message: string = 'Internal server error', details?: Record<string, any>, path?: string) =>\n    createErrorResponse(\n      new ApiError(message, ERROR_CODES.INTERNAL_SERVER_ERROR, HTTP_STATUS.INTERNAL_SERVER_ERROR, details),\n      undefined,\n      undefined,\n      path\n    ),\n\n  /**\n   * Service Unavailable (503) - External service error\n   */\n  serviceUnavailable: (message: string = 'Service temporarily unavailable', details?: Record<string, any>, path?: string) =>\n    createErrorResponse(\n      new ApiError(message, ERROR_CODES.SERVICE_UNAVAILABLE, HTTP_STATUS.SERVICE_UNAVAILABLE, details),\n      undefined,\n      undefined,\n      path\n    ),\n\n  /**\n   * Database Error (500) - Database operation failed\n   */\n  databaseError: (message: string = 'Database operation failed', details?: Record<string, any>, path?: string) =>\n    createErrorResponse(\n      new ApiError(message, ERROR_CODES.DATABASE_ERROR, HTTP_STATUS.INTERNAL_SERVER_ERROR, details),\n      undefined,\n      undefined,\n      path\n    ),\n\n  /**\n   * External Service Error (500) - Third-party service error\n   */\n  externalServiceError: (message: string = 'External service error', details?: Record<string, any>, path?: string) =>\n    createErrorResponse(\n      new ApiError(message, ERROR_CODES.EXTERNAL_SERVICE_ERROR, HTTP_STATUS.INTERNAL_SERVER_ERROR, details),\n      undefined,\n      undefined,\n      path\n    ),\n};\n\n/**\n * Validation helper functions\n */\nexport const ValidationHelpers = {\n  /**\n   * Validate required fields are present\n   */\n  validateRequired: (data: Record<string, any>, requiredFields: string[]): ValidationError[] => {\n    const errors: ValidationError[] = [];\n\n    for (const field of requiredFields) {\n      if (!data[field] || (typeof data[field] === 'string' && data[field].trim() === '')) {\n        errors.push({\n          field,\n          message: `${field} is required`,\n          code: 'REQUIRED_FIELD_MISSING'\n        });\n      }\n    }\n\n    return errors;\n  },\n\n  /**\n   * Validate email format\n   */\n  validateEmail: (email: string, fieldName: string = 'email'): ValidationError | null => {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    if (!emailRegex.test(email)) {\n      return {\n        field: fieldName,\n        message: 'Invalid email format',\n        code: 'INVALID_EMAIL_FORMAT'\n      };\n    }\n    return null;\n  },\n\n  /**\n   * Validate phone number format (basic international format)\n   */\n  validatePhone: (phone: string, fieldName: string = 'phone'): ValidationError | null => {\n    const phoneRegex = /^\\+[1-9]\\d{1,14}$/;\n    if (!phoneRegex.test(phone)) {\n      return {\n        field: fieldName,\n        message: 'Phone number must be in international format (e.g., +1234567890)',\n        code: 'INVALID_PHONE_FORMAT'\n      };\n    }\n    return null;\n  },\n\n  /**\n   * Validate string length\n   */\n  validateLength: (\n    value: string,\n    fieldName: string,\n    min?: number,\n    max?: number\n  ): ValidationError | null => {\n    if (min && value.length < min) {\n      return {\n        field: fieldName,\n        message: `${fieldName} must be at least ${min} characters long`,\n        code: 'MIN_LENGTH_VIOLATION'\n      };\n    }\n\n    if (max && value.length > max) {\n      return {\n        field: fieldName,\n        message: `${fieldName} must not exceed ${max} characters`,\n        code: 'MAX_LENGTH_VIOLATION'\n      };\n    }\n\n    return null;\n  },\n\n  /**\n   * Validate UUID format\n   */\n  validateUUID: (uuid: string, fieldName: string = 'id'): ValidationError | null => {\n    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n    if (!uuidRegex.test(uuid)) {\n      return {\n        field: fieldName,\n        message: 'Invalid UUID format',\n        code: 'INVALID_UUID_FORMAT'\n      };\n    }\n    return null;\n  },\n};\n\n/**\n * Error handler wrapper for async API route handlers\n * Catches and formats unhandled errors\n */\nexport function withErrorHandler<T extends any[], R>(\n  handler: (...args: T) => Promise<R>\n) {\n  return async (...args: T): Promise<R | NextResponse<ApiErrorResponse>> => {\n    try {\n      return await handler(...args);\n    } catch (error) {\n      console.error('Unhandled API error:', error);\n\n      // Handle known error types\n      if (error instanceof ApiError) {\n        return createErrorResponse(error);\n      }\n\n      // Handle Supabase errors\n      if (error && typeof error === 'object' && 'code' in error && 'message' in error) {\n        return ErrorResponses.databaseError(\n          (error as any).message,\n          { supabaseCode: (error as any).code }\n        );\n      }\n\n      // Handle general errors\n      const message = error instanceof Error ? error.message : 'Unknown error occurred';\n      return ErrorResponses.serverError(message, {\n        stack: error instanceof Error ? error.stack : undefined\n      });\n    }\n  };\n}\n\n/**\n * Utility to extract path from NextRequest\n */\nexport function getRequestPath(request: Request): string {\n  try {\n    const url = new URL(request.url);\n    return url.pathname;\n  } catch {\n    return 'unknown';\n  }\n}\n\n/**\n * Type guards for error handling\n */\nexport const TypeGuards = {\n  isApiError: (error: unknown): error is ApiError => {\n    return error instanceof ApiError;\n  },\n\n  isSupabaseError: (error: unknown): error is { code: string; message: string } => {\n    return (\n      error !== null &&\n      typeof error === 'object' &&\n      'code' in error &&\n      'message' in error &&\n      typeof (error as any).code === 'string' &&\n      typeof (error as any).message === 'string'\n    );\n  },\n};","/Users/rennychan/Personal Apps/contax/lib/utils/cookie-config.ts",["675","676","677"],[],"/**\n * Centralized cookie configuration for secure cookie handling\n * Ensures consistent security settings across the application\n */\n\nimport { ResponseCookie } from 'next/dist/compiled/@edge-runtime/cookies'\n\n/**\n * Type definition for cookie options\n */\nexport interface SecureCookieOptions extends Partial<ResponseCookie> {\n  httpOnly?: boolean\n  secure?: boolean\n  sameSite?: 'strict' | 'lax' | 'none'\n  path?: string\n  maxAge?: number\n  expires?: Date\n}\n\n/**\n * Default secure cookie configuration\n * - httpOnly: true (prevents XSS attacks)\n * - secure: true in production (HTTPS only)\n * - sameSite: 'lax' (CSRF protection while maintaining usability)\n * - path: '/' (available site-wide)\n */\nconst defaultSecureOptions: SecureCookieOptions = {\n  httpOnly: true,\n  secure: process.env.NODE_ENV === 'production',\n  sameSite: 'lax',\n  path: '/',\n}\n\n/**\n * Configuration for different types of cookies\n */\nexport const CookieConfig = {\n  /**\n   * Google Calendar access tokens\n   * Short-lived with 1 hour default expiry\n   */\n  googleCalendarAccess: {\n    ...defaultSecureOptions,\n    maxAge: 3600, // 1 hour\n  } as SecureCookieOptions,\n\n  /**\n   * Google Calendar refresh tokens\n   * Long-lived with 30 days expiry\n   */\n  googleCalendarRefresh: {\n    ...defaultSecureOptions,\n    maxAge: 30 * 24 * 60 * 60, // 30 days\n  } as SecureCookieOptions,\n\n  /**\n   * Token expiry timestamps\n   * Same lifetime as access tokens\n   */\n  tokenExpiry: {\n    ...defaultSecureOptions,\n    maxAge: 3600, // 1 hour\n  } as SecureCookieOptions,\n\n  /**\n   * General authentication tokens\n   * 24 hour default expiry\n   */\n  authToken: {\n    ...defaultSecureOptions,\n    maxAge: 24 * 60 * 60, // 24 hours\n  } as SecureCookieOptions,\n\n  /**\n   * Cookie deletion configuration\n   * Used when clearing cookies\n   */\n  deletion: {\n    ...defaultSecureOptions,\n    maxAge: 0,\n    expires: new Date(0),\n  } as SecureCookieOptions,\n} as const\n\n/**\n * Helper function to create secure cookie options with custom overrides\n * @param overrides - Custom options to override defaults\n * @returns Complete cookie options with security settings\n */\nexport function createSecureCookieOptions(overrides: Partial<SecureCookieOptions> = {}): SecureCookieOptions {\n  return {\n    ...defaultSecureOptions,\n    ...overrides,\n  }\n}\n\n/**\n * Helper function to get cookie configuration by type\n * @param type - The type of cookie configuration to retrieve\n * @param overrides - Additional options to override\n * @returns Cookie options for the specified type\n */\nexport function getCookieConfig(\n  type: keyof typeof CookieConfig,\n  overrides: Partial<SecureCookieOptions> = {}\n): SecureCookieOptions {\n  return {\n    ...CookieConfig[type],\n    ...overrides,\n  }\n}\n\n/**\n * Validate cookie options to ensure security requirements are met\n * @param options - Cookie options to validate\n * @returns true if options are secure, false otherwise\n */\nexport function validateCookieOptions(options: SecureCookieOptions): boolean {\n  // In production, cookies must be secure\n  if (process.env.NODE_ENV === 'production' && !options.secure) {\n    console.warn('Cookie security warning: secure flag should be true in production')\n    return false\n  }\n\n  // Sensitive cookies should be httpOnly\n  if (options.httpOnly === false) {\n    console.warn('Cookie security warning: httpOnly should be true for sensitive cookies')\n    return false\n  }\n\n  // SameSite should be set for CSRF protection\n  if (!options.sameSite) {\n    console.warn('Cookie security warning: sameSite should be set for CSRF protection')\n    return false\n  }\n\n  return true\n}","/Users/rennychan/Personal Apps/contax/lib/utils/date-utils.ts",[],[],"/Users/rennychan/Personal Apps/contax/lib/utils/logger.ts",["678","679","680","681","682"],[],"/**\n * Centralized logging utility for Contax\n * Provides structured logging with different levels and contexts\n */\n\nexport enum LogLevel {\n  DEBUG = 0,\n  INFO = 1,\n  WARN = 2,\n  ERROR = 3,\n}\n\nexport interface LogContext {\n  userId?: string;\n  organizationId?: string;\n  agentId?: string;\n  component?: string;\n  action?: string;\n  [key: string]: any;\n}\n\nclass Logger {\n  private level: LogLevel;\n  private isDevelopment: boolean;\n\n  constructor() {\n    this.level = process.env.NODE_ENV === 'production' ? LogLevel.INFO : LogLevel.DEBUG;\n    this.isDevelopment = process.env.NODE_ENV === 'development';\n  }\n\n  private formatMessage(level: string, message: string, context?: LogContext): string {\n    const timestamp = new Date().toISOString();\n    const contextStr = context ? ` ${JSON.stringify(context)}` : '';\n    return `[${timestamp}] ${level}: ${message}${contextStr}`;\n  }\n\n  private shouldLog(level: LogLevel): boolean {\n    return level >= this.level;\n  }\n\n  debug(message: string, context?: LogContext): void {\n    if (!this.shouldLog(LogLevel.DEBUG)) return;\n\n    if (this.isDevelopment) {\n      console.debug(this.formatMessage('DEBUG', message, context));\n    }\n  }\n\n  info(message: string, context?: LogContext): void {\n    if (!this.shouldLog(LogLevel.INFO)) return;\n\n    console.info(this.formatMessage('INFO', message, context));\n  }\n\n  warn(message: string, context?: LogContext): void {\n    if (!this.shouldLog(LogLevel.WARN)) return;\n\n    console.warn(this.formatMessage('WARN', message, context));\n  }\n\n  error(message: string, error?: Error, context?: LogContext): void {\n    if (!this.shouldLog(LogLevel.ERROR)) return;\n\n    const errorContext = error ? { ...context, error: error.message, stack: error.stack } : context;\n    console.error(this.formatMessage('ERROR', message, errorContext));\n  }\n\n  // Convenience methods for common use cases\n  apiRequest(method: string, path: string, context?: LogContext): void {\n    this.info(`${method} ${path}`, { ...context, action: 'api_request' });\n  }\n\n  apiResponse(method: string, path: string, status: number, context?: LogContext): void {\n    const level = status >= 400 ? LogLevel.ERROR : LogLevel.INFO;\n    const message = `${method} ${path} - ${status}`;\n\n    if (level === LogLevel.ERROR) {\n      this.error(message, undefined, { ...context, status, action: 'api_response' });\n    } else {\n      this.info(message, { ...context, status, action: 'api_response' });\n    }\n  }\n\n  webhook(eventType: string, context?: LogContext): void {\n    this.info(`Webhook received: ${eventType}`, { ...context, action: 'webhook_received' });\n  }\n\n  userAction(action: string, context?: LogContext): void {\n    this.info(`User action: ${action}`, { ...context, action: 'user_action' });\n  }\n}\n\n// Export singleton instance\nexport const logger = new Logger();\n\n// Export convenience functions for easier usage\nexport const log = {\n  debug: (message: string, context?: LogContext) => logger.debug(message, context),\n  info: (message: string, context?: LogContext) => logger.info(message, context),\n  warn: (message: string, context?: LogContext) => logger.warn(message, context),\n  error: (message: string, error?: Error, context?: LogContext) => logger.error(message, error, context),\n  apiRequest: (method: string, path: string, context?: LogContext) => logger.apiRequest(method, path, context),\n  apiResponse: (method: string, path: string, status: number, context?: LogContext) => logger.apiResponse(method, path, status, context),\n  webhook: (eventType: string, context?: LogContext) => logger.webhook(eventType, context),\n  userAction: (action: string, context?: LogContext) => logger.userAction(action, context),\n};","/Users/rennychan/Personal Apps/contax/lib/utils/utils.ts",[],[],"/Users/rennychan/Personal Apps/contax/lib/utils.ts",[],[],{"ruleId":"683","severity":1,"message":"684","line":48,"column":7,"nodeType":"685","messageId":"686","endLine":48,"endColumn":20},{"ruleId":"683","severity":1,"message":"684","line":37,"column":9,"nodeType":"685","messageId":"686","endLine":37,"endColumn":22},{"ruleId":"683","severity":1,"message":"684","line":70,"column":7,"nodeType":"685","messageId":"686","endLine":70,"endColumn":20},{"ruleId":"683","severity":1,"message":"684","line":86,"column":11,"nodeType":"685","messageId":"686","endLine":86,"endColumn":24},{"ruleId":"683","severity":1,"message":"684","line":93,"column":9,"nodeType":"685","messageId":"686","endLine":93,"endColumn":22},{"ruleId":"683","severity":1,"message":"684","line":145,"column":7,"nodeType":"685","messageId":"686","endLine":145,"endColumn":20},{"ruleId":"683","severity":1,"message":"684","line":171,"column":7,"nodeType":"685","messageId":"686","endLine":171,"endColumn":20},{"ruleId":"683","severity":1,"message":"684","line":201,"column":7,"nodeType":"685","messageId":"686","endLine":201,"endColumn":20},{"ruleId":"683","severity":1,"message":"684","line":28,"column":15,"nodeType":"685","messageId":"686","endLine":28,"endColumn":28},{"ruleId":"683","severity":1,"message":"684","line":109,"column":9,"nodeType":"685","messageId":"686","endLine":109,"endColumn":22},{"ruleId":"683","severity":1,"message":"684","line":131,"column":7,"nodeType":"685","messageId":"686","endLine":131,"endColumn":20},{"ruleId":"683","severity":1,"message":"684","line":154,"column":5,"nodeType":"685","messageId":"686","endLine":154,"endColumn":18},{"ruleId":"683","severity":1,"message":"684","line":27,"column":15,"nodeType":"685","messageId":"686","endLine":27,"endColumn":28},{"ruleId":"683","severity":1,"message":"684","line":48,"column":5,"nodeType":"685","messageId":"686","endLine":48,"endColumn":18},{"ruleId":"683","severity":1,"message":"684","line":28,"column":15,"nodeType":"685","messageId":"686","endLine":28,"endColumn":28},{"ruleId":"683","severity":1,"message":"684","line":59,"column":5,"nodeType":"685","messageId":"686","endLine":59,"endColumn":18},{"ruleId":"683","severity":1,"message":"684","line":33,"column":15,"nodeType":"685","messageId":"686","endLine":33,"endColumn":28},{"ruleId":"683","severity":1,"message":"684","line":79,"column":5,"nodeType":"685","messageId":"686","endLine":79,"endColumn":18},{"ruleId":"683","severity":1,"message":"684","line":27,"column":15,"nodeType":"685","messageId":"686","endLine":27,"endColumn":28},{"ruleId":"683","severity":1,"message":"684","line":43,"column":5,"nodeType":"685","messageId":"686","endLine":43,"endColumn":18},{"ruleId":"683","severity":1,"message":"684","line":27,"column":15,"nodeType":"685","messageId":"686","endLine":27,"endColumn":28},{"ruleId":"683","severity":1,"message":"684","line":42,"column":5,"nodeType":"685","messageId":"686","endLine":42,"endColumn":18},{"ruleId":"683","severity":1,"message":"684","line":22,"column":13,"nodeType":"685","messageId":"686","endLine":22,"endColumn":26},{"ruleId":"683","severity":1,"message":"684","line":87,"column":13,"nodeType":"685","messageId":"686","endLine":87,"endColumn":26},{"ruleId":"683","severity":1,"message":"684","line":22,"column":13,"nodeType":"685","messageId":"686","endLine":22,"endColumn":26},{"ruleId":"683","severity":1,"message":"684","line":58,"column":5,"nodeType":"685","messageId":"686","endLine":58,"endColumn":18},{"ruleId":"683","severity":1,"message":"684","line":80,"column":13,"nodeType":"685","messageId":"686","endLine":80,"endColumn":26},{"ruleId":"683","severity":1,"message":"684","line":161,"column":5,"nodeType":"685","messageId":"686","endLine":161,"endColumn":18},{"ruleId":"683","severity":1,"message":"684","line":183,"column":13,"nodeType":"685","messageId":"686","endLine":183,"endColumn":26},{"ruleId":"683","severity":1,"message":"684","line":284,"column":5,"nodeType":"685","messageId":"686","endLine":284,"endColumn":18},{"ruleId":"683","severity":1,"message":"684","line":313,"column":13,"nodeType":"685","messageId":"686","endLine":313,"endColumn":26},{"ruleId":"683","severity":1,"message":"684","line":397,"column":5,"nodeType":"685","messageId":"686","endLine":397,"endColumn":18},{"ruleId":"683","severity":1,"message":"684","line":54,"column":15,"nodeType":"685","messageId":"686","endLine":54,"endColumn":28},{"ruleId":"683","severity":1,"message":"684","line":103,"column":7,"nodeType":"685","messageId":"686","endLine":103,"endColumn":20},{"ruleId":"683","severity":1,"message":"684","line":150,"column":7,"nodeType":"685","messageId":"686","endLine":150,"endColumn":20},{"ruleId":"683","severity":1,"message":"684","line":159,"column":5,"nodeType":"685","messageId":"686","endLine":159,"endColumn":18},{"ruleId":"683","severity":1,"message":"684","line":27,"column":13,"nodeType":"685","messageId":"686","endLine":27,"endColumn":26},{"ruleId":"683","severity":1,"message":"684","line":78,"column":7,"nodeType":"685","messageId":"686","endLine":78,"endColumn":20},{"ruleId":"683","severity":1,"message":"684","line":92,"column":7,"nodeType":"685","messageId":"686","endLine":92,"endColumn":20},{"ruleId":"683","severity":1,"message":"684","line":104,"column":5,"nodeType":"685","messageId":"686","endLine":104,"endColumn":18},{"ruleId":"683","severity":1,"message":"684","line":21,"column":13,"nodeType":"685","messageId":"686","endLine":21,"endColumn":26},{"ruleId":"683","severity":1,"message":"684","line":61,"column":5,"nodeType":"685","messageId":"686","endLine":61,"endColumn":18},{"ruleId":"683","severity":1,"message":"684","line":87,"column":5,"nodeType":"685","messageId":"686","endLine":87,"endColumn":18},{"ruleId":"683","severity":1,"message":"684","line":224,"column":5,"nodeType":"685","messageId":"686","endLine":224,"endColumn":18},{"ruleId":"683","severity":1,"message":"684","line":305,"column":5,"nodeType":"685","messageId":"686","endLine":305,"endColumn":18},{"ruleId":"683","severity":1,"message":"684","line":23,"column":15,"nodeType":"685","messageId":"686","endLine":23,"endColumn":28},{"ruleId":"683","severity":1,"message":"684","line":76,"column":7,"nodeType":"685","messageId":"686","endLine":76,"endColumn":20},{"ruleId":"683","severity":1,"message":"684","line":101,"column":5,"nodeType":"685","messageId":"686","endLine":101,"endColumn":18},{"ruleId":"683","severity":1,"message":"684","line":126,"column":15,"nodeType":"685","messageId":"686","endLine":126,"endColumn":28},{"ruleId":"683","severity":1,"message":"684","line":180,"column":5,"nodeType":"685","messageId":"686","endLine":180,"endColumn":18},{"ruleId":"683","severity":1,"message":"684","line":205,"column":15,"nodeType":"685","messageId":"686","endLine":205,"endColumn":28},{"ruleId":"683","severity":1,"message":"684","line":264,"column":5,"nodeType":"685","messageId":"686","endLine":264,"endColumn":18},{"ruleId":"683","severity":1,"message":"684","line":44,"column":7,"nodeType":"685","messageId":"686","endLine":44,"endColumn":20},{"ruleId":"683","severity":1,"message":"684","line":58,"column":7,"nodeType":"685","messageId":"686","endLine":58,"endColumn":20},{"ruleId":"683","severity":1,"message":"684","line":114,"column":5,"nodeType":"685","messageId":"686","endLine":114,"endColumn":18},{"ruleId":"687","severity":2,"message":"688","line":45,"column":11,"nodeType":"689","messageId":"690","endLine":45,"endColumn":17},{"ruleId":"683","severity":1,"message":"684","line":63,"column":5,"nodeType":"685","messageId":"686","endLine":63,"endColumn":18},{"ruleId":"687","severity":2,"message":"691","line":12,"column":11,"nodeType":"689","messageId":"690","endLine":12,"endColumn":15},{"ruleId":"687","severity":2,"message":"692","line":13,"column":11,"nodeType":"689","messageId":"690","endLine":13,"endColumn":13},{"ruleId":"687","severity":2,"message":"693","line":14,"column":11,"nodeType":"689","messageId":"690","endLine":14,"endColumn":20},{"ruleId":"687","severity":2,"message":"694","line":16,"column":11,"nodeType":"689","messageId":"690","endLine":16,"endColumn":20},{"ruleId":"683","severity":1,"message":"684","line":52,"column":7,"nodeType":"685","messageId":"686","endLine":52,"endColumn":20},{"ruleId":"683","severity":1,"message":"684","line":57,"column":5,"nodeType":"685","messageId":"686","endLine":57,"endColumn":16},{"ruleId":"683","severity":1,"message":"684","line":62,"column":5,"nodeType":"685","messageId":"686","endLine":62,"endColumn":18},{"ruleId":"695","severity":2,"message":"696","line":48,"column":15,"nodeType":"697","messageId":"698","endLine":48,"endColumn":18,"suggestions":"699"},{"ruleId":"687","severity":2,"message":"700","line":138,"column":11,"nodeType":"689","messageId":"690","endLine":138,"endColumn":22},{"ruleId":"687","severity":2,"message":"701","line":139,"column":11,"nodeType":"689","messageId":"690","endLine":139,"endColumn":22},{"ruleId":"683","severity":1,"message":"684","line":159,"column":7,"nodeType":"685","messageId":"686","endLine":159,"endColumn":20},{"ruleId":"683","severity":1,"message":"684","line":194,"column":5,"nodeType":"685","messageId":"686","endLine":194,"endColumn":18},{"ruleId":"687","severity":2,"message":"702","line":215,"column":31,"nodeType":"689","messageId":"690","endLine":215,"endColumn":47},{"ruleId":"695","severity":2,"message":"696","line":111,"column":19,"nodeType":"697","messageId":"698","endLine":111,"endColumn":22,"suggestions":"703"},{"ruleId":"683","severity":1,"message":"684","line":112,"column":5,"nodeType":"685","messageId":"686","endLine":112,"endColumn":18},{"ruleId":"695","severity":2,"message":"696","line":10,"column":35,"nodeType":"697","messageId":"698","endLine":10,"endColumn":38,"suggestions":"704"},{"ruleId":"695","severity":2,"message":"696","line":57,"column":38,"nodeType":"697","messageId":"698","endLine":57,"endColumn":41,"suggestions":"705"},{"ruleId":"683","severity":1,"message":"684","line":130,"column":9,"nodeType":"685","messageId":"686","endLine":130,"endColumn":22},{"ruleId":"683","severity":1,"message":"684","line":138,"column":7,"nodeType":"685","messageId":"686","endLine":138,"endColumn":19},{"ruleId":"683","severity":1,"message":"684","line":145,"column":5,"nodeType":"685","messageId":"686","endLine":145,"endColumn":16},{"ruleId":"683","severity":1,"message":"684","line":199,"column":7,"nodeType":"685","messageId":"686","endLine":199,"endColumn":20},{"ruleId":"683","severity":1,"message":"684","line":282,"column":7,"nodeType":"685","messageId":"686","endLine":282,"endColumn":20},{"ruleId":"695","severity":2,"message":"696","line":299,"column":19,"nodeType":"697","messageId":"698","endLine":299,"endColumn":22,"suggestions":"706"},{"ruleId":"683","severity":1,"message":"684","line":300,"column":5,"nodeType":"685","messageId":"686","endLine":300,"endColumn":18},{"ruleId":"687","severity":2,"message":"702","line":319,"column":27,"nodeType":"689","messageId":"690","endLine":319,"endColumn":43},{"ruleId":"687","severity":2,"message":"707","line":16,"column":9,"nodeType":"689","messageId":"690","endLine":16,"endColumn":15},{"ruleId":"687","severity":2,"message":"708","line":14,"column":9,"nodeType":"689","messageId":"690","endLine":14,"endColumn":17},{"ruleId":"687","severity":2,"message":"709","line":4,"column":10,"nodeType":"689","messageId":"690","endLine":4,"endColumn":14},{"ruleId":"687","severity":2,"message":"710","line":4,"column":16,"nodeType":"689","messageId":"690","endLine":4,"endColumn":27},{"ruleId":"687","severity":2,"message":"711","line":4,"column":29,"nodeType":"689","messageId":"690","endLine":4,"endColumn":39},{"ruleId":"687","severity":2,"message":"712","line":4,"column":41,"nodeType":"689","messageId":"690","endLine":4,"endColumn":50},{"ruleId":"687","severity":2,"message":"713","line":24,"column":44,"nodeType":"689","messageId":"690","endLine":24,"endColumn":50},{"ruleId":"687","severity":2,"message":"714","line":29,"column":10,"nodeType":"689","messageId":"690","endLine":29,"endColumn":17},{"ruleId":"715","severity":2,"message":"716","line":40,"column":13,"nodeType":"717","messageId":"686","endLine":40,"endColumn":15,"suggestions":"718"},{"ruleId":"715","severity":2,"message":"716","line":63,"column":13,"nodeType":"717","messageId":"686","endLine":63,"endColumn":15,"suggestions":"719"},{"ruleId":"715","severity":2,"message":"716","line":69,"column":13,"nodeType":"717","messageId":"686","endLine":69,"endColumn":15,"suggestions":"720"},{"ruleId":"715","severity":2,"message":"716","line":75,"column":13,"nodeType":"717","messageId":"686","endLine":75,"endColumn":15,"suggestions":"721"},{"ruleId":"687","severity":2,"message":"713","line":11,"column":49,"nodeType":"689","messageId":"690","endLine":11,"endColumn":55},{"ruleId":"687","severity":2,"message":"708","line":20,"column":9,"nodeType":"689","messageId":"690","endLine":20,"endColumn":17},{"ruleId":"683","severity":1,"message":"684","line":40,"column":7,"nodeType":"685","messageId":"686","endLine":40,"endColumn":20},{"ruleId":"683","severity":1,"message":"684","line":32,"column":7,"nodeType":"685","messageId":"686","endLine":32,"endColumn":20},{"ruleId":"683","severity":1,"message":"684","line":45,"column":7,"nodeType":"685","messageId":"686","endLine":45,"endColumn":20},{"ruleId":"687","severity":2,"message":"714","line":17,"column":10,"nodeType":"689","messageId":"690","endLine":17,"endColumn":17},{"ruleId":"695","severity":2,"message":"696","line":70,"column":19,"nodeType":"697","messageId":"698","endLine":70,"endColumn":22,"suggestions":"722"},{"ruleId":"683","severity":1,"message":"684","line":72,"column":7,"nodeType":"685","messageId":"686","endLine":72,"endColumn":20},{"ruleId":"683","severity":1,"message":"684","line":88,"column":7,"nodeType":"685","messageId":"686","endLine":88,"endColumn":20},{"ruleId":"695","severity":2,"message":"696","line":39,"column":54,"nodeType":"697","messageId":"698","endLine":39,"endColumn":57,"suggestions":"723"},{"ruleId":"687","severity":2,"message":"724","line":9,"column":37,"nodeType":"689","messageId":"690","endLine":9,"endColumn":48},{"ruleId":"687","severity":2,"message":"725","line":21,"column":28,"nodeType":"689","messageId":"690","endLine":21,"endColumn":34},{"ruleId":"687","severity":2,"message":"726","line":21,"column":98,"nodeType":"689","messageId":"690","endLine":21,"endColumn":107},{"ruleId":"715","severity":2,"message":"716","line":100,"column":13,"nodeType":"717","messageId":"686","endLine":100,"endColumn":15,"suggestions":"727"},{"ruleId":"715","severity":2,"message":"716","line":169,"column":75,"nodeType":"717","messageId":"686","endLine":169,"endColumn":77,"suggestions":"728"},{"ruleId":"715","severity":2,"message":"716","line":175,"column":88,"nodeType":"717","messageId":"686","endLine":175,"endColumn":90,"suggestions":"729"},{"ruleId":"715","severity":2,"message":"716","line":180,"column":64,"nodeType":"717","messageId":"686","endLine":180,"endColumn":66,"suggestions":"730"},{"ruleId":"687","severity":2,"message":"731","line":8,"column":3,"nodeType":"689","messageId":"690","endLine":8,"endColumn":25},{"ruleId":"687","severity":2,"message":"732","line":15,"column":3,"nodeType":"689","messageId":"690","endLine":15,"endColumn":24},{"ruleId":"687","severity":2,"message":"733","line":16,"column":3,"nodeType":"689","messageId":"690","endLine":16,"endColumn":32},{"ruleId":"687","severity":2,"message":"734","line":17,"column":3,"nodeType":"689","messageId":"690","endLine":17,"endColumn":13},{"ruleId":"687","severity":2,"message":"735","line":60,"column":48,"nodeType":"689","messageId":"690","endLine":60,"endColumn":72},{"ruleId":"715","severity":2,"message":"716","line":62,"column":61,"nodeType":"717","messageId":"686","endLine":62,"endColumn":63,"suggestions":"736"},{"ruleId":"695","severity":2,"message":"696","line":109,"column":64,"nodeType":"697","messageId":"698","endLine":109,"endColumn":67,"suggestions":"737"},{"ruleId":"715","severity":2,"message":"716","line":126,"column":61,"nodeType":"717","messageId":"686","endLine":126,"endColumn":63,"suggestions":"738"},{"ruleId":"687","severity":2,"message":"739","line":142,"column":55,"nodeType":"689","messageId":"690","endLine":142,"endColumn":66},{"ruleId":"715","severity":2,"message":"716","line":273,"column":13,"nodeType":"717","messageId":"686","endLine":273,"endColumn":15,"suggestions":"740"},{"ruleId":"695","severity":2,"message":"696","line":477,"column":52,"nodeType":"697","messageId":"698","endLine":477,"endColumn":55,"suggestions":"741"},{"ruleId":"695","severity":2,"message":"696","line":478,"column":49,"nodeType":"697","messageId":"698","endLine":478,"endColumn":52,"suggestions":"742"},{"ruleId":"695","severity":2,"message":"696","line":479,"column":47,"nodeType":"697","messageId":"698","endLine":479,"endColumn":50,"suggestions":"743"},{"ruleId":"695","severity":2,"message":"696","line":482,"column":52,"nodeType":"697","messageId":"698","endLine":482,"endColumn":55,"suggestions":"744"},{"ruleId":"695","severity":2,"message":"696","line":483,"column":62,"nodeType":"697","messageId":"698","endLine":483,"endColumn":65,"suggestions":"745"},{"ruleId":"695","severity":2,"message":"696","line":484,"column":58,"nodeType":"697","messageId":"698","endLine":484,"endColumn":61,"suggestions":"746"},{"ruleId":"715","severity":2,"message":"716","line":497,"column":47,"nodeType":"717","messageId":"686","endLine":497,"endColumn":49,"suggestions":"747"},{"ruleId":"715","severity":2,"message":"716","line":500,"column":58,"nodeType":"717","messageId":"686","endLine":500,"endColumn":60,"suggestions":"748"},{"ruleId":"715","severity":2,"message":"716","line":507,"column":17,"nodeType":"717","messageId":"686","endLine":507,"endColumn":19,"suggestions":"749"},{"ruleId":"695","severity":2,"message":"696","line":546,"column":52,"nodeType":"697","messageId":"698","endLine":546,"endColumn":55,"suggestions":"750"},{"ruleId":"695","severity":2,"message":"696","line":547,"column":49,"nodeType":"697","messageId":"698","endLine":547,"endColumn":52,"suggestions":"751"},{"ruleId":"695","severity":2,"message":"696","line":548,"column":47,"nodeType":"697","messageId":"698","endLine":548,"endColumn":50,"suggestions":"752"},{"ruleId":"715","severity":2,"message":"716","line":551,"column":17,"nodeType":"717","messageId":"686","endLine":551,"endColumn":19,"suggestions":"753"},{"ruleId":"715","severity":2,"message":"716","line":590,"column":62,"nodeType":"717","messageId":"686","endLine":590,"endColumn":64,"suggestions":"754"},{"ruleId":"715","severity":2,"message":"716","line":600,"column":17,"nodeType":"717","messageId":"686","endLine":600,"endColumn":19,"suggestions":"755"},{"ruleId":"683","severity":1,"message":"684","line":295,"column":11,"nodeType":"685","messageId":"686","endLine":295,"endColumn":24,"suppressions":"756"},{"ruleId":"683","severity":1,"message":"684","line":399,"column":9,"nodeType":"685","messageId":"686","endLine":399,"endColumn":22,"suppressions":"757"},{"ruleId":"683","severity":1,"message":"684","line":411,"column":9,"nodeType":"685","messageId":"686","endLine":411,"endColumn":22,"suppressions":"758"},{"ruleId":"683","severity":1,"message":"684","line":19,"column":5,"nodeType":"685","messageId":"686","endLine":19,"endColumn":17},{"ruleId":"683","severity":1,"message":"684","line":58,"column":5,"nodeType":"685","messageId":"686","endLine":58,"endColumn":18},{"ruleId":"683","severity":1,"message":"684","line":92,"column":5,"nodeType":"685","messageId":"686","endLine":92,"endColumn":18},{"ruleId":"683","severity":1,"message":"684","line":115,"column":5,"nodeType":"685","messageId":"686","endLine":115,"endColumn":17},{"ruleId":"695","severity":2,"message":"696","line":19,"column":27,"nodeType":"697","messageId":"698","endLine":19,"endColumn":30,"suggestions":"759"},{"ruleId":"683","severity":1,"message":"684","line":106,"column":5,"nodeType":"685","messageId":"686","endLine":106,"endColumn":18},{"ruleId":"683","severity":1,"message":"684","line":110,"column":3,"nodeType":"685","messageId":"686","endLine":110,"endColumn":14},{"ruleId":"683","severity":1,"message":"684","line":114,"column":5,"nodeType":"685","messageId":"686","endLine":114,"endColumn":16},{"ruleId":"683","severity":1,"message":"684","line":115,"column":5,"nodeType":"685","messageId":"686","endLine":115,"endColumn":16},{"ruleId":"683","severity":1,"message":"684","line":123,"column":5,"nodeType":"685","messageId":"686","endLine":123,"endColumn":16},{"ruleId":"683","severity":1,"message":"684","line":125,"column":7,"nodeType":"685","messageId":"686","endLine":125,"endColumn":18},{"ruleId":"683","severity":1,"message":"684","line":128,"column":5,"nodeType":"685","messageId":"686","endLine":128,"endColumn":16},{"ruleId":"683","severity":1,"message":"684","line":129,"column":5,"nodeType":"685","messageId":"686","endLine":129,"endColumn":16},{"ruleId":"683","severity":1,"message":"684","line":130,"column":5,"nodeType":"685","messageId":"686","endLine":130,"endColumn":16},{"ruleId":"695","severity":2,"message":"696","line":33,"column":35,"nodeType":"697","messageId":"698","endLine":33,"endColumn":38,"suggestions":"760"},{"ruleId":"695","severity":2,"message":"696","line":34,"column":17,"nodeType":"697","messageId":"698","endLine":34,"endColumn":20,"suggestions":"761"},{"ruleId":"695","severity":2,"message":"696","line":74,"column":16,"nodeType":"697","messageId":"698","endLine":74,"endColumn":19,"suggestions":"762"},{"ruleId":"683","severity":1,"message":"684","line":191,"column":7,"nodeType":"685","messageId":"686","endLine":191,"endColumn":20},{"ruleId":"683","severity":1,"message":"684","line":284,"column":5,"nodeType":"685","messageId":"686","endLine":284,"endColumn":18},{"ruleId":"695","severity":2,"message":"696","line":297,"column":13,"nodeType":"697","messageId":"698","endLine":297,"endColumn":16,"suggestions":"763"},{"ruleId":"683","severity":1,"message":"684","line":323,"column":5,"nodeType":"685","messageId":"686","endLine":323,"endColumn":18},{"ruleId":"695","severity":2,"message":"696","line":332,"column":13,"nodeType":"697","messageId":"698","endLine":332,"endColumn":16,"suggestions":"764"},{"ruleId":"683","severity":1,"message":"684","line":365,"column":5,"nodeType":"685","messageId":"686","endLine":365,"endColumn":18},{"ruleId":"683","severity":1,"message":"684","line":21,"column":13,"nodeType":"685","messageId":"686","endLine":21,"endColumn":26},{"ruleId":"683","severity":1,"message":"684","line":50,"column":5,"nodeType":"685","messageId":"686","endLine":50,"endColumn":18},{"ruleId":"683","severity":1,"message":"684","line":71,"column":5,"nodeType":"685","messageId":"686","endLine":71,"endColumn":18},{"ruleId":"683","severity":1,"message":"684","line":82,"column":5,"nodeType":"685","messageId":"686","endLine":82,"endColumn":18},{"ruleId":"687","severity":2,"message":"765","line":88,"column":11,"nodeType":"689","messageId":"690","endLine":88,"endColumn":15},{"ruleId":"695","severity":2,"message":"696","line":91,"column":39,"nodeType":"697","messageId":"698","endLine":91,"endColumn":42,"suggestions":"766"},{"ruleId":"683","severity":1,"message":"684","line":98,"column":5,"nodeType":"685","messageId":"686","endLine":98,"endColumn":18},{"ruleId":"683","severity":1,"message":"684","line":129,"column":5,"nodeType":"685","messageId":"686","endLine":129,"endColumn":18},{"ruleId":"683","severity":1,"message":"684","line":147,"column":5,"nodeType":"685","messageId":"686","endLine":147,"endColumn":18},{"ruleId":"695","severity":2,"message":"696","line":160,"column":21,"nodeType":"697","messageId":"698","endLine":160,"endColumn":24,"suggestions":"767"},{"ruleId":"695","severity":2,"message":"696","line":160,"column":40,"nodeType":"697","messageId":"698","endLine":160,"endColumn":43,"suggestions":"768"},{"ruleId":"683","severity":1,"message":"684","line":231,"column":5,"nodeType":"685","messageId":"686","endLine":231,"endColumn":18},{"ruleId":"683","severity":1,"message":"684","line":277,"column":5,"nodeType":"685","messageId":"686","endLine":277,"endColumn":18},{"ruleId":"687","severity":2,"message":"769","line":13,"column":3,"nodeType":"689","messageId":"690","endLine":13,"endColumn":20},{"ruleId":"695","severity":2,"message":"696","line":24,"column":44,"nodeType":"697","messageId":"698","endLine":24,"endColumn":47,"suggestions":"770"},{"ruleId":"695","severity":2,"message":"696","line":494,"column":19,"nodeType":"697","messageId":"698","endLine":494,"endColumn":22,"suggestions":"771"},{"ruleId":"695","severity":2,"message":"696","line":511,"column":19,"nodeType":"697","messageId":"698","endLine":511,"endColumn":22,"suggestions":"772"},{"ruleId":"695","severity":2,"message":"696","line":542,"column":19,"nodeType":"697","messageId":"698","endLine":542,"endColumn":22,"suggestions":"773"},{"ruleId":"715","severity":2,"message":"716","line":554,"column":15,"nodeType":"717","messageId":"686","endLine":554,"endColumn":17,"suggestions":"774"},{"ruleId":"687","severity":2,"message":"775","line":6,"column":3,"nodeType":"689","messageId":"690","endLine":6,"endColumn":24},{"ruleId":"683","severity":1,"message":"684","line":144,"column":5,"nodeType":"685","messageId":"686","endLine":144,"endColumn":18},{"ruleId":"683","severity":1,"message":"684","line":176,"column":7,"nodeType":"685","messageId":"686","endLine":176,"endColumn":20},{"ruleId":"683","severity":1,"message":"684","line":190,"column":5,"nodeType":"685","messageId":"686","endLine":190,"endColumn":18},{"ruleId":"687","severity":2,"message":"776","line":7,"column":3,"nodeType":"689","messageId":"690","endLine":7,"endColumn":27},{"ruleId":"695","severity":2,"message":"696","line":73,"column":21,"nodeType":"697","messageId":"698","endLine":73,"endColumn":24,"suggestions":"777"},{"ruleId":"683","severity":1,"message":"684","line":74,"column":7,"nodeType":"685","messageId":"686","endLine":74,"endColumn":20},{"ruleId":"695","severity":2,"message":"696","line":99,"column":21,"nodeType":"697","messageId":"698","endLine":99,"endColumn":24,"suggestions":"778"},{"ruleId":"683","severity":1,"message":"684","line":100,"column":7,"nodeType":"685","messageId":"686","endLine":100,"endColumn":20},{"ruleId":"695","severity":2,"message":"696","line":44,"column":28,"nodeType":"697","messageId":"698","endLine":44,"endColumn":31,"suggestions":"779"},{"ruleId":"695","severity":2,"message":"696","line":64,"column":44,"nodeType":"697","messageId":"698","endLine":64,"endColumn":47,"suggestions":"780"},{"ruleId":"695","severity":2,"message":"696","line":70,"column":30,"nodeType":"697","messageId":"698","endLine":70,"endColumn":33,"suggestions":"781"},{"ruleId":"695","severity":2,"message":"696","line":91,"column":28,"nodeType":"697","messageId":"698","endLine":91,"endColumn":31,"suggestions":"782"},{"ruleId":"695","severity":2,"message":"696","line":128,"column":74,"nodeType":"697","messageId":"698","endLine":128,"endColumn":77,"suggestions":"783"},{"ruleId":"695","severity":2,"message":"696","line":139,"column":88,"nodeType":"697","messageId":"698","endLine":139,"endColumn":91,"suggestions":"784"},{"ruleId":"695","severity":2,"message":"696","line":150,"column":75,"nodeType":"697","messageId":"698","endLine":150,"endColumn":78,"suggestions":"785"},{"ruleId":"695","severity":2,"message":"696","line":161,"column":79,"nodeType":"697","messageId":"698","endLine":161,"endColumn":82,"suggestions":"786"},{"ruleId":"695","severity":2,"message":"696","line":172,"column":87,"nodeType":"697","messageId":"698","endLine":172,"endColumn":90,"suggestions":"787"},{"ruleId":"695","severity":2,"message":"696","line":183,"column":81,"nodeType":"697","messageId":"698","endLine":183,"endColumn":84,"suggestions":"788"},{"ruleId":"695","severity":2,"message":"696","line":205,"column":85,"nodeType":"697","messageId":"698","endLine":205,"endColumn":88,"suggestions":"789"},{"ruleId":"695","severity":2,"message":"696","line":216,"column":102,"nodeType":"697","messageId":"698","endLine":216,"endColumn":105,"suggestions":"790"},{"ruleId":"695","severity":2,"message":"696","line":227,"column":91,"nodeType":"697","messageId":"698","endLine":227,"endColumn":94,"suggestions":"791"},{"ruleId":"695","severity":2,"message":"696","line":238,"column":95,"nodeType":"697","messageId":"698","endLine":238,"endColumn":98,"suggestions":"792"},{"ruleId":"695","severity":2,"message":"696","line":254,"column":43,"nodeType":"697","messageId":"698","endLine":254,"endColumn":46,"suggestions":"793"},{"ruleId":"695","severity":2,"message":"696","line":348,"column":44,"nodeType":"697","messageId":"698","endLine":348,"endColumn":47,"suggestions":"794"},{"ruleId":"683","severity":1,"message":"684","line":355,"column":7,"nodeType":"685","messageId":"686","endLine":355,"endColumn":20},{"ruleId":"695","severity":2,"message":"696","line":365,"column":21,"nodeType":"697","messageId":"698","endLine":365,"endColumn":24,"suggestions":"795"},{"ruleId":"695","severity":2,"message":"696","line":366,"column":37,"nodeType":"697","messageId":"698","endLine":366,"endColumn":40,"suggestions":"796"},{"ruleId":"695","severity":2,"message":"696","line":405,"column":24,"nodeType":"697","messageId":"698","endLine":405,"endColumn":27,"suggestions":"797"},{"ruleId":"695","severity":2,"message":"696","line":406,"column":24,"nodeType":"697","messageId":"698","endLine":406,"endColumn":27,"suggestions":"798"},{"ruleId":"683","severity":1,"message":"684","line":121,"column":5,"nodeType":"685","messageId":"686","endLine":121,"endColumn":17},{"ruleId":"683","severity":1,"message":"684","line":127,"column":5,"nodeType":"685","messageId":"686","endLine":127,"endColumn":17},{"ruleId":"683","severity":1,"message":"684","line":133,"column":5,"nodeType":"685","messageId":"686","endLine":133,"endColumn":17},{"ruleId":"695","severity":2,"message":"696","line":19,"column":18,"nodeType":"697","messageId":"698","endLine":19,"endColumn":21,"suggestions":"799"},{"ruleId":"683","severity":1,"message":"684","line":45,"column":7,"nodeType":"685","messageId":"686","endLine":45,"endColumn":20},{"ruleId":"683","severity":1,"message":"684","line":52,"column":5,"nodeType":"685","messageId":"686","endLine":52,"endColumn":17},{"ruleId":"683","severity":1,"message":"684","line":58,"column":5,"nodeType":"685","messageId":"686","endLine":58,"endColumn":17},{"ruleId":"683","severity":1,"message":"684","line":65,"column":5,"nodeType":"685","messageId":"686","endLine":65,"endColumn":18},"no-console","Unexpected console statement.","MemberExpression","unexpected","@typescript-eslint/no-unused-vars","'gather' is assigned a value but never used.","Identifier","unusedVar","'from' is assigned a value but never used.","'to' is assigned a value but never used.","'direction' is assigned a value but never used.","'timestamp' is assigned a value but never used.","@typescript-eslint/no-explicit-any","Unexpected any. Specify a different type.","TSAnyKeyword","unexpectedAny",["800","801"],"'agentPrompt' is assigned a value but never used.","'voiceConfig' is assigned a value but never used.","'req' is defined but never used. Allowed unused args must match /^_/u.",["802","803"],["804","805"],["806","807"],["808","809"],"'router' is assigned a value but never used.","'supabase' is assigned a value but never used.","'Card' is defined but never used.","'CardContent' is defined but never used.","'CardHeader' is defined but never used.","'CardTitle' is defined but never used.","'userId' is defined but never used. Allowed unused args must match /^_/u.","'loading' is assigned a value but never used.","no-empty","Empty block statement.","BlockStatement",["810"],["811"],["812"],["813"],["814","815"],["816","817"],"'ApiResponse' is defined but never used.","'MicOff' is defined but never used.","'TestTube2' is defined but never used.",["818"],["819"],["820"],["821"],"'ResponseStartedMessage' is defined but never used.","'CreateResponseMessage' is defined but never used.","'CreateConversationItemMessage' is defined but never used.","'ToolBuffer' is defined but never used.","'opts' is defined but never used. Allowed unused args must match /^_/u.",["822"],["823","824"],["825"],"'tz' is defined but never used. Allowed unused args must match /^_/u.",["826"],["827","828"],["829","830"],["831","832"],["833","834"],["835","836"],["837","838"],["839"],["840"],["841"],["842","843"],["844","845"],["846","847"],["848"],["849"],["850"],["851"],["852"],["853"],["854","855"],["856","857"],["858","859"],["860","861"],["862","863"],["864","865"],"'data' is assigned a value but never used.",["866","867"],["868","869"],["870","871"],"'refreshAgentToken' is defined but never used.",["872","873"],["874","875"],["876","877"],["878","879"],["880"],"'GoogleFreeBusyRequest' is defined but never used.","'AgentCalendarIntegration' is defined but never used.",["881","882"],["883","884"],["885","886"],["887","888"],["889","890"],["891","892"],["893","894"],["895","896"],["897","898"],["899","900"],["901","902"],["903","904"],["905","906"],["907","908"],["909","910"],["911","912"],["913","914"],["915","916"],["917","918"],["919","920"],["921","922"],["923","924"],["925","926"],{"messageId":"927","fix":"928","desc":"929"},{"messageId":"930","fix":"931","desc":"932"},{"messageId":"927","fix":"933","desc":"929"},{"messageId":"930","fix":"934","desc":"932"},{"messageId":"927","fix":"935","desc":"929"},{"messageId":"930","fix":"936","desc":"932"},{"messageId":"927","fix":"937","desc":"929"},{"messageId":"930","fix":"938","desc":"932"},{"messageId":"927","fix":"939","desc":"929"},{"messageId":"930","fix":"940","desc":"932"},{"messageId":"941","data":"942","fix":"943","desc":"944"},{"messageId":"941","data":"945","fix":"946","desc":"944"},{"messageId":"941","data":"947","fix":"948","desc":"944"},{"messageId":"941","data":"949","fix":"950","desc":"944"},{"messageId":"927","fix":"951","desc":"929"},{"messageId":"930","fix":"952","desc":"932"},{"messageId":"927","fix":"953","desc":"929"},{"messageId":"930","fix":"954","desc":"932"},{"messageId":"941","data":"955","fix":"956","desc":"944"},{"messageId":"941","data":"957","fix":"958","desc":"944"},{"messageId":"941","data":"959","fix":"960","desc":"944"},{"messageId":"941","data":"961","fix":"962","desc":"944"},{"messageId":"941","data":"963","fix":"964","desc":"944"},{"messageId":"927","fix":"965","desc":"929"},{"messageId":"930","fix":"966","desc":"932"},{"messageId":"941","data":"967","fix":"968","desc":"944"},{"messageId":"941","data":"969","fix":"970","desc":"944"},{"messageId":"927","fix":"971","desc":"929"},{"messageId":"930","fix":"972","desc":"932"},{"messageId":"927","fix":"973","desc":"929"},{"messageId":"930","fix":"974","desc":"932"},{"messageId":"927","fix":"975","desc":"929"},{"messageId":"930","fix":"976","desc":"932"},{"messageId":"927","fix":"977","desc":"929"},{"messageId":"930","fix":"978","desc":"932"},{"messageId":"927","fix":"979","desc":"929"},{"messageId":"930","fix":"980","desc":"932"},{"messageId":"927","fix":"981","desc":"929"},{"messageId":"930","fix":"982","desc":"932"},{"messageId":"941","data":"983","fix":"984","desc":"944"},{"messageId":"941","data":"985","fix":"986","desc":"944"},{"messageId":"941","data":"987","fix":"988","desc":"944"},{"messageId":"927","fix":"989","desc":"929"},{"messageId":"930","fix":"990","desc":"932"},{"messageId":"927","fix":"991","desc":"929"},{"messageId":"930","fix":"992","desc":"932"},{"messageId":"927","fix":"993","desc":"929"},{"messageId":"930","fix":"994","desc":"932"},{"messageId":"941","data":"995","fix":"996","desc":"944"},{"messageId":"941","data":"997","fix":"998","desc":"944"},{"messageId":"941","data":"999","fix":"1000","desc":"944"},{"kind":"1001","justification":"1002"},{"kind":"1001","justification":"1002"},{"kind":"1001","justification":"1002"},{"messageId":"927","fix":"1003","desc":"929"},{"messageId":"930","fix":"1004","desc":"932"},{"messageId":"927","fix":"1005","desc":"929"},{"messageId":"930","fix":"1006","desc":"932"},{"messageId":"927","fix":"1007","desc":"929"},{"messageId":"930","fix":"1008","desc":"932"},{"messageId":"927","fix":"1009","desc":"929"},{"messageId":"930","fix":"1010","desc":"932"},{"messageId":"927","fix":"1011","desc":"929"},{"messageId":"930","fix":"1012","desc":"932"},{"messageId":"927","fix":"1013","desc":"929"},{"messageId":"930","fix":"1014","desc":"932"},{"messageId":"927","fix":"1015","desc":"929"},{"messageId":"930","fix":"1016","desc":"932"},{"messageId":"927","fix":"1017","desc":"929"},{"messageId":"930","fix":"1018","desc":"932"},{"messageId":"927","fix":"1019","desc":"929"},{"messageId":"930","fix":"1020","desc":"932"},{"messageId":"927","fix":"1021","desc":"929"},{"messageId":"930","fix":"1022","desc":"932"},{"messageId":"927","fix":"1023","desc":"929"},{"messageId":"930","fix":"1024","desc":"932"},{"messageId":"927","fix":"1025","desc":"929"},{"messageId":"930","fix":"1026","desc":"932"},{"messageId":"927","fix":"1027","desc":"929"},{"messageId":"930","fix":"1028","desc":"932"},{"messageId":"941","data":"1029","fix":"1030","desc":"944"},{"messageId":"927","fix":"1031","desc":"929"},{"messageId":"930","fix":"1032","desc":"932"},{"messageId":"927","fix":"1033","desc":"929"},{"messageId":"930","fix":"1034","desc":"932"},{"messageId":"927","fix":"1035","desc":"929"},{"messageId":"930","fix":"1036","desc":"932"},{"messageId":"927","fix":"1037","desc":"929"},{"messageId":"930","fix":"1038","desc":"932"},{"messageId":"927","fix":"1039","desc":"929"},{"messageId":"930","fix":"1040","desc":"932"},{"messageId":"927","fix":"1041","desc":"929"},{"messageId":"930","fix":"1042","desc":"932"},{"messageId":"927","fix":"1043","desc":"929"},{"messageId":"930","fix":"1044","desc":"932"},{"messageId":"927","fix":"1045","desc":"929"},{"messageId":"930","fix":"1046","desc":"932"},{"messageId":"927","fix":"1047","desc":"929"},{"messageId":"930","fix":"1048","desc":"932"},{"messageId":"927","fix":"1049","desc":"929"},{"messageId":"930","fix":"1050","desc":"932"},{"messageId":"927","fix":"1051","desc":"929"},{"messageId":"930","fix":"1052","desc":"932"},{"messageId":"927","fix":"1053","desc":"929"},{"messageId":"930","fix":"1054","desc":"932"},{"messageId":"927","fix":"1055","desc":"929"},{"messageId":"930","fix":"1056","desc":"932"},{"messageId":"927","fix":"1057","desc":"929"},{"messageId":"930","fix":"1058","desc":"932"},{"messageId":"927","fix":"1059","desc":"929"},{"messageId":"930","fix":"1060","desc":"932"},{"messageId":"927","fix":"1061","desc":"929"},{"messageId":"930","fix":"1062","desc":"932"},{"messageId":"927","fix":"1063","desc":"929"},{"messageId":"930","fix":"1064","desc":"932"},{"messageId":"927","fix":"1065","desc":"929"},{"messageId":"930","fix":"1066","desc":"932"},{"messageId":"927","fix":"1067","desc":"929"},{"messageId":"930","fix":"1068","desc":"932"},{"messageId":"927","fix":"1069","desc":"929"},{"messageId":"930","fix":"1070","desc":"932"},{"messageId":"927","fix":"1071","desc":"929"},{"messageId":"930","fix":"1072","desc":"932"},{"messageId":"927","fix":"1073","desc":"929"},{"messageId":"930","fix":"1074","desc":"932"},{"messageId":"927","fix":"1075","desc":"929"},{"messageId":"930","fix":"1076","desc":"932"},"suggestUnknown",{"range":"1077","text":"1078"},"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct.","suggestNever",{"range":"1079","text":"1080"},"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of.",{"range":"1081","text":"1078"},{"range":"1082","text":"1080"},{"range":"1083","text":"1078"},{"range":"1084","text":"1080"},{"range":"1085","text":"1078"},{"range":"1086","text":"1080"},{"range":"1087","text":"1078"},{"range":"1088","text":"1080"},"suggestComment",{"type":"1089"},{"range":"1090","text":"1091"},"Add comment inside empty block statement.",{"type":"1089"},{"range":"1092","text":"1091"},{"type":"1089"},{"range":"1093","text":"1091"},{"type":"1089"},{"range":"1094","text":"1091"},{"range":"1095","text":"1078"},{"range":"1096","text":"1080"},{"range":"1097","text":"1078"},{"range":"1098","text":"1080"},{"type":"1089"},{"range":"1099","text":"1091"},{"type":"1089"},{"range":"1100","text":"1091"},{"type":"1089"},{"range":"1101","text":"1091"},{"type":"1089"},{"range":"1102","text":"1091"},{"type":"1089"},{"range":"1103","text":"1091"},{"range":"1104","text":"1078"},{"range":"1105","text":"1080"},{"type":"1089"},{"range":"1106","text":"1091"},{"type":"1089"},{"range":"1107","text":"1091"},{"range":"1108","text":"1078"},{"range":"1109","text":"1080"},{"range":"1110","text":"1078"},{"range":"1111","text":"1080"},{"range":"1112","text":"1078"},{"range":"1113","text":"1080"},{"range":"1114","text":"1078"},{"range":"1115","text":"1080"},{"range":"1116","text":"1078"},{"range":"1117","text":"1080"},{"range":"1118","text":"1078"},{"range":"1119","text":"1080"},{"type":"1089"},{"range":"1120","text":"1091"},{"type":"1089"},{"range":"1121","text":"1091"},{"type":"1089"},{"range":"1122","text":"1091"},{"range":"1123","text":"1078"},{"range":"1124","text":"1080"},{"range":"1125","text":"1078"},{"range":"1126","text":"1080"},{"range":"1127","text":"1078"},{"range":"1128","text":"1080"},{"type":"1089"},{"range":"1129","text":"1091"},{"type":"1089"},{"range":"1130","text":"1091"},{"type":"1089"},{"range":"1131","text":"1091"},"directive","",{"range":"1132","text":"1078"},{"range":"1133","text":"1080"},{"range":"1134","text":"1078"},{"range":"1135","text":"1080"},{"range":"1136","text":"1078"},{"range":"1137","text":"1080"},{"range":"1138","text":"1078"},{"range":"1139","text":"1080"},{"range":"1140","text":"1078"},{"range":"1141","text":"1080"},{"range":"1142","text":"1078"},{"range":"1143","text":"1080"},{"range":"1144","text":"1078"},{"range":"1145","text":"1080"},{"range":"1146","text":"1078"},{"range":"1147","text":"1080"},{"range":"1148","text":"1078"},{"range":"1149","text":"1080"},{"range":"1150","text":"1078"},{"range":"1151","text":"1080"},{"range":"1152","text":"1078"},{"range":"1153","text":"1080"},{"range":"1154","text":"1078"},{"range":"1155","text":"1080"},{"range":"1156","text":"1078"},{"range":"1157","text":"1080"},{"type":"1089"},{"range":"1158","text":"1091"},{"range":"1159","text":"1078"},{"range":"1160","text":"1080"},{"range":"1161","text":"1078"},{"range":"1162","text":"1080"},{"range":"1163","text":"1078"},{"range":"1164","text":"1080"},{"range":"1165","text":"1078"},{"range":"1166","text":"1080"},{"range":"1167","text":"1078"},{"range":"1168","text":"1080"},{"range":"1169","text":"1078"},{"range":"1170","text":"1080"},{"range":"1171","text":"1078"},{"range":"1172","text":"1080"},{"range":"1173","text":"1078"},{"range":"1174","text":"1080"},{"range":"1175","text":"1078"},{"range":"1176","text":"1080"},{"range":"1177","text":"1078"},{"range":"1178","text":"1080"},{"range":"1179","text":"1078"},{"range":"1180","text":"1080"},{"range":"1181","text":"1078"},{"range":"1182","text":"1080"},{"range":"1183","text":"1078"},{"range":"1184","text":"1080"},{"range":"1185","text":"1078"},{"range":"1186","text":"1080"},{"range":"1187","text":"1078"},{"range":"1188","text":"1080"},{"range":"1189","text":"1078"},{"range":"1190","text":"1080"},{"range":"1191","text":"1078"},{"range":"1192","text":"1080"},{"range":"1193","text":"1078"},{"range":"1194","text":"1080"},{"range":"1195","text":"1078"},{"range":"1196","text":"1080"},{"range":"1197","text":"1078"},{"range":"1198","text":"1080"},{"range":"1199","text":"1078"},{"range":"1200","text":"1080"},{"range":"1201","text":"1078"},{"range":"1202","text":"1080"},{"range":"1203","text":"1078"},{"range":"1204","text":"1080"},[1399,1402],"unknown",[1399,1402],"never",[3293,3296],[3293,3296],[658,661],[658,661],[2193,2196],[2193,2196],[10704,10707],[10704,10707],"block",[1486,1486]," /* empty */ ",[2145,2145],[2286,2286],[2409,2409],[1886,1889],[1886,1889],[1106,1109],[1106,1109],[4252,4252],[6693,6693],[6952,6952],[7141,7141],[2239,2239],[5154,5157],[5154,5157],[5854,5854],[10603,10603],[20047,20050],[20047,20050],[20121,20124],[20121,20124],[20207,20210],[20207,20210],[20505,20508],[20505,20508],[20592,20595],[20592,20595],[20689,20692],[20689,20692],[21466,21466],[21608,21608],[22031,22031],[23964,23967],[23964,23967],[24038,24041],[24038,24041],[24123,24126],[24123,24126],[24302,24302],[25991,25991],[26505,26505],[509,512],[509,512],[846,849],[846,849],[867,870],[867,870],[1992,1995],[1992,1995],[8984,8987],[8984,8987],[10054,10057],[10054,10057],[2545,2548],[2545,2548],[4165,4168],[4165,4168],[4184,4187],[4184,4187],[564,567],[564,567],[14710,14713],[14710,14713],[15233,15236],[15233,15236],[16185,16188],[16185,16188],[16523,16523],[2285,2288],[2285,2288],[2980,2983],[2980,2983],[1029,1032],[1029,1032],[1411,1414],[1411,1414],[1525,1528],[1525,1528],[1994,1997],[1994,1997],[2891,2894],[2891,2894],[3230,3233],[3230,3233],[3545,3548],[3545,3548],[3863,3866],[3863,3866],[4205,4208],[4205,4208],[4545,4548],[4545,4548],[5233,5236],[5233,5236],[5612,5615],[5612,5615],[5974,5977],[5974,5977],[6345,6348],[6345,6348],[6729,6732],[6729,6732],[9113,9116],[9113,9116],[9677,9680],[9677,9680],[9727,9730],[9727,9730],[10643,10646],[10643,10646],[10692,10695],[10692,10695],[347,350],[347,350]]